\chapter{Lecture: Property-Based Testing}
\startlecture

\begin{instructor}

\section*{Lecture Outline}

\begin{enumerate}

\item  Sometimes, writing individual test cases isn't enough or isn't desirable.
  It can help to think of properties instead of test cases.

\item Work through the split and join example.

\item Write some list processing functions: reverse, concat, map

\item Some properties of list processing functions: reverse and concat,
  concat distributes over map, reverse reverse is identity. \emph{Write these
    as functions}.

\item Show ScalaCheck. Show the generators generating things.

\item Write a tail recursive fibonnaci and check that the two implementations
are equivalent.

\item Write properties of join lists.

\end{enumerate}

\end{instructor}

%% Sometimes, testing individual functions is not enough or isn't desirable. In these
%% situations, it helps to come up with \emph{properties} of functions or groups of
%% related functions.


%% \begin{figure}
%% \begin{lstlisting}
%% def split(sep: Char, astring: String): List[String] = {
%%   def splitRec(chars: List[Char]): List[String] = {
%%     val prefix = chars.takeWhile(ch => ch != sep).mkString
%%     chars.dropWhile(ch => ch != sep) match {
%%       case Nil => Nil
%%       case _ :: suffix => prefix :: splitRec(suffix)
%%     }
%%   }
%%   splitRec(astring.toList)
%% }

%% def join(sep: Char, strings: List[String]): String = strings match {
%%   case Nil => ""
%%   case List(x) => x
%%   case x1 :: x2 :: xs => x1 + sep + join(sep, x2 :: xs)
%% }
%% \end{lstlisting}
%% \caption{Splitting a string on a separator.}\label{split_buggy}
%% \end{figure}

%% For example, consider the function in \cref{split_buggy} that splits strings on a
%% separator character. Therefore, \lstinline|split(',', "Hello, world!")| should
%% produce \lstinline|List("Hello", " world!")|.
%% How would we check that the implementation is correct? The standard approach is to write
%% individual test cases. The key to good tests is to think of examples that exercise
%% the corner cases of a function. An alternative approach to testing is to think of
%% properties that the function should exhibit. A basic property of the
%% result of \lstinline|split| is that we should be able to reassemble the original
%% string by interspersing the separator with the output list.



\begin{figure}
  \scalafile{code/scalacheck/src/test/scala/ListTestSuite.scala}
  \caption{Checking properties of simple list processing functions.}
\end{figure}

\begin{figure}
  \scalafile{code/scalacheck/src/test/scala/FibTestSuite.scala}
  \caption{Checking that an optimized implementation of the fibonacci
    function is equivalent to the naive implementation.}
  
\end{figure}

\begin{figure}
  \scalafile{code/scalacheck/src/test/scala/JoinListSuite.scala}
  \caption{Checking properties of join lists.}
\end{figure}
