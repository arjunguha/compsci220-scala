\chapter{Advanced Streams}
\startlecture

\begin{instructor}

  \section*{Lecture Outline}

  \begin{enumerate}

  \item We can use \lstinline|Stream.from(n)| to produce an infinite stream of integers.

  \item We can also produce an infinite stream of fractions:

    \begin{lstlisting}
    Stream.from(1).map(m => Stream.from(1).map(n => s"$m/$n")).flatten
    \end{lstlisting}

  \item This stream starts with the sequence \lstinline|1/1|, \lstinline|1/2|, \lstinline|1/3|, etc.
    so we will never reach \lstinline|2/1|.

  \item Draw a few rows of the table of fractions and show that we need to walk the diagonals.

  \item Intuition: don't flatten the stream of streams above by waiting for the first inner stream
    to terminate. Instead, produce one element from the first stream, then one element from the
    first two streams each, then one element from the first three streams each, and so on.

    \begin{lstlisting}
  def diags[A](xss: Stream[Stream[A]], yss: Stream[Stream[A]]): Stream[A] = {
    if (yss.isEmpty) xss.map(_.head) #::: diags(xss.map(_.tail), yss)
    else xss.map(_.head) #::: diags(yss.head #:: xss.map(_.tail), yss.tail)
  }

  val rats1 = diags(Stream(), nats.map(m => nats.map(n => Rat(m, n))))
    \end{lstlisting}

  \item Unfortunately, this produces repeated numbers!

  \item Enumerating the rationals directly produces duplicates. So, we
    need to map rationals to some other object such that two equal rationals map to the
    same object and enumerate those objects.

  \item Consider the GCD. Calculate GCD by hand for 3 equal rationals. Show that GCD is different
    but operations are the same.

  \item Consider instrumented version of GCD that produces a trace:

    \begin{lstlisting}
      def igcd(m: Int, n: Int): (Int, List[Boolean]) = {
        if (m < n) igcd(m, n - m).map { case (r, trace) => (r, false :: trace) }
        else if (m > n) igcd(m - n, n).map { case (r, trace) => (r, true :: trace) }
        else (m, Nil)
      }
    \end{lstlisting}

    Two equal rationals always have the same trace (but different GCDs)

  \item We can invert the function

    \begin{lstlisting}
    def ungcd(r: Int, trace: List[Boolean]): (Int, Int) = trace match {
      case Nil => (r, r)
      case false :: rest => ungcd(r, rest).map { case (m, n) => (m, n + m) }
      case true :: rest => ungcd(r, rest).map { case (m, n) => (m + n, n) }
    }
    \end{lstlisting}

  \item If we fix $r = 1$ (or any other value) and we enumerate boolean strings, it is easy to
    solve the problem.

  \end{enumerate}

\end{instructor}

\section{Enumerating the rationals}

In this lecture, we discussed two sophisticated uses of streams that are presented in the following
article:

\href{http://dl.acm.org/citation.cfm?id=1132893}{http://dl.acm.org/citation.cfm?id=1132893}

If you're off-campus, you may not be able to access the article. (It will prompt you to buy it.) You can visit this address
when you're connected to \emph{eduroam} or any other on-campus network to get the article for free. We only discussed Sections 1 and 2.

The code from class is included below. It simply translates the code in the article to Scala

\scalafile{code/Rationals.scala}
