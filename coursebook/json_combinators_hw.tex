\chapter{Project: Programming with combinators}
\savepdf{project-json-combinators}

\section{Introduction}
In the past assignments, we looked at how Scala uses first class functions
to allow for a greater level of composition in programs. In this assignment,
you will be implementing \textit{functional combinators} that allow you
build up a library using a small and composable core of program primitives.
\\ \\

\section{Working with combinators}
For this assignment, you will be working with the case class \texttt{JsonProc}
(documented in hw.combinator.JsonProc). We will be using this class and its 
member methods to implement combinators. 
\\ \\
\noindent First, let's take a look at the definition of the \texttt{JsonProc}
class:
\begin{scalacode}
case class JsonProc[S, T](val func: S => List[T])
\end{scalacode}
An instance of \texttt{JsonProc} takes a function that consumes a value of type
\texttt{S} and returns a list of values of type \texttt{T}. The reason for
producing a list of values instead of a single value will become clearer later
on. For now, we can take a look at a combinator that we can implement using
the \texttt{JsonProc} class. 
\\ \\
\noindent \textbf{Description}: Implement a combinator that extract the value
associated with a a key in a \texttt{JsonDict}. If the input is not a
\texttt{JsonDict}, or if the key does not exist, return an empty list.
\begin{scalacode}
def key(key: String): JsonProc[Json, Json] = new JsonProc(json => 
    json match {
      case JsonDict(map) => map.get(JsonString(key)) match {
        case Some(value) => List(value)
        case None => Nil
      }
      case v => Nil
    })
\end{scalacode}
We have now defined the \texttt{key} combinator. To use this combinator, we
can simply extract the \texttt{func} value from the resulting \texttt{JsonProc}:
\begin{scalacode}
// represents the json { "a": 1 }
val json = JsonDict(Map(JsonString("a") -> JsonNumber(1))) 
val a: JsonProc[Json, Json] = key("a").func(json) // a = List(JsonNumber(1))
\end{scalacode}
This however, is not an interesting use case of the combinator since we could
have simply used a function to accomplish the same goal. Consider, however, the
case where we have to extract a value from a nested \texttt{JsonDict}:
\begin{scalacode}
// represents the json { "a": { "b": 2 } }
val nestedJson = JsonDict(Map(JsonString("a") -> JsonDict(Map(JsonString("b") -> JsonNumber(2)))))
\end{scalacode}
To extract this key, we will make use of the method \texttt{>>>} defined on
\texttt{JsonProc}. \texttt{>>>} allows us to compose two \texttt{JsonProc}
sequentially. It takes the result from the first \texttt{JsonProc}, which is a
list, applies the second \texttt{JsonProc} to each element, and flattens the result
to get another list of values.
\begin{scalacode}
val getAthenB: JsonProc[Json, Json] = key("a") >>> key("b")
val b = getAthenB.func(nestedJson) // b = List(JsonNumber(2))
\end{scalacode}
This use case also clarifies why the function inside \texttt{JsonProc} returns
a list of values: What if the input to \texttt{getAthenB} did not have a key
called ``a''. In that case, the composition operator would have received an
empty list and wouldn't have applied the second combinator on anything else.

\section{Preliminaries}
Using the command-line, run the command
\verb|sbt new umass-compsci220/scala-json-combinators.g8|. When prompted for
a project name, press ``Enter'' to accept the default name. This will create
the directory \verb|scala-json-combinators|. Implement the functions described
below in the file \verb|scala-json-combinators/src/main/scala/Main.scala|.

\section{Programming Task}
For this assignment, you will be implementing several combinators that operate
on Json values. Additionally, you will be using these combinators to implement
various extractors on Json values.

\begin{enumerate}
    \item Implement a combinator that extracts the number from an input
    \texttt{JsonNumber}. If the input is not a \texttt{JsonNumber}, return the
    empty list. Otherwise, return a singleton list with just the number.
    \begin{scalacode}
    def number: JsonProc[Json,Double]
    \end{scalacode}

    \item Implement a combinator that extracts the given \texttt{index} from
    a \texttt{JsonArray}. If the input is not a \texttt{JsonArray} or if the index
    is not present in the array, return an empty list. Otherwise, return
    a singleton list with just the Json value at the given index.
    \begin{scalacode}
    def index(n: Int): JsonProc[Json,Json]
    \end{scalacode}

    \item Implement a combinator that returns all the elements in a
    \texttt{JsonArray}. If the input is not a \texttt{JsonArray}, return the
    empty list.
    \begin{scalacode}
    def iter: JsonProc[Json,Json]
    \end{scalacode}

    \item Implement a combinator that extracts all the leaf values from an
    input Json value. Leaf values can only be \texttt{JsonNull},
    \texttt{JsonString}, \texttt{JsonNumber}, and \texttt{JsonBool}.
    \begin{scalacode}
    def recur: JsonProc[Json, Json]
    \end{scalacode}

    % Getting students to use >>> to make sure they understand JsonProcs
    \item Using the combinators defined so far and the \texttt{>>>} method,
    implement a function that takes a \texttt{JsonArray} and adds all the
    numbers in it. \textbf{You may not use pattern matching or recursion to
    implement this function}. You may only use combinators.
    \begin{scalacode}
    def addAll(json: Json): Double
    \end{scalacode}

    \item Implement the function allNumbers that extracts all the numbers from
    an arbitrarily nested Json value. The function should return a list containing
    all the numbers in the input Json value. The order of numbers does not
    matter. \textbf{You may not use pattern matching or recursion to
    implement this function}. You may only use
    combinators.
    \begin{scalacode}
    def allNumbers(json: Json): List[Double]
    \end{scalacode}

    \item Implement a generic combinator that returns tuple that contains
    two copies of the input. This combinator will allow us to perform two
    separate operation on a given input.
    \begin{scalacode}
    def split[S]: JsonProc[S, (S, S)]
    \end{scalacode}

    \item Implement a generic combinator that takes tuple with two values
    of the same type and returns a list containing both the elements. This
    combinator will allow us to combine two separate inputs into one output.
    \begin{scalacode}
    def combine[A]: JsonProc[(A, A), A]
    \end{scalacode}

    \item Implement the combinator \texttt{first}. The input to first is a
    generic \texttt{JsonProc} called \texttt{proc} that consumes a value of
    type `A' and returns a value of type `B'. The output of \texttt{first} is
    a \texttt{JsonProc} that consumes a tuple and returns a list of tuples in
    which the first element has been transformed by \texttt{proc}. This
    combinator will allow us to operate on one of copies generated by split.
    \begin{scalacode}
    def first[A, B, C](proc: JsonProc[A, B]): JsonProc[(A, C), (B, C)]
    \end{scalacode}

    \item Implement the combinator \texttt{second}. The input to first is a
    generic \texttt{JsonProc} called \texttt{proc} that consumes a value of
    type `A' and returns a value of type `B'. The output of \texttt{first} is
    a \texttt{JsonProc} that consumes a tuple and returns a list of tuples in
    which the second element has been transformed by \texttt{proc}. This
    combinator will allow us to operate on one of copies generated by split.
    \begin{scalacode}
    def second[A, B, C](proc: JsonProc[A, B]): JsonProc[(C, A), (C, B)]
    \end{scalacode}

    \item Implement the function extractNameAndAge that consumes a Json value
    and extracts the ``name'' and ``age'' fields if the value is a
    \texttt{JsonDict}. If the extraction is successful, return the values in
    tuple wrapped in \texttt{Some} (value of name first, then age). In every
    other case, return \texttt{None}. \textbf{You may not use pattern
    matching or recursion to implement this function}. You may only use
    combinators.
    \begin{scalacode}
    def extractNameAndAge(json: Json): Option[(Json, Json)]
    \end{scalacode}

    \item Implement the function calculateAge that consumes a Json value
    and calculates the age using the ``born'' and ``died'' fields. If they
    exist, both ``born'' and ``died'' keys have \texttt{JsonNumber}s associated
    to them. If the age can be calculated, return it wrapped in \texttt{Some}.
    In every other case, return \texttt{None}. \textbf{You may not use pattern
    matching or recursion to implement this function}. You may only use
    combinators.
    \begin{scalacode}
    def calculateAge(json: Json): Option[Double]
    \end{scalacode}

\end{enumerate}

\input{handin}
