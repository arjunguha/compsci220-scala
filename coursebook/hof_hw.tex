\newhw{Higher-Order Functions}

In this assignment, you'll write several higher-order functions over lists.

\textbf{Restrictions}: You must not use Scala's builtin methods. In particular, you must not
use any of the methods on Scala's lists. However, feel free to use any of the list-processing
functions that we've written in class or the code you wrote for the previous assignment.
You
may not use imperative features, such as \scalainline{while} and \scalainline{var}.
You should also write any helper functions you think are necessary. You
may also use functions you write for one part of the assignment to solve
another part of the assignment.

\section{Preliminaries}

You should create a directory-tree that looks like this:

\dirtree{%
.1 ./hof.
.2 project.
.3 plugins.sbt.
.2 src.
.3 main.
.4 scala.\DTcomment{Your solution goes here}.
.3 test.
.4 scala\DTcomment{Yours tests go here}.
}

The \texttt{project/plugins.sbt} file must have exactly this line:

\scalafile{../hw/hof/template/project/plugins.sbt}

\section{Exercises}

\begin{figure}
\scalafile{../hw/hof/template/src/main/scala/HOF.scala}
\caption{Solution template.}
\label{hof_template}
\end{figure}

Within an object called \texttt{HOF}, implement the following functions.
(You may use the template in \cref{hof_template})

\begin{enumerate}

\item
Write the \scalainline{map2} function, which maps over two lists:

\begin{scalacode}
def map2[A,B,C](f: (A, B) => C, alist1: List[A], alist2: List[B]): List[C]

test("map2 with add") {
  def add(x: Int, y: Int): Int = x + y
  assert(map2(add, List(1, 2, 3), List(4, 5, 6)) == List(5, 7, 9))
}
\end{scalacode}

You may assume that \scalainline{alist1} and \scalainline{alist2} have the same
length (i.e., do whatever you think is reasonable).

\item
Scala lets you write \scalainline{(x, y)} to create \emph{tuples}. For example:

\begin{scalacode}
val nameSsn: (String, Int) = ("John Smith", 19970293)
val emailAdmin: (String, Boolean) = ("carberry@cs.umass.edu", true)
val xy: (Double, Double) = (3.0, 4.0)
\end{scalacode}

Tuples are a convenient way to package two related values together, without
having to create a new type to hold them. You can use pattern matching to
extract the components of tuples, or simply write \scalainline{xy._1}
and \scalainline{xy._2} to access the first and second component respectively.

Write the \scalainline{zip} function, which tuples corresponding elements in a list:

\begin{scalacode}
def zip[A,B](alist1: List[A], alist2: List[B]): List[(A, B)]

test("zip test 1") {
  assert(zip(List(1, 2, 3), List(4, 5, 6)) == List((1,4), (2, 5), (3, 6)))
}

test("zip test 2") {
  assert(zip(List("George", "Teddy"), List("Washington", "Roosevelt")) ==
         List(("George", "Washington"), ("Teddy", "Roosevelt")))
}
\end{scalacode}

\item
Write the function \scalainline{flatten}, which flattens a nested list:

\begin{scalacode}
def flatten[A](alist: List[List[A]]): List[A]

test("flatten test") {
  assert(flatten(List(List(1, 2), List(3, 4))) == List(1, 2, 3, 4))
}
\end{scalacode}

\item
Write the \scalainline{flatten3} function, which flattens a triple-nested list:

\begin{scalacode}
def flatten3[A](alist: List[List[List[A]]]): List[A]
\end{scalacode}

\item
Write the \scalainline{buildList} function, which builds a list of the given length. Each
element is determined by applying \scalainline{f} to the index of the element:

\begin{scalacode}
def buildList[A](length: Int, f: Int => A): List[A]

test("buildList test") {
  def f(x: Int) = x
  assert(buildList(10, f) == List(0, 1, 2, 3, 4, 5, 6, 7, 8, 9))
}
\end{scalacode}

\item
Write the \scalainline{mapList} function, which maps each element to a list and returns
the list of all results:

\begin{scalacode}
def mapList[A, B](alist: List[A], f: A => List[B]): List[B]

test("mapList test") {
  def f(n: Int): List[Int] = buildList(n, (_: Int) => n)
  assert(mapList(List(1, 2, 3), f) == List(1, 2, 2, 3, 3, 3))
}
\end{scalacode}

\item
Write the \scalainline{partition(f, alist)} function, which splits a list into
two sub-lists, where the first list has all the elements of \scalainline{alist}
on which \scalainline{f} produces \scalainline{true} and the second
list has all the elements of \scalainline{alist} on which \scalainline{f}
produces \scalainline{false}.

The ordering of elements in the two sub-lists should be the same
as in \scalainline{alist}.

\begin{scalacode}
def partition[A](f: A => Boolean, alist: List[A]): (List[A], List[A])

def isEven(n: Int): Boolean = n % 2 == 0

test("partition test 1") {
  assert(partition(isEven, List(1,2,3,4,5,6)) == (List(2,4,6), List(1,3,5)))
}

test("partition test 2") {
  assert(partition(isEven, List(2,4,6)) == (List(2,4,6), Nil))

test("partition test 3") {
  assert(partition(isEven, List(1,3,5)) == (Nil, List(1,3,5)))
}
\end{scalacode}

\item
Write the \scalainline{merge(lessThan, alist1, alist2)} function, which merges
the two elements of the two lists. You should assume that \scalainline{alist1}
and \scalainline{alist2} are sorted by the ordering defined by \scalainline{lessThan}.
the produced list should also be sorted by the same ordering.

\begin{scalacode}
def merge[A](lessThan: (A, A) => Boolean, alist1: List[A], alist2: List[A]): List[A]

def lt(x: Int, y: Int): Boolean = x < y

test("merge test 1") {
  assert(merge(lt, List(5, 3, 1), List(10, 6, 0)) == List(10, 6, 5, 3, 1, 0))
}
\end{scalacode} 


\item
Write the \scalainline{sort(lessThan, alist)} function, which sorts \scalainline{alist} by the ordering
defined by \scalainline{lessThan}.

\begin{scalacode}
def sort[A](lessThan: (A, A) => Boolean, alist: List[A]): List[A]


test("sort test 1") {
  assert(sort(lt, List(5,1,2,3,4,5)) == List(5,5,4,3,2,1))
}
\end{scalacode} 

\end{enumerate}

\input{handin}
