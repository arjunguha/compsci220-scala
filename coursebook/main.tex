\documentclass[9pt]{extbook}
\usepackage{pervasives}

\title{COMPSCI220 Course Book}

\begin{document}

\maketitle
\tableofcontents

\include{introduction}
\include{lists_hw}
\include{patterns}

\newdiscussion{Scala Technical Support}


\include{hof}
\include{hof_hw}

\include{hof2}

\include{discussion_hof}
\input{errors}
\input{wrangling_hw}


\newdiscussion{Continuation of Previous Discussion (Feb 10)}

The previous discussion is far too long! It spilled into this one.

\include{stack_machines}

\newlecture

This lecture actually uses a slide deck! These are not the lecture notes.
see the file \texttt{/website/lectures/gc.pdf} for a copy of the slides.
The original slides are on Notability on Arjun's iPad.


\include{fundata_hw}
\include{expression_problem}

\include{error_handling_discussion}

\include{tictactoe_hw}

\include{subtyping}
\include{tictactoe_discussion}
\include{bounded_quantification}
\include{generics_hw}

\include{variance_and_tc}

\input{samefringe}
\input{nqueens}
\input{gadts}

\input{implicit_classes}

\input{sudoku}

\input{sudoku_discussion}

\input{streams}
\input{streams2}

\input{regex}

\input{implicits_hw}

\input{regex2}

\include{parsing}

\input{regex_hw}

\input{parsing_hw}

\newdiscussion{Implicits (Apr 6)}

This discussion will cover the first two questions of Homework 8, which asks you to use Scala implicits to wrap ``ugly'' Java interfaces with ``pretty'' Scala interfaces.

\section{What you need to do}

We will be completing HW 8, programming tasks 1 and 2 in class.  These two assignments are reproduced below.

\begin{enumerate}

  \item We should be able to construct paths by using the slash-operator to separate strings. For example, the expression \scalainline{"usr" / "bin" / "scala"} should be equivalent to the expression \scalainline{Paths.get("usr", "bin", "scala")}. 
  \item Similarly, given two paths, we should be able to join them using the slash-operator. For example, if \scalainline{p1} is \scalainline{"usr" / "local"} and \scalainline{p2} is \scalainline{"bin" / "scala"} then \scalainline{p1 / p2} should be equivalent to \scalainline{Paths.get("usr", "local", "bin", "scala")}. 
\end{enumerate}

\section{Hints}

First hint: this assignment requires \emph{neither} Scala implicit functions to work \emph{nor} Scala implicit function parameters.  You \emph{only} need Scala implicit classes.  If you do not remember the difference between these sorts of implicits, I strongly suggest that you familiarize yourself with their definitions.

Second hint: remember that Scala implicit classes require a few ingredients in order to work.  The most important ingredients are described here, but you can find the complete list of rules at: \url{https://www.artima.com/pins1ed/implicit-conversions-and-parameters.html#21.2}

\begin{enumerate}
  \item You must create a class and mark it as \scalainline{implicit}.
  \item Implicit classes must be defined inside an \scalainline{object}, \scalainline{trait}, or \scalainline{class}.
  \item The implicit class must be visible from the scope of the expression that you want rewritten.
  \item The compiler \emph{will not} attempt to rewrite an expression to use an implicit class if it type-checks as-is.  In other words, the expression must fail to type check \emph{unless} the compiler can find an implicit class in scope that causes the type check to succeed.
\end{enumerate}

\begin{instructor}
\section{Solutions}
  
Note that I have elided parts of the solution that are not directly related to the first two programming tasks.  The reason is that I want students to have to think about the rest of the solution on their own.

\begin{scalacode}
  import java.nio.file._

  object PathImplicits {  
    implicit class RichPath(p: Path) {
      def /(p2: String) : Path = p.resolve(p2)
      def /(p2: Path) : Path = p.resolve(p2)
    }

    implicit class RichString(s: String) {
      def /(s2: String) : Path = Paths.get(s).resolve(s2)
      def /(p2: Path) : Path = Paths.get(s).resolve(p2)
    }
  }
\end{scalacode}
  
\end{instructor}


\newdiscussion{Regular Expressions (Apr 13)}

A \emph{regular expression}, also known as ``regex,'' is a powerful feature of most modern programming languages.  Regexes allow programmers to build sophisticated string-manipulating functions with relative ease.  They are built on a simple, elegant formalism called \emph{finite automata}.  You may encounter some ugly regular expressions in the real world, but if you keep in mind that they are simple machines, you will always be able to understand them.~\footnote{For example, here are some seriously ugly regular expressions for validating URLs: \url{https://mathiasbynens.be/demo/url-regex}.}:

\section{Regular Expression Primer}

A regular expression is a sequence of text characters.  For example, the regular expression \texttt{aa} \emph{accepts} the string \scalainline{"aa"} and \emph{rejects} all other strings.  One way to think of \texttt{aa} is as a function that takes a \scalainline{String} as input and that returns a \texttt{Boolean} as output: \scalainline{true} if the string is \scalainline{"aa"} and \scalainline{false} otherwise.

A regular expression is equivalent to a class of \emph{state machines} called a \emph{nondeterministic finite automaton}, or NFA.  NFAs can be drawn as a directed graph, and having this graph in your head helps understand what the regular expression algorithm does.  The rules are simple.  (1) Every possible change in the state of the machine (a ``transition'') is uniquely determined by the source state and input symbol.  (2) The machine ``accepts'' if and only if a sequence of input symbols results in the NFA ending in an ``accepting'' state (a circle with double lines).

Here's the NFA for the regular expression \texttt{aa}:

\begin{center}
  \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm,
                      semithick]
    \tikzstyle{every state}=[fill=none,draw=black,text=black]

    \node[initial,state] (1)              {$q_0$};
    \node[state]         (2) [right of=1] {$q_1$};
    \node[state,accepting]         (3) [right of=2] {$q_2$};
    \path (1) edge              node {a} (2)
          (2) edge              node {a} (3);
  \end{tikzpicture}
\end{center}

\subsection{Analogy: Hunt the Wumpus}

Think of this graph as a maze\footnote{See \url{https://en.wikipedia.org/wiki/Hunt_the_Wumpus}}.  You start at $q_0$, the circle at the beginning of the maze.  Your goal is to get to $q_2$, the circle at the end of the maze (the one with double lines).  You can follow paths (arrows) in the direction that they point, but not the other way.  And unfortunately, this maze is filled with evil, dangerous creatures!  Now, you're no fool.  You brought a map!  If your map is right, you make it out alive.  If not, you meet your doom in the maze.  Is your map any good?

Your map is the input string \scalainline{"aa"}.  Start at $q_0$.  The map says to go down path \scalainline{"a"}.  OK, that takes us to $q_1$.  After that, the map says to go down path \scalainline{"a"}.  Great!  This brings us to $q_2$.  We made it out!  The maze ``accepts'' the map.

What if we had the map \scalainline{"bb"}?  We'd start at $q_0$ and go to $q_1$.  But then the map says to take the path \scalainline{"b"}.  There is no \scalainline{"b"} path.  We're doomed! The maze ``rejects'' the map and the wumpus (\includegraphics[width=0.5cm]{wumpus.jpg}) eats you.

\subsection{One Caveat (Among Many) to My Beautiful Analogy}

Note that my analogy assumes that our input string and our regular expression both start and end in the same place.  This fact would imply that a regular expression matches an \emph{entire input string}.  In practice, it is often useful to write regular expressions that match a \emph{substring}.  In many regular expression implementations, one denotes whole-string matches by prepending the regex with the \texttt{\^{}} character and appending it with the \texttt{\$} character.  For example, \texttt{aa} becomes \texttt{\^{}aa\$}.

Scala's \scalainline{regex.pattern.matcher(str).matches()} (where \scalainline{regex} is a regex and \scalainline{str} is an input string) always matches the entire string, so \texttt{\^{}} and \texttt{\$} are unnecessary.  Other Scala regex methods do not work this way.  You should be careful that the function you use has the semantics that you want, so please check the Scala docs if you are unsure.

\section{Discussion Programming Tasks}

We are going to do programming tasks 2 and 5 in class.  They are:

\begin{itemize}

  \item Define the regular expression \scalainline{time}, which only matches times written as five-character strings \texttt{HH:MM}, where the hours range from 00--23 and the minutes from 00--59.
 
  \item Define the regular expression \scalainline{comment}, which only matches strings that start with \texttt{/*} and end with \texttt{*/}.

\end{itemize}

\section{Homework Hint for the Parity-Checking Regular Expression}

The last regex is a tricky one.  It helps if you know a certain arithmetical law~\footnote{Which is somewhere on this page: \url{https://en.wikipedia.org/wiki/Parity_(mathematics)}}.

\end{document}
