\documentclass[9pt]{extbook}
\usepackage{pervasives}

\title{COMPSCI220 Course Book}

\begin{document}

\maketitle
\tableofcontents

\include{introduction}
\include{lists_hw}
\include{patterns}

\newdiscussion{Scala Technical Support}


\include{hof}
\include{hof_hw}

\include{hof2}

\include{discussion_hof}
\input{errors}


\newhw{Data Wrangling}

The United States Social Security Administration releases data dating back to
1880 on babies' first names, genders, and their
popularity.\footnote{\url{https://www.ssa.gov/oact/babynames/limits.html}}
Similarly, the Centers for Disease Control releases data on life expectancy
in the United States.\footnote{\url{http://www.cdc.gov/nchs/products/life_tables.htm}}.
In this assignment, you'll be putting these two data sources together
to answer vital questions such as ``What is the most popular baby name in 2007?'',
``Approximately how many Emmas are alive today?'', and so on.

To do so, you'll use Scala's built-in data
structures (lists, sets, and maps) to write several data-processing functions
that can be composed together to answer complicated queries.
Although you can write all these functions directly using recursion,
the point of the assignment is to sequence Scala's built-in methods together
to write them quickly and compactly. Most of the functions only need
1 line of code, if you exploit the right library features.

In addition, you'll be working with CSV files (\emph{comma-separated values}),
which is the format in which a lot of public data sets are released.

\section{Preliminaries}

You should create a directory-tree that looks like this:

\dirtree{%
.1 ./wrangling.
.2 build.sbt.
.2 project.
.3 plugins.sbt.
.2 src.
.3 main.
.4 scala.\DTcomment{Your solution goes here}.
.3 test.
.4 scala\DTcomment{Yours tests go here}.
}

Your \texttt{build.sbt} file must have exactly these lines:

\scalafile{../hw/wrangling/template/build.sbt}

The \texttt{project/plugins.sbt} file must have exactly this line:

\scalafile{../hw/wrangling/template/project/plugins.sbt}

You'll also need to download two datasets:
%
\begin{itemize}

  \item The CDC data on life expectancy:

  \url{https://www.cs.umass.edu/~arjun/courses/compsci220/cdc-life-expectancy.csv}

  \item The SSA data on baby names:

  \url{https://www.cs.umass.edu/~arjun/courses/compsci220/ssa-births.csv}

\end{itemize}

You should place these files in the \texttt{wrangling} directory that you created above.

\section{The Data}

In a CSV file, each line has a row of data, where each row
has a sequence of columns, separated by a commas. For example, the
first few rows of \texttt{ssa-births.csv} are:

\begin{verbatim}
1880,Mary,F,7065
1880,Anna,F,2604
1880,Emma,F,2003
1880,Elizabeth,F,1939
\end{verbatim}

We can interpret this data as ``In the year 1880, 7065 female babies were born
named Mary; in the year 1880, 2604 female babies were born named Anna'' and so on.
In fact, the file has over 1.8 million lines of entries like this, with data
as recent as 2014. \emph{If this file is too large for your computer to handle,
you should delete some entries}.

The file \texttt{cdc-life-expectancy.csv} is much shorter and has entries
that look like this:

\begin{verbatim}
2010,76,81
2009,75,80
2008,75,80
\end{verbatim}

We can interpret this data as ``The average life expectancy of U.S. babies born
in 2010 is 76 years for males and 81 years for females'', and so
on.\footnote{The CDC releases more precise statistics. The numbers have been
cleaned up to make the assignment a little easier.}

The \texttt{build.sbt} file for this assignment is
configured to load a library for reading CSV files. For example, the program:
\begin{scalacode}
import edu.umass.cs.CSV
CSV.fromFile("cdc-life-expectancy.csv")
\end{scalacode}
Produces the value:
\begin{scalacode}
List(
  List("2010", "76", "81"),
  List("2009", "75", "80"),
  List("2008", "75", "80"),
  ...)
\end{scalacode}

\section{Programming Task}

Your programming task is to implement the functions described below.
You should place all functions within an object called \texttt{Wrangling}.

\begin{enumerate}

  \item Write a function that consumes a list of SSA records and only produces
  those records from a given year:
  \begin{scalacode}
  def yearIs(data: List[List[String]], n: Int): List[List[String]]
  \end{scalacode}


  \item Write a function that consumes a list of SSA records and only produces
  those records for years greater than the given bound:
  \begin{scalacode}
  def yearGT(data: List[List[String]], bound: Int): List[List[String]]
  \end{scalacode}

  \item Write a function that consumes a list of SSA records and only produces
  those records for years lower than the given bound:
  \begin{scalacode}
  def yearLT(data: List[List[String]], bound: Int): List[List[String]]
  \end{scalacode}

  \item Write a function that consumes a list of SSA records and only produces
  records with the given name:
  \begin{scalacode}
  def onlyName(data: List[List[String]], name: String): List[List[String]]
  \end{scalacode}

  \item Write a function to calculate the most popular name in the given dataset
  and the \emph{total} number of children born with that name.

  \textbf{Hint:} It is likely that children are born with the same
      name in several years. So, you should first calculate the total
      number of childen with each name.
  
  \begin{scalacode}
  def mostPopular(data: List[List[String]]): (String, Int)
  \end{scalacode}

  \item Write a function to calculate the number of children born in the given dataset.
  \begin{scalacode}
  def count(data: List[List[String]]): Int = ???
  \end{scalacode}

  \item Write a function that produces a tuple with the number of girls and boys
   respectively.
  \begin{scalacode}
  def countGirlsAndBoys(data: List[List[String]]): (Int, Int)
  \end{scalacode}

  \item Writen a function to calculate the set of names that are given to both girls and boys.
  \begin{scalacode}
  def genderNeutralNames(data: List[List[String]]): Set[String]
  \end{scalacode}


  \item Write a function to determine if a person with the specified \texttt{gender} and born in the
  specified year (\texttt{birthYear}) is expected to be alive (in the year \texttt{currentYear}),
  according to the CDC life-expectancy data.

    If \texttt{currentYear} is the last year the person is estimated to be alive, be
      optimistic and produce \texttt{true}.

  The CDC data only ranges from 1930---2010. Therefore, assume that
      \texttt{birthYear} is in this range too.

  \begin{scalacode}
  def expectedAlive(gender: String, birthYear: Int, currentYear: Int): Boolean 
  \end{scalacode}

  \item Write a function to estimate how many people from the given dataset
  will be alive in a particular year:

  \begin{scalacode}
  def estimatePopulation(data: List[List[String]], year: Int): Int
  \end{scalacode}

\end{enumerate}



You'll notice that many functions
consume and produce a list of births. The key idea is that you can
compose these functions together to pose complex queries. For example,
suppose \scalainline{allBirths} holds the complete list of births:

\begin{scalacode}
val allBirths = CSV.fromFile("ssa-births.csv")
\end{scalacode}

\begin{itemize}

  \item The following query calculates how many girls and boys were born between 1990
  and 2000:

  \begin{scalacode}
  countGirlsAndBoys(yearGT(yearLT(allBirths, 2001), 1989))
  \end{scalacode}

  \item The following query tells is if there were more Emma's born in 2010 than
  in 2009:

  \begin{scalacode}
  count(onlyName(yearIs(2010, allBirths), "Emma")) > count(onlyName(yearIs(2010, allBirths), "Emma"))
  \end{scalacode}

  \item The following query reports the most popular name of 2013:

  \begin{scalacode}
  mostPopular(yearIs(2013, allBirths))
  \end{scalacode}

  \item The following query estimates the number of John's alive today who
  were born after 1980:

  \begin{scalacode}
  estimatePopulation(yearGT(allBirths, 1980), 2015)
  \end{scalacode}

\end{itemize}

\input{handin}

\newdiscussion{Continuation of Previous Discussion (Feb 10)}

The previous discussion is far too long! It spilled into this one.


\include{stack_machines}

\newlecture

This lecture actually uses a slide deck! These are not the lecture notes.
see the file \texttt{/website/lectures/gc.pdf} for a copy of the slides.
The original slides are on Notability on Arjun's iPad.


\include{fundata_hw}
\newlecture

\section{Reading}

Programming in Scala, Chapter 6.1---6.11.\footnote{\url{http://www.artima.com/pins1ed/}}

\section{Object Oriented Scala}

\begin{figure}
\begin{minipage}{0.45\textwidth}
\begin{scalacode}
class Point(x: Double, y: Double) {

  def getX() = this.x

  def getY() = this.y

  def add(other: Point) = {
    new Point(this.x + other.getX(),
              this.y + other.getY())
  }

  def magnitude() = math.sqrt(x * x + y + y)
}
\end{scalacode}
\caption{A class for points.}\label{pointclass}
\end{minipage}
\quad\vrule\quad
\begin{minipage}{0.45\textwidth}
\begin{javacode}
class Point {
  private Double x;
  private Double y;

  public Point(Double x, Double y) {
    this.x = x;
    this.y = y;
  }

  public Double getX() {
    return this.x;
  }

  public Double getY() {
    return this.y;
  }

  public Point add(Point other) {
    return new Point(this.x + other.getX(),
                     this.y + other.getY());
  }

  public Double magnitude() = {
    return math.sqrt(x * x + y + y);
  }
}
\end{javacode}
\caption{A similar class in Java.}
\end{minipage}
\end{figure}

Although we've focused on functional programming so far, Scala supports
Java-style object-oriented programming too. For example, \cref{pointclass}
defines a \scalainline{Point} class (not a case class) with two private
fields\footnote{Recall that case class fields are public, which
is what allows us to use pattern matching. We cannot pattern match on ordinary classes,
even if their fields are public.} and four methods.

Notice that we didn't have to declare a constructor for \scalainline{Point}.
Scala creates a constructor automatically that initializes the values of
\scalainline{x} and \scalainline{y}.

We could make the fields public by writing:
\begin{scalacode}
class Point(val x: Double, val y: Double) { ... }
\end{scalacode}

We can make methods private by writing:
\begin{scalacode}
private def add(other: Point) = { ... }
\end{scalacode}

If we wanted to compute the value of a field, e.g., if we wanted the magnitude
to be a field whose value is calculated at construction, we could write:
%
\begin{scalacode}
class Point(x: Double, y: Double) {

  val magnitute = math.sqrt(x * x + y + y)

  ...
}
\end{scalacode}

In fact, you can think of the entire body of the class as the constructor.
For example, the following code prints each time a new point is constructed:

%
\begin{scalacode}
class Point(x: Double, y: Double) {

  println(s"Created a new Point with x = $x and y = $y.")

  ...
}
\end{scalacode}

These and other features of Scala's classes are described in depth in the
assigned reading. However, note that they are mostly syntactic differences.
The semantics of classes in Scala and Java are exactly the same (for now).

\section{Converting Functional Code to Object-Oriented Code}

\begin{figure}
\begin{scalacode}
sealed trait Shape
case class Circle(radius: Double) extends Shape // Center of the circle is (0, 0)
case class Square(side: Double) extends Shape // Bottom-left corner of the square is (0, 0)

object Shape {
  def inShape(s: Shape, x: Double, y: Double) = s match {
    case Circle(radius) => math.sqrt(x * x + y * y) <= radius
    case Square(side) => x >= 0 && x <= side && y >= 0 && y <= side
  }
}
\end{scalacode}
\caption{A Functional Shape Library}
\label{fshapes1}
\end{figure}

\Cref{fshapes1} shows a library for shapes, written in a functional style.
The library defines a sealed trait called \scalainline{Shape} and two
constructors for \scalainline{Circle} and \scalainline{Square} using
case classes. The library defines a function called \scalainline{inShape}
to test whether an $(x,y)$ coordinate is within the given shape. The function
uses pattern-matching to handle the two cases for circles and squares.

\begin{figure}
\begin{scalacode}
trait Shape {
  def inShape(x: Double, y: Double) = {
    if (this.isInstanceOf[Circle]) {
      math.sqrt(x * x + y * y) <= this.asInstanceOf[Circle].radius
    }
    else if (this.isInstanceOf[Square]) {
      val side = this.asInstanceOf[Square].side
      x >= 0 && x <= side && y >= 0 && y <= side
    }
    else {
      sys.error("unknown shape!")
    }
  }
}
class Circle(val radius: Double) extends Shape
class Square(val side: Double) extends Shape
\end{scalacode}
\caption{An object-oriented shape library: do not write code like this.}
\label{jshapesbad}
\end{figure}

\paragraph{Object-Oriented Refactoring Done Badly} To refactor this code into an
object-oriented style, we need to stop using case classes and pattern matching
and turn \scalainline{inShape} into a method instead of a function.
A literal translation of the code would be to turn the case classes
into classes with public fields, move the method into the \scalainline{Shape}
trait,\footnote{Think of this trait as an abstract class in Java. Traits are actually more powerful, but we'll get to that later.}, and rewrite the body to
use type-tests and casts.
 \Cref{jshapesbad} shows this refactoring of the
code.

\begin{notation}
In Scala:
\begin{scalacode}
this.instanceOf[Circle]
\end{scalacode}
is the same as
\javainline{this instanceof Circle} in Java.

In Scala:
\begin{scalacode}
this.asInstanceOf[Square]
\end{scalacode}
is the same as \javainline{(Square)this} in Java.
\end{notation}

You should already know that this is terrible code! It is an extremely bad idea
to use \javainline{instanceof} and type-casts in Java (and in Scala) because it
\emph{defeats the type system}. The point of the type system in Java (and Scala)
is to help you catch errors. When you write code like this, the type system
can't help you.
\textbf{You are not permitted to use \scalainline{isInstanceOf} and \scalainline{asInstanceOf},
since writing high-quality code is a major goal of this class.}

\paragraph{Object Oriented Refactoring Done Right}

\begin{figure}
\begin{scalacode}
trait Shape {
  def inShape(x: Double, y: Double): Boolean
}

class Circle(radius: Double) extends Shape {
   def inShape(x: Double, y: Double) = math.sqrt(x * x + y * y) <= radius
}

class Square(side: Double) extends Shape {
  def inShape(x: Double, y: Double) = x >= 0 && x <= side && y >= 0 && y <= side
}
\end{scalacode}
\caption{An object-oriented shape library done well.}
\label{jshapes1}
\end{figure}

The right way to build an object-oriented shape library is shown in \Cref{jshapes1}.
We've made
\scalainline{inShape} an abstract method in the trait
\scalainline{Shape}\footnote{Now, we're using the trait like an interface
in Java.} and each shape provides
an implementation. Note that we are not using any type-casts or type-tests and
that the shapes' fields are private, which is typically good practice in
object-oriented code. \textbf{Most significantly,} notice that the method
bodies are exactly the same as the cases in the function from \cref{fshapes1}.

Functional code that uses pattern matching can be converted to equivalent
object-oriented code by following this recipe:

\begin{enumerate}

  \item Functions that use pattern-matching become abstract methods on the type
  on which they pattern match.

  i.e., a function that looks like this:

  \begin{scalacode}
  def f(x: T, args ...): R = x match { ... }
  \end{scalacode}

  Becomes an abstract method:

  \begin{scalacode}
  trait T {
    def f(args ...): R
  }
  \end{scalacode}

  \begin{think}
  Notice that the \emph{function} $f$ takes an argument caled $x$, but
  the \emph{method} $f$ does not. Why not?
  \end{think}

  \item Each case in a function turns into an implementation of the abstract
  method in the corresponding class.

  i.e., a function that has a case like this:

  \begin{scalacode}
  def f(x: T, args ...): R = x match {
    case C(fields ...) => body
  }
  \end{scalacode}

  Becomes an implementation of the method $f$:

  \begin{scalacode}
  class C(fields ...) extends T {

    def f(args ...): R = body
  }
  \end{scalacode}

\end{enumerate}

\begin{think}
A key feature of pattern-matching is the \emph{exhuastivity check}. If
we forget to write a case in a function, Scala complains that pattern-matching
may not be exhaustive and actually lists all the cases that we have not
handled. Since we are no longer using pattern-matching, we no longer rely
on exhuastivity-checking. Is this okay? How do similar bugs manifest in
object-oriented code and can the Scala compiler catch them?
\end{think}

\section{Using Libraries}

Libraries and APIs are an important part of programming. Without libraries,
we'd be writing a lot of basic functionality from scratch. The Scala
and Java \emph{standard libraries} define a variety of useful data structures
and programming patterns and are available to all code that you write.
SBT makes it easy to use libraries from the Web.

For example,
\href{https://lihaoyi.github.io/upickle-pprint/upickle/}{uPickle} is a
handy library for converting Scala data structures to JSON, which is
often used in systems where programs in several languages need to communicate.
To use uPickle in a project, create a file called \texttt{build.sbt} in the
root directory of the project and add the line:
%
\begin{scalacode}
libraryDependencies += "com.lihaoyi" %% "upickle" % "0.3.8"
\end{scalacode}
%
After restarting SBT, you can use uPickle as documented on its website.
\href{http://mvnrepository.com}{Maven Central} has thousands of libraries
that you can use in a similar way.

\section{Writing Libraries}

Any SBT project can be packaged into a library by simply giving it
a name, organization, and version number in the \texttt{build.sbt} file.
For example, we could use the following \texttt{build.sbt} for our
functional shape library:

\begin{scalacode}
name := "fshapes"
organization := "compsci220"
version := "1.0"
\end{scalacode}

Before publishing a library on the Web, it is a good idea to test it by
publishing it locally. We can run \texttt{sbt publish-local} to do so.

When it completes, we can test the library by using it from another
project. To do so, we'd have to add this line to its \texttt{build.sbt}
file:
\begin{scalacode}
libraryDependencies += "compsci220" %% "fshapes" % "1.0"
\end{scalacode}

It takes a little more work to publish libararies online.
If you want to learn how to do so, we recommend using
\href{https://github.com/softprops/bintray-sbt}{Bintray SBT}. (It is a lot
simpler than using Maven Central directly.)

\section{Reusing and Extending Libraries}

Imagine that we wanted to use a library of shapes and we'd found both the functional
and object-oriented shape library we wrote earlier on the Web. We can use
either one by editing the \texttt{build.sbt} file:

\begin{scalacode}
libraryDependencies += "compsci220" %% "fshapes" % "1.0"
\end{scalacode}
or
\begin{scalacode}
libraryDependencies += "compsci220" %% "jshapes" % "1.0"
\end{scalacode}

So, which one should we use? Recall that both libraries implement the same
features: only two shapes and just one method/function to calculate if
a point is within a shape. So, perhaps the choice is just a matter of taste:
i.e., whether we prefer to think functionally or in an object-oriented way.

But, let's consider the choices more carefully. In particular, suppose neither
library was quite right and we needed to extend them in some way. In fact,
our libraries are so small, it's easy to imagine that we'd want a larger
variety of shapes and other functions or methods. So, let's see what it
takes to extend each library.

Remember that these are meant to be libraries that someone else wrote that
we are re-using in our own project. So, we do not want to read or modify their code. (Imagine that
the library has millions of lines of code). In fact, it may be a closed-source
library, so the original code may not even be available for us to read or modify.
So, imagine that all we have to work with is the Scaladoc and some example code.

We'll consider two kinds of extensions:

\begin{itemize}

  \item \emph{Extending the data model} by adding support for rectangles.

  \item \emph{Extending the feature set} by adding a routine to
  double the size of a shape.

\end{itemize}

\subsection{Extending the Functional Shape Library}

It is easy to write a new function to double the size of a shape. In our
own project, we could simply write:

\begin{scalacode}
object FunctionalExtension {
  def growShape(s: Shape): Shape = s match {
    case Circle(radius) => Circle(radius * 2)
    case Square(side) => Square(side * 2)
  }
}
\end{scalacode}

Now, let's add support for rectangles. The obvious thing to do is write:
\begin{scalacode}
import fshapes._
case class Rectangle(width: Double, height: Double) extends Shape
\end{scalacode}
But, this code does not type-check, because \scalainline{Shape} was \emph{sealed}
earlier. This may appear annoying now, but its a good thing that it doesn't work.
Remember that the \scalainline{inShape} function in the library doesn't
have a case for \scalainline{Rectangle}. How could it? Someone else wrote it
and didn't anticipate that we wanted support for rectangles. Therefore, by
preventing us from extending \scalainline{Shape}, Scala is ensuring that
the library code doesn't fail. (i.e., Scala is ensuring that the exhuastivity
analysis it did on the library remains valid.)

\begin{figure}
\begin{scalacode}
sealed trait ShapeExt
case class Rectangle(width: Double, height: Double) extends ShapeExt
case class OtherShape(s: Shape) extends ShapeExt

object FunctionalExtension {
  def growShape(s: ShapeExt): ShapeExt = s match {
    case OtherShape(Circle(radius)) => OtherShape(Circle(radius * 2))
    case OtherShape(Square(side)) => OtherShape(Square(side * 2))
    case Rectangle(width, height) => Rectangle(width * 2, height * 2)
  }

  def inShape(s: ShapeExt, x: Double, y: Double): Boolean = s match {
    case OtherShape(shape) => Shape.inShape(shape, x, y)
    case Rectangle(width, height) => x >= 0 && y >= 0 && x <= width && y <= height
  }
}
\end{scalacode}
\caption{Extending fshapes with rectangles.}
\label{fshapesext}
\end{figure}

However, all is not lost. We can add support for rectangles by \emph{wrapping}
the previously defined \scalainline{Shape} type in a new type. \Cref{fshapesext}
shows how to do this. The idea is quite straightforward. We simply
have to define a new \scalainline{inShape} function that handles rectangles
and invokes the original \scalainline{inShape} function on other shapes.

Now, imagine doing this on a large library with hundreds of functions. It would
be extremely tiresome. But, this illustrates a \emph{fundamental limitation of
functional programming}: it is easy to extends a library by adding new
functions, but it is hard to extend a library to support new kinds of data.

\begin{think}
Imagine that the original library had a \scalainline{growShape} function
and that we were trying to write the \scalainline{inShape} function.
Would wrapping still work?

Suppose the original library had a constructor for creating composite
shapes:
\begin{scalacode}
case class Overlay(top: Shape, bottom: Shape) extends Shape
\end{scalacode}
Would wrapping still work?
\end{think}

\subsection{Extending the Object-Oriented Shape Library}

It is easy to extend the object-oriented library with rectangles. All we
have to do is create a new class that extends \scalainline{Shape}
and define its \scalainline{inShape} method:
%
\begin{scalacode}
class Rectangle(width: Double, height: Double) extends Shape {
  def inShape(x: Double, y: Double): Boolean = x >= 0 && y >= 0 && x <= width && y <= height
}
\end{scalacode}

Now, let's try to add a feature to double the size of shapes. The object-oriented
way is to have a \scalainline{growShape} method in the \scalainline{Shape}
trait. But, we can't do that because \scalainline{Shape} was defined in
a library that someone else wrote (and we don't have the source code).

\begin{figure}
\begin{scalacode}
object JShapesExtension {
  def growShape(shape: Shape) {
    if (this.isInstanceOf[Circle]) {
      new Circle(this.asInstanceOf[Circle].radius * 2)
    }
    else if (this.isInstanceOf[Square]) {
      new Square(this.asInstanceOf[Square].side * 2)
    }
    else if (this.isInstanceOf[Rectangle]) {
      new Rectangle(this.asInstanceOf[Rectangle].width * 2, this.asInstanceOf[Rectangle].height * 2)
    }
    else {
      sys.error("unknown shape!")
    }
  }
}
\end{scalacode}
\caption{Using type-tests and type-casts to grow shows. Does not compile.}
\label{jshapesext1}
\end{figure}

Instead, we could write a \scalainline{growShape} function using
type-tests and type-casts, as shown in \cref{jshapesext1}. We've already
discussed why this is terrible code. Moreover, it has a simpler problem: it
does not compile.

\begin{think}
Why doesn't the code in \cref{jshapesext1} compile?
\end{think}

\begin{figure}
\begin{scalacode}
trait Growable {
  def growShape(): Shape
}

class MyCircle(radius: Double) extends Circle(radius) with Growable {
  def growShape(): MyCircle = new MyCircle(radius * 2)
}

class MySquare(side: Double) extends Square(side) with Growable {
  def growShape(): MySquare = new MySquare(side * 2)
}

class Rectangle(width: Double, height: Double) extends Shape with Growable {
  def inShape(x: Double, y: Double: Boolean = x >= 0 && y >= 0 && x <= width && y <= height

  def growShape(): Rectangle = new Rectangle(width * 2, height * 2)
}
\end{scalacode}
\caption{Using inheritance to extend the library.}
\label{jshapesext2}
\end{figure}

An alternative approach uses inheritance, as shown
in \cref{jshapesext2}. The key idea is to create  new types for circles
and squares that inherit from the existing libraries.
Again, imagine doing this at scale: if the library had dozens of objects
and dozens of methods, this would be extremely tedious.
 This illustrates a \emph{fundamental limitation of
object-oriented programming}: it is easy to extends a library with new
kinds of data (new classes), but it is hard to extend a library to support
new methods.

\begin{think}
Suppose the original library had a class that represented composite
shapes:
\begin{scalacode}
class Overlay(top: Shape, bottom: Shape) extends Shape { ... }
\end{scalacode}
Would wrapping work?
\end{think}

\section{Perspective}

These two examples illustrate that functional
and object-oriented styles involve fundamental tradeoffs when it comes
to extending and re-using code. There are certain kinds of extensions
that can be done in object-oriented style that cannot be done in
functional style, and vice versa.  It is misguided to argue that
one style is better than the other. What matters is how you expect your code
to be used (and extended). One could argue that a language that forces you to
pick one style of programming limits the kinds of code re-use that are possible.

\newdiscussion{Maps and Error-Handling (Feb 17)}

\underline{Note}: See the end of this handout for formatting and submission instructions.

This assignment has two goals:

\begin{itemize}
  \item To understand the Map data structure.
  \item To understand how to use the Option type to signal errors.
\end{itemize}

\section{Warm-Up}

\subsection{Map}

\underline{Note}: The data structure \scalainline{Map[A,B]} is not the same thing as the \emph{function} \scalainline{map[A,B]}, although they are based on related concepts.

A \scalainline{Map[A,B]} is a data structure that associates values of type \scalainline{A} with values of type \scalainline{B}.  This is useful whenever you want an efficient way of associating two kinds of data.  For example, you might want to associate the names of your friends (of type \scalainline{String}) with their birthdays (of type \scalainline{Date}).

The \scalainline{toMap} function (which is defined in the \scalainline{TraversableOnce} trait) will build a \scalainline{Map[A,B]} given a collection of pairs of \scalainline{A} and \scalainline{B}, e.g., \scalainline{List[(A,B)]}.  For example,

\begin{scalacode}
val friendsBirthdays = List(("Anja", "1994-10-01"), ("Brent", "1995-07-23"), ("Ammar", "1994-01-12"))
val fb = friendsBirthdays.toMap
// fb: scala.collection.immutable.Map[String,String] = Map(Anja -> 1994-10-01, Brent -> 1995-07-23, Ammar -> 1994-01-12)
val anja_bday = fb("Anja")
// anja_bday: String = 1994-10-01
\end{scalacode}

Scala also allows you to specify a \scalainline{Map[A,B]} in \emph{literal form}.  For example, the following does the same thing:

\begin{scalacode}
val fb = Map("Anja" -> "1994-10-01", "Brent" -> "1995-07-23", "Ammar" -> "1994-01-12")
val anja_bday = fb("Anja")
// anja_bday: String = 1994-10-01
\end{scalacode}

In the above examples, the element on the left of the \scalainline{->} (e.g., ``Anja'') is referred to as the \emph{key} and the element on the right (e.g., ``1994-10-01'') is referred to as the \emph{value}.  Thus \scalainline{Map[A,B]} also has two very handy methods.  \scalainline{keys} returns a list of the keys and \scalainline{values} returns a list of the values.

\begin{scalacode}
val fb = Map("Anja" -> "1994-10-01", "Brent" -> "1995-07-23", "Ammar" -> "1994-01-12")
val names = fb.keys
// names: Iterable[String] = Set(Anja, Brent, Ammar)
val dates = fb.values
// dates: Iterable[String] = MapLike(1994-10-01, 1995-07-23, 1994-01-12)
\end{scalacode}

\scalainline{contains(key: A): Boolean} will tell you if a key is present in a \scalainline{Map[A,B]}.

Lastly, note that keys must always be distinct.  A \scalainline{Map[A,B]} will only ever store a single copy of a key-value pair.

\begin{scalacode}
val fb = Map("Anja" -> "1994-10-01", "Anja" -> "1995-07-23")
// fb: scala.collection.immutable.Map[String,String] = Map(Anja -> 1995-07-23)
\end{scalacode}


\subsection{Option[T]}

\scalainline{Option[T]} is very simple algebraic data type.  It has two cases: \scalainline{Some} of \scalainline{T}, and \scalainline{None} of \scalainline{T}.

\scalainline{Option[T]} is useful for lots of things, but a common use is to handle unexpected outcomes in code.  Unlike \scalainline{Exception} in Java, which is a \emph{runtime} mechanism for handling unexpected outcomes in a program, \scalainline{Option[T]} is a \emph{compile time} mechanism.  This means that programmers who rely on \scalainline{Option[T]} can be assured that their code handles all known error cases \emph{before the program runs}.  This magical ability is thanks to the fact that Scala's \emph{exhaustivity check} will ensure that all cases are handled.

Here's a simple example.  Often we want to retrieve the first element in a \scalainline{List}.  But what if the \scalainline{List} is empty?  This case is easy to forget.  \scalainline{headOption} makes handling this case foolproof.  This code does not compile:

\begin{scalacode}
val friends : List[String] = List("Anja", "Brent", "Ammar")
val firstFriend : String = friends.headOption
\end{scalacode}

Think for a minute about why this does not compile.

The right way to use \scalainline{headOption} is with your old friend, \emph{pattern matching}.  The following code \emph{does} compile:

\begin{scalacode}
val friends : List[String] = List("Anja", "Brent", "Ammar")
val firstFriend : String = friends.headOption match {
  case Some(friend) => "My first friend is " + friend + "."
  case None => "I have no friends!"
}
// firstFriend: String = My first friend is Anja.
\end{scalacode}

Since the compiler told us that we made a mistake in our first version, we were able to correct it in the second version before we ran the program.  Contrast this against the following code, which compiles without error but throws an exception when we run the program:

\begin{scalacode}
val friends : List[String] = List()
val firstFriend : String = friends.head
\end{scalacode}

We get:

\begin{scalacode}
java.util.NoSuchElementException: head of empty list
  at scala.collection.immutable.Nil$.head(List.scala:420)
  at scala.collection.immutable.Nil$.head(List.scala:417)
  ... 33 elided
\end{scalacode}

\section{Exercise}

The Willy Wonka candy company calls you one morning because they need help modernizing their operation.  They want customers at supermarkets to be able to scan their candy in the self-checkout lanes at the supermarket.  Right now, customers can't do this because there are no barcodes on Wonka products.  Customers are flocking to Slugworth's Sizzlers because buying Wonka candy is so inconvenient.  Wonka wants you to put barcodes on their candy to deal with this situation.

The Wokna company gives you a \scalainline{Map[String,BigDecimal]} of candy names and their prices:

\begin{scalacode}
val candies : Map[String,BigDecimal] = Map(
  "Snozzberries" -> BigDecimal(2.49),
  "Everlasting Gobstopper" -> BigDecimal(0.99),
  "Fizzy Lifting Drink" -> BigDecimal(1.99),
  "Edible Teacup" -> BigDecimal(4.79),
  "Wonka Bar" -> BigDecimal(1.50)
)
\end{scalacode}

Barcodes will be represented using Java's UUID type.  UUID stands for ``universally unique identifier.''  You can create new UUIDs by calling \scalainline{UUID.randomUUID()}.

The Wonka company wants you to implement two functions.  First, they want a function \scalainline{getBarcodeForCandy(c: String) : Option[UUID]} that returns \scalainline{Some} barcode given a candy name, or \scalainline{None} if the candy name is not known.  Second, they want a function \scalainline{getPriceFromBarcode(b: UUID) : Option[BigDecimal]} that returns \scalainline{Some} price given a barcode, or \scalainline{None} if the barcode is not known.

You will need to create two \scalainline{Map[A,B]} data structures for those two functions to work.

\scalainline{val barcodes : Map[String,UUID]} stores the mapping from candy names to barcodes.

\scalainline{val prices : Map[UUID,BigDecimal]} stores the mapping from barcodes to prices.

\underline{Important note:} You are \emph{not} allowed to create \scalainline{barcodes} and \scalainline{prices} by hand.  You must transform \scalainline{candies} programmatically.  Hint: use our old friend, \scalainline{map} with \scalainline{toMap}.  \scalainline{getBarcodeForCandy} and \scalainline{getPriceFromBarcode} should check whether the appropriate \scalainline{Map} contains the key.  If it does, the function should return \scalainline{Some} of the value, otherwise \scalainline{None}.

\section{Templates}

To facilitate a useful discussion, please use the following templates.  \scalainline{???} indicates where you should provide implementations.

Place the following file in \texttt{Discussion4/src/main/scala/CandyDatabase.scala}

\begin{scalacode}
import java.util.UUID

class CandyDatabase(candies: Map[String, BigDecimal]) {
  val barcodes : Map[String,UUID] = ???

  val prices : Map[UUID,BigDecimal] = ???

  def getPriceFromBarcode(b: UUID) : Option[BigDecimal] = ???

  def getBarcodeForCandy(c: String) : Option[UUID] = ???
}
\end{scalacode}

Place the following test file in \texttt{Discussion4/src/test/scala/CandyDatabaseTests.scala}

\begin{scalacode}
import org.scalatest.FunSuite

class ExerciseTests extends FunSuite {
  val candies : Map[String,BigDecimal] = Map(
    "Snozzberries" -> BigDecimal(2.49),
    "Everlasting Gobstopper" -> BigDecimal(0.99),
    "Fizzy Lifting Drink" -> BigDecimal(1.99),
    "Edible Teacup" -> BigDecimal(4.79),
    "Wonka Bar" -> BigDecimal(1.50)
  )

  def barcodeTester(database: CandyDatabase, candy_name: String) : BigDecimal = {
    database
    // query the database for the barcode
      .getBarcodeForCandy(candy_name)
    // and then query the database for the price using the barcode
      .flatMap(database.getPriceFromBarcode)
    // return $0 if any of those lookups fail
      .getOrElse(BigDecimal(0))
  }

  val db = new CandyDatabase(candies)

  test("Everlasting Gobstoppers cost $0.99.") {
    val price = barcodeTester(db, "Everlasting Gobstopper")

    assert(price == candies("Everlasting Gobstopper"))
  }

  test("There is no price on file for a River of Chocolate.") {
    val price = barcodeTester(db, "River of Chocolate")

    assert(price == BigDecimal(0))
  }
}
\end{scalacode}

\input{handin}

\include{tictactoe_hw}

\newlecture

\section{Reading}

Programming in Scala, Chapters 12 and 19.\footnote{\url{http://www.artima.com/pins1ed/}}

\section{The Singleton Pattern}

\begin{figure}
\begin{javacode}
public class Singleton {
  private static Singleton instance = null;

  private Singleton() { }

  public static Singleton getInstance() {
    if(instance == null) {
      instance = new ClassicSingleton();
    }
    return instance;
  }

  void myMethod() {
    System.out.println("It works")
  }

}
\end{javacode}
\caption{The Singleton Pattern in Java}
\label{javasingleton}
\end{figure}

At times, it is often desirable to only have a single instance of a particular
class. For example, if you have a class that lets you read input from the
user, it doesn't make sense to have two instances, since the user just has
one keyboard. You can create a singleton object in Java by following the
design pattern in \cref{javasingleton}. The only instance of \javainline{Singleton}
that can exist is the one stored in the private field. (Notice that the constructor
is private.) The only way to get
the singleton is by calling the \scalainline{Singleton.getInstance} method.

Here is the equivalent in Scala:

\begin{scalacode}
object Singleton {
  def myMethod() = println("It works")
}
\end{scalacode}

So, all the top-level functions we've created so far (in class and in
assignment) can be thought of as methods of singleton objects.

\section{Case Objects}

We've seen several examples of case classes that take no arguments. For example,
to represent binary trees with values at nodes (and not at the leaves), we could
write the following type:
%
\begin{scalacode}
sealed trait BinTree
case class BinTree(lhs: BinTree, value: Int, rhs: BinTree) extends BinTree
case class Leaf() extends BinTree
\end{scalacode}

However, we can also represent leaves using a \emph{case object}, which is essentially
a singleton that can be used in pattern-matching:
%
\begin{scalacode}
sealed trait BinTree
case class BinTree(lhs: BinTree, value: Int, rhs: BinTree) extends BinTree
case object Leaf extends BinTree
\end{scalacode}

Since \scalainline{Leaf} is an object and not a class, it \emph{cannot}
take any arguments, which why we can simply write \scalainline{Leaf} instead
of \scalainline{Leaf()}. Scala uses case objects extensively. For example,
\scalainline{Nil} and \scalainline{None} are case objects. If they
were case classes, we've have to write \scalainline{Nil()} and
\scalainline{None()} instead.

\section{Subtyping}

Subtyping in Scala is very similar to subtyping in Java.

\begin{notation}
We write $A <: B$ to mean $A$ is a subtype of $B$.
\end{notation}

The intuition behind subtyping is that a subtype always ``adds more features''
to its super-type, and doesn't ``subtract features''. Therefore, if $A <: B$,
then $A$ can be used in any context where $B$ is expected. The context simply
won't try to use the extra features of $A$. However, $B$ \emph{cannot}
be used in contexts where $A$ is expected, because the context may rely on
the ``added features'' of $A$ that $B$ does not provide.

For example, consider the following hierarchy of types, all of which
implement the \scalainline{Animal} trait\footnote{Think of a trait as an interface in Java. Traits
are actually more flexible, but we are only going to use them like interfaces for now.}
%
\begin{scalacode}
trait Animal {
  def sound(): String
}

class Dog extends Animal {
  def sound() = "woof"
  def bite() = "ouch"
}

class Poodle extends Dog {
  override def sound() = "yelp"
}

class Cat extends Animal {
  def sound() = "purr"
  def scratch() = "yow"
}
\end{scalacode}

A function that expects an \scalainline{Animal} can be applied to an object
of any class defined above. Similarly, a function that expects a \scalainline{Dog}
can be applied to a \scalainline{Dog} or a \scalainline{Poodle}, but not to a
\scalainline{Cat}. For example, the following function takes dogs and makes
them bite:
\begin{scalacode}
def dontBite(x: Dog) = {
  x.bite()
}
\end{scalacode}

The expression \scalainline{dontBite(new Cat())} will not type-check, which
is good, because cats don't have a \scalainline{bite} method.

Given the traits and types defined above, we can say that:
\begin{itemize}

  \item \scalainline{Dog <: Animal} because \scalainline{Dog extends Animal}

  \item \scalainline{Poodle <: Dog} because \scalainline{Poodle extends Dog}

  \item \scalainline{Cat <: Animal} because \scalainline{Cat extends Animal}

  \item \scalainline{Poodle <: Animal} because \scalainline{Poodle <: Dog} and
  \scalainline{Dog <: Animal} (subtyping is transitive),

  \item \scalainline{X <: X} for all $X$ (subtyping is reflexive).

\end{itemize}
%
In addition, scala has two special types:
%
\begin{itemize}

  \item \scalainline{X <: Any} for all types X.

  \item \scalainline{Nothing <: X} for all types X.

\end{itemize}

A peculiar property of \scalainline{Nothing} is that
\emph{there are no values with type} \scalainline{Nothing}!
It may seem pointless to have a type with no values. For example, the following
function cannot be applied to anything (not even to \scalainline{null}):
\begin{scalacode}
def useless(x: Nothing): Unit = {
  println("Cannot call me")
}
\end{scalacode}

But, we'll see why \scalainline{Nothing} is useful in a moment.

\section{Generics and Subtyping}

\begin{figure}
\begin{subfigure}[b]{0.26\textwidth}
\begin{scalacode}
def useDog(c: Single[Dog]) = {
  c.get().bite()
}

useDog(new Single(new Cat()))
\end{scalacode}
\caption{Cats can't bite.}
\label{catdog1}
\end{subfigure}
~\vrule~
\begin{subfigure}[b]{0.33\textwidth}
\begin{scalacode}
def useAnimal(c: Single[Animal]) = {
  c.get().sound()
}

val c = new Single[Dog](new Dog())
useAnimal(c)
\end{scalacode}
\label{catdog2}
\caption{Scala is being conservative.}
\end{subfigure}
~\vrule~
\begin{subfigure}[b]{0.31\textwidth}
\begin{scalacode}
def useAnimal2(c: Single[Animal]) = {
  c.set(new Cat())
  c.get().sound()
}

val c = new Single[Dog](new Dog())
useAnimal2(c)
c.get().bite()
\end{scalacode}
\label{catdog3}
\caption{Sneaky function confuses our code.}
\end{subfigure}
\caption{None of these programs type-check.}
\end{figure}

Subtyping becomes more complicated when we working with generics types, such
as lists, sets, or any other container type. To illustrate, we'll work
with the following generic type, which is the simplest possible container:
%
\begin{scalacode}
class Container[T](private var x: T) {
  def get(): T = x
  def set(newX: T): Unit = x = newX
}

val c1: Container[Dog] = new Container(new Dog)
c1.set(new Poodle)
\end{scalacode}

Unsurprisingly, we can't store cats in \scalainline{c1}. If we did, a function
that consumes a container with a dog, might try to \scalainline{.get} the
dog and call the \scalainline{bite} method, which cats don't have.
Therefore, the code in \cref{catdog1} does not type-check.
However, since \scalainline{Dog <: Animal}, can we send a dog-container
to a function that expects an animal container. For example, \cref{catdog2}
appears to be safe. Unfortunately, this code does not type-check either. Although this particular example
is safe, consider the variation in \cref{catdog3}.

The problem above is that \scalainline{useAnimal2} sneakily stores a cat in
the container. After the function returns, \scalainline{c.get} would produce
a cat even though the type indicates that it should produce a dog.
Therefore, the Scala type-checker does not allow this program to type-check.

Unfortunately, \cref{catdog2} (which was safe) does not type-check either, just so that
this kind of unsafe example can be ruled out. Individual methods and functions
are type-checked only once. Similarly, when a function or method call is type-checked,
the body of the function is not re-examined.

\section{Variance}

\begin{instructor}
This is \emph{declaration-site variance}, as found in C\# and Scala. Java
does \emph{use-site variance}. John Altidor's papers summarize the differences
better than most stuff on the Web.
\end{instructor}

However, lists and other immutable data structures in Scala are not constrained
this way. For example, the following code does type-check:

\begin{scalacode}
def useAnimals(alist: List[Animal]) = {
  alist.map(animal => animal.sound()).mkString(", ")
}

val alist: List[Cat] = List(new Cat(), new Cat())
useAnimals(alist)
\end{scalacode}

The reason this works is because there are no methods on lists to update
their contents. The problem with our \scalainline{Container[T]} class is
that it writes to \scalainline{T}-typed values. However, if we had a functional
container class, we can use a \emph{covariance annotation} to indicate
that \scalainline{T}-typed values are never updated.

\begin{scalacode}
class Container[+T](private val x: T) {
  def get(): T = x
}
\end{scalacode}

The \scalainline{+T} annotation indicates \scalainline{Container[A] <:
Container[B]} when \scalainline{A <: B}. For this to be safe,
Scala ensures that \scalainline{T}-typed values are never updated
by the class.\footnote{Coavariance is actually more subtle than this. The reading discusses it in more depth, but you don't have to remember all the details.} (The class may have other kind of state, but it can't
update \scalainline{T}s.)

As a rule of thumb, almost any immutable data structure can be made
covariant, which makes it more flexible. E.g., we can a \scalainline{Set[Cat]}
where a \scalainline{Set[Animal]} is expected or a \scalainline{List[Dog]}
where a \scalainline{List[Animal]} is expected.

In fact, the list type in Scala is covariant:
%
\begin{scalacode}
sealed trait List[+A]
\end{scalacode}
Cons is easy to define as follows:
\begin{scalacode}
case class ::[A](head: A, tail: List[A]) extends List[A]
\end{scalacode}
However, the definition of \scalainline{Nil} is trickier. If it were a case-class,
we could write:
\begin{scalacode}
case class Nil[A]() extends List[A]
\end{scalacode}
However, recall that \scalainline{Nil} is a case-object. So, we may try to
write this:
\begin{scalacode}
case object Nil[A] extends List[A]
\end{scalacode}
However, objects can't have type parameters (or any parameters for that matter).

As discussed earlier, Scala has a special type \scalainline{Nothing} that has no values
and is the subtype of all other types: i.e.,
\scalainline{Nothing <: A}. Therefore, by covariance of lists, \scalainline{List[Nil] <: List[A]}, so
we can write:
\begin{scalacode}
case object Nil extends List[Nothing]
\end{scalacode}
Although there a no values of type \scalainline{Nothing}, an empty list of
of type \scalainline{List[A]} doesn't contain any values of type \scalainline{A}.
Therefore, the \scalainline{Nil} object can be given the type \scalainline{List[Nothing]}.

\newdiscussion{Generalized Tic Tac Toe (Feb 24)}

Discussion notes for instructors.

\section{Overview}

This discussion will cover tasks 1 and 2 in homework 5.  Students are expected to have read the assignment beforehand, so you do not need to introduce the assignment at the beginning of class.  Furthermore, no new Scala concepts have been introduced, so you should not need to introduce language features.

Discussion works like this: have students pair up and then ask them to start working on a task.  If a student reports that they have already completed the task, then ask them to pair up anyway to assist another student.  After 15 minutes, break, and then guide them briefly through the solution on the chalkboard.

Note that the complete Tic Tac Toe template is appended to the end of these lecture notes.

\section{Homework \#5 Programming Task \#1}

This task is to implement the \scalainline{createGame} method.

After 15 minutes, stop the class.

There are a couple ways that this could be implemented.  A few things to note:

\begin{enumerate}
  \item Students themselves need to decide what fields to put in the \scalainline{Game} class constructor.
  \item Nonetheless, \scalainline{Game} will eventually need to access a \scalainline{Matrix[A]} object, which comes with a variety of convenience methods.
  \item They can either create the \scalainline{Matrix[A]} and then pass it to the \scalainline{Game} constructor, or simply to have the \scalainline{Game} constructor build the \scalainline{Matrix[A]} itself from the \scalainline{board}, which is a \scalainline{Map[(Int, Int), Player]}.  Our homework solution does the former.
\end{enumerate}

Our \scalainline{createGame} looks like:

\begin{scalacode}
  def createGame(turn: Player, dim: Int, board: Map[(Int, Int), Player]): Board = {
      new Game(turn, Matrix.fromMap(dim, None, board.mapValues(p => Some(p))))
  }
\end{scalacode}

Note that we use the \scalainline{Map[T,U].mapValues} method to create a \scalainline{Map[T,Option[U]]}.  Why do we do this?  The \scalainline{board} that is passed to the \scalainline{createGame} method only represents the filled-in moves in the game.  But at some point we will need to know \scalainline{nextBoards()}.  If we represent available cells with \scalainline{None}, then we can easily find all available next moves by simply enumerating all of the cells containing \scalainline{None}.  I suggest drawing two Tic Tac Toe boards on the chalkboard to demonstrate this concept (one containing just \scalainline{Player}s, and the other contain \scalainline{Option[Player]}s).

The \scalainline{Game} constructor thus looks like:

\begin{scalacode}
  class Game(val turn: Player, matrix: Matrix[Option[Player]]) extends GameLike[Game] { ... }
\end{scalacode}

\section{Homework \#5 Programming Task \#2}

This task is to implement the \scalainline{Game.isFinished()} method.

After 15 minutes, stop the class.

There are four cases for the state of any \scalainline{Game}:

\begin{enumerate}
  \item Player \scalainline{X} won.
  \item Player \scalainline{O} won.
  \item The game is a draw (i.e., all the entries are filled-in but neither player won).
  \item The game is not finished.
\end{enumerate}

This translates into the very simple:

\begin{scalacode}
  def isFinished(): Boolean = {
    hasPlayerWon(X) || hasPlayerWon(O) || isDraw()
  }
\end{scalacode}

Of course, now we need to define a few more things.

A player wins if there are $n$ consecutive player marks (remember, this is $n \times n$ Tic Tac Toe).  There are three cases:

\begin{enumerate}
  \item There are $n$ player marks in a row.
  \item There are $n$ player marks in a column.
  \item There are $n$ player marks in a diagonal.
\end{enumerate}

Conveniently, \scalainline{Matrix[Option[Player]]} has a few methods that return rows, columns, and diagonals.

\begin{enumerate}
  \item \scalainline{rows()} returns a \scalainline{List[List[Option[Player]]]}, i.e., a \scalainline{List} containing each row (\scalainline{List[Option[Player]]}).
  \item \scalainline{cols()} returns a \scalainline{List[List[Option[Player]]]}, i.e., a \scalainline{List} containing each column (\scalainline{List[Option[Player]]}).
  \item \scalainline{mainDiagonal()} and \scalainline{antiDiagonal()} each return a \scalainline{List[Option[Player]]}.
\end{enumerate}

So one implementation for \scalainline{hasPlayerWon} is:

\begin{scalacode}
def hasPlayerWon(player: Player): Boolean = {
  val allPossibleWins =
    boardMatrix.mainDiagonal() ::
    boardMatrix.antiDiagonal() ::
    boardMatrix.rows() :::
    boardMatrix.cols()

  allPossibleWins.exists { row => row.forall { cell => cell == Some(player) } }
}
\end{scalacode}

This works because we make a master \scalainline{List[List[Option[Player]]]} of all possible $n$-consecutive cells, and then we ask: does any \scalainline{[List[Option[Player]]} exist whose entries are all \scalainline{player}?  If so, then \scalainline{player} won.

Finally, we need to implement \scalainline{isDraw}.  All cells must not contain \scalainline{None}:

\begin{scalacode}
  def isDraw(): Boolean = {
    matrix.rows.forall { row =>
      row.forall { cell => !cell.isEmpty }
    }
  }
\end{scalacode}

You could alternately use \scalainline{Option[T].isDefined} and flip the condition in the lambda.

\section{Templates}

In \texttt{src/main/scala/Solution.scala} you will find:

\begin{scalacode}
class Game(/* add fields here */) extends GameLike[Game] {

  def isFinished(): Boolean = ???

  /* Assume that isFinished is true */
  def getWinner(): Option[Player] = ???

  def nextBoards(): List[Game] = ???
}

object Solution extends MinimaxLike {

  type T = Game // T is an "abstract type member" of MinimaxLike

  def createGame(turn: Player, dim: Int, board: Map[(Int, Int), Player]): Game = ???

  def minimax(board: Game): Option[Player] = ???

}
\end{scalacode}

In \texttt{src/main/scala/Provided.scala} you will find:

\begin{scalacode}
// You'll need to read and understand this file, but don't change its contents.
// Do not change the contents of this file

sealed trait Player
case object X extends Player
case object O extends Player

trait GameLike[T <: GameLike[T]] {

  def isFinished(): Boolean

  /** Assume that isFinished} is true. */
  def getWinner(): Option[Player]

  def nextBoards(): List[T]
}

trait MinimaxLike {

  type T <: GameLike[T]

  def createGame(turn: Player, dim: Int, board: Map[(Int, Int), Player]): T

  def minimax(board: T): Option[Player]

}

class Matrix[A] private(val dim: Int, default: A, values: Map[(Int, Int), A]) {

  def set(x: Int, y: Int, value: A): Matrix[A] = {
    require(x >= 0 && x < dim)
    require(y >= 0 && y < dim)
    new Matrix[A](dim, default, values + ((x, y) -> value))
  }

  def rows(): List[List[A]] = {
    0.to(dim - 1).toList.map { row =>
      0.to(dim - 1).toList.map { col =>
        values.getOrElse((row, col), default)
      }
    }
  }

  def cols(): List[List[A]] = {
    0.to(dim - 1).toList.map { col =>
      0.to(dim - 1).toList.map { row =>
        values.getOrElse((row, col), default)
      }
    }
  }

  def mainDiagonal(): List[A] = {
    0.to(dim - 1).toList.map { n =>
      values.getOrElse((n, n), default)
    }
  }

  def antiDiagonal(): List[A] = {
    0.to(dim - 1).toList.map { n =>
      values.getOrElse((dim - n - 1, n), default)
    }
  }

  def toList[B](f: (Int, Int, A) => B): List[B] = {
    0.to(dim - 1).map { row =>
      0.to(dim - 1).map { col =>
        f(row, col, values.getOrElse((row, col), default))
      }
    }.flatten.toList
  }

  def toMap(): Map[(Int, Int), A] = values

  def get(x: Int, y: Int): A = {
    require(x >= 0 && x < dim)
    require(y >= 0 && y < dim)
    values.getOrElse((x, y), default)
  }

  override def toString(): String = {
    val builder = new StringBuilder((dim + 1) * dim)
    for (y <- 0.to(dim - 1)) {
      for (x <- 0.to(dim - 1)) {
        builder ++= values.getOrElse((x, y), default).toString
      }
      builder ++= "\n"
    }
    builder.toString
  }

  override def hashCode(): Int = {
    (for (i <- 0.until(dim); j <- 0.until(dim)) yield {
       this.get(i, j).hashCode
     }).sum
  }

  override def equals(other: Any): Boolean = other match {
    case other: Matrix[_] => {
      other.isInstanceOf[Matrix[_]] &&
      this.dim == other.dim &&
      (for (i <- 0.until(dim); j <- 0.until(dim)) yield {
        this.get(i, j) == other.get(i, j)
       }).forall(identity)
    }
    case _ => false
  }

}

object Matrix {

  def apply[A](dim: Int, init: A): Matrix[A] = {
    new Matrix(dim, init, Map.empty)
  }

  def fromMap[A](dim: Int, default: A, values: Map[(Int, Int), A]) = {
    for (((x, y), _) <- values) {
      require(x >= 0 && x < dim)
      require(y >= 0 && y < dim)
    }
    new Matrix(dim, default, values)
  }

}

\end{scalacode}

\newlecture


\section{Bounded Quantification}

\begin{figure}
\begin{scalacode}
def insert[A](toInt: A => Int, x: A, alist: List[A]): List[A] = alist match {
  case hd :: tl => if (toInt(x) <= toInt(hd)) { x :: hd :: tl } else { hd :: insert(toInt, x tl) }
  case Nil => List(x)
}

def sort[A](toInt: A => Int, alist: List[A]): List[A] = alist match {
  case Nil => Nil
  case hd :: tl => insert(toInt, hd, sort(toInt, tl))
}
\end{scalacode}
\caption{Sorting by mapping values to integers.}
\label{sortToIntHOF}
\end{figure}

We've used higher-order functions to write generic sorting functions.
\Cref{sortToIntHOF} is small variation of the kind of function we've
seen before: instead of taking a comparator function as an argument, it takes a
\scalainline{toInt} function that maps
\scalainline{A}-values to integers, then sorts by the natural ordering
on integers.

For example, given this type:
\begin{scalacode}
case class Person(name: String, age: Int)
\end{scalacode}
We can sort people in ascending order by age:
\begin{scalacode}
val personList: List[Person] = ...
sort((p: Person) => p.age, personList)
\end{scalacode}

However, it can be annoying to pass the \scalainline{toInt} function around,
especially since there is a natural ordering for \scalainline{Person}s.
We can address this issue by adding a \scalainline{toInt} method
to \scalainline{Person} and modifying \scalainline{insert} to invoke this
method instead:
\begin{scalacode}
def insert[A](x: A, alist: List[A]): List[A] = alist match {
  case hd :: tl => if (x.toInt <= hd.toInt) ...
  case Nil => ...
}
\end{scalacode}
Unfortunately, this code does not type-check: \scalainline{x} and \scalainline{hd} both have type \scalainline{A},
would could be \emph{any} type. There is no guarantee that \scalainline{A}-values have a \scalainline{toInt}
method.

\begin{figure}
\begin{scalacode}
trait IntLike {
  def toInt(): Int
}

case class Person(name: String, age: Int) extends IntLike {
  def toInt(): Int = age
}

def insert(x: IntLike, alist: List[IntLike]): List[IntLike] = alist match {
  case Nil => List(x)
  case hd :: tl => if (x.toInt <= hd.toInt) { x :: hd :: tl } else { hd :: insert(x, tl) }
}

def sort(alist: List[IntLike]): List[IntLike] = alist match {
  case Nil => Nil
  case hd :: tl => insert(hd, sort(tl))
}
\end{scalacode}
\caption{This code type-checks, but the types lose too much information.}
\label{sorting_fail}
\end{figure}

We can address this problem by introducing a trait for objects that have a
\scalainline{ToInt} method and modify \scalainline{Person} to extend this trait.
We could then rewrite the sorting function, as shown in \cref{sorting_fail}.
Unfortunately, the type of \scalainline{sort} is not helpful. When we apply
it to a \scalainline{List[Person]}, we get back a list \scalainline{List[IntLike]},
and loose track of the fact that we were working with \scalainline{Person}s:
\begin{scalacode}
val alist = List(Person("Alice", 12), Person("Bob", 7), Person("Carol", 3))
val sortedList = sort(alist)
sortedList.head.age // type error, since head has type IntLike
\end{scalacode}

We need to know that the type of the argument and the type of the result
of \scalainline{sort} are the same, which is what generics did for us:
%
\begin{scalacode}
def sort[A](alist: List[A]): List[A]
\end{scalacode}
However, the problem with this generic type was that \scalainline{A} could
be any type, and not necessary a type with a \scalainline{toInt} method,
which is what this type ensured:
\begin{scalacode}
def sort(alist: List[IntLike]): List[IntLike]
\end{scalacode}
We need to
ensure that \scalainline{alist} and the result have the same type \emph{and}
that they implement \scalainline{IntLike}. We can do this by using
\emph{bounded quantification}:
\begin{scalacode}
def sort[A <: IntLike](alist: List[A]): List[A]
\end{scalacode}
You should read this as ``sort consumes and produces lists of $A$, where $A$
is a subtype of IntLike''. \Cref{sort_bq} shows a complete version of this code.
Note that none of this is Scala-specific. \Cref{sorting_java_omg} converts
this code into Java.

Finally, note that when we write:
\begin{scalacode}
def sort[A](alist: List[A]): List[A]
\end{scalacode}
What we're really saying is that \scalainline{A} can be any type, or:
%
\begin{scalacode}
def sort[A <: Any](alist: List[A]): List[A]
\end{scalacode}
%
The bound \scalainline{Any} is implicit. Using bounded quantification, we're restricting \scalainline{A} to be any
type that implements \scalainline{IntLike}.

\begin{figure}
\begin{scalacode}
def insert[A <: IntLike](x: A, alist: List[A]): List[A] = alist match {
  case Nil => List(x)
  case hd :: tl => if (x.toInt <= hd.toInt) { x :: hd :: tl } else { hd :: insert(x, tl) }
}

def sort[A <: IntLike](alist: List[A]): List[A] = alist match {
  case Nil => Nil
  case hd :: tl => insert(hd, sort(tl))
}
\end{scalacode}
\caption{A well-typed sort using bounded quantification.}
\label{sort_bq}
\end{figure}

\begin{figure}
\begin{javacode}
interface IntLike {
  int toInt();
}

class Person implements IntLike {
  String name;
  int age;
  Person(String name, int age) { this.name = name; this.age = age; }
  public int toInt() { return age; }
}

interface List<T>  { }
class Empty<T> implements List<T> { }
class Cons<T> implements List<T> {
  public final T head;
  public final List<T> tail;
  public Cons(T head, List<T> tail) {
    this.head = head;
    this.tail = tail;
  }
}

class Sorting {

  static <T extends IntLike> List<T> insert(T x, List<T> alist) {
    if (alist instanceof Empty) {
      return new Cons<T>(x, new Empty<T>());
    }
    else {
      T hd = ((Cons<T>)alist).head;
      List<T> tl = ((Cons<T>)alist).tail;
      if (x.toInt() < hd.toInt()) {
        return new Cons<T>(x, new Cons<T>(hd, tl));
      }
      else {
        return new Cons<T>(hd, insert(x, tl));
      }
    }
  }

  static <T extends IntLike> List<T> sort(List<T> alist) {
    if (alist instanceof Empty) {
      return alist;
    }
    else {
      T hd = ((Cons<T>)alist).head;
      List<T> tl = ((Cons<T>)alist).tail;
      return insert(hd, sort(tl));
    }
  }

}
\end{javacode}
\caption{\Cref{sort_bq} converted into Java (with lists and person too).}
\label{sorting_java_omg}
\end{figure}

\section{Type Parameters to Traits}

Traits in Scala (and interfaces in Java) can take type arguments.
For example, the following trait T takes three type arguments:
\begin{scalacode}
trait T[X,Y,Z] {
  def f(x: X): Y
  def g(z: Z): Z
}
\end{scalacode}
Therefore, when a class extends the trait, it needs to supply type-arguments:
\begin{scalacode}
class C1 extends T[???, ???, ???] {
  def f(x: Int): String = x.toString
  def g(z: Boolean): Boolean = !z
}
\end{scalacode}
We can infer the arguments by examining the body of the
class.\footnote{Surprisingly, Scala's type-inference cannot infer these arguments for us.}
\begin{itemize}
  \item The class states that the argument of \scalainline{f} is an \scalainline{Int}
  and the trait states that the argument of \scalainline{f} is an \scalainline{X}.
  Therefore, \scalainline{X = Int}.

  \item The class states that the result of \scalainline{f} is a \scalainline{String}
  and the trait states that the result of \scalainline{f} is a \scalainline{Y}.
  Therefore, \scalainline{Y = String}.

  \item The class states that the argument and result of \scalainline{g} are both \scalainline{Boolean}
  and the trait states that the argument and result of \scalainline{g} are both \scalainline{Z}.
  Therefore, \scalainline{Z = Int}.
\end{itemize}
Therefore, the class can extend the trait as follows:
\begin{scalacode}
class C1 extends T[Int, String, Boolean] {
  def f(x: Int): String = x.toString
  def g(z: Boolean): Boolean = !z
}
\end{scalacode}

Consider the following class that is trying to extend the same trait:
\begin{scalacode}
class C2 extends T[Int, String, ???] {
  def f(x: Int): String = x.toString
  def g(z: Boolean): Int = 42
}
\end{scalacode}
This extension is impossible, since it would imply that \scalainline{Boolean = Int}, which
is a contradiction.

Consider the following class:
\begin{scalacode}
class C3(head: Int, tail: C3) extends T[???, ???, ???] {
  def f(x: Int): C3 = new C3(x, this)
  def g(z: C3): C3 = z
}
\end{scalacode}
We can reason through the type parameters in exactly the same way as before:
\begin{itemize}
  \item The class states that the argument of \scalainline{f} is an \scalainline{Int}
  and the trait states that the argument of \scalainline{f} is an \scalainline{X}.
  Therefore, \scalainline{X = Int}.

  \item The class states that the result of \scalainline{f} is a \scalainline{C3}
  and the trait states that the result of \scalainline{f} is a \scalainline{Y}.
  Therefore, \scalainline{Y = C3}.

  \item The class states that the argument and result of \scalainline{g} are both \scalainline{C3}
  and the trait states that the argument and result of \scalainline{g} are both \scalainline{Z}.
  Therefore, \scalainline{Z = C3}.
\end{itemize}
Here is the complete definition:
\begin{scalacode}
class C3(head: Int, tail: C3) extends T[Int, C3, C3] {
  def f(x: Int): C3 = new C3(x, this)
  def g(z: C3): C3 = z
}
\end{scalacode}

Consider the following generalization:
\begin{scalacode}
class C4[A](head: A, tail: C4[A]) extends T[???, ???, ???] {
  def f(x: A): C4[A] = new C4[A](x, this)
  def g(z: C4[A]): C4[A] = z
}
\end{scalacode}

We can apply the same reasoning to get:
\begin{scalacode}
class C4[A](head: A, tail: C4[A]) extends T[Int, C4[A], C4[A]] { ... }
\end{scalacode}

\begin{instructor}
Note that we have not covered covariant/contravariant type-arguments to traits.
\end{instructor}

\section{Leveraging Recursive Bounded Quantification}

It is cumbersome to sort values by explicitly mapping them to integers,
which is what we did before.
E.g., if we wanted to people sort by name, it would be very annoying to convert
all names to unique integers. Alternative, if we want to sort a list of time
objects, it would be annoying (and needless) to convert them all to seconds
from some fixed date.\footnote{Most computers store the current time as the number of seconds elapsed since Jan 1, 1970.}

A better approach would be to give sortable classes a \scalainline{lessThan} method
and then have them inherit from a common trait:
\begin{scalacode}
case class Person(name: String, age: Int) extends Comparable = {
  def lessThan(other: Person): Boolean = this.name < other.name
}
case class Time(h: Int, m: Int, s: Int) extends Comparable = {
  def lessThan(o: Time): Boolean = this.h < o.h || (this.h == o.h && this.m < o.min || (this.m == o.min && this.s < o.s))
}
\end{scalacode}
But, defining \scalainline{Comparable} is tricky:
\begin{scalacode}
trait Comparable {
  def lessThan(other: ???): Boolean
}
\end{scalacode}
The problem is that \scalainline{Person} requires the type of the argument
to be \scalainline{Person}, whereas \scalainline{Time} requires it to be \scalainline{Time}.
However, \scalainline{Comparable} should be a generic trait that any type can extend.
When a type in a trait must vary, we can simply turn it into a type variable,
\begin{scalacode}
trait Comparable[T] {
  def lessThan(other: T): Boolean
}
\end{scalacode}
However, the definitions of \scalainline{Person} and \scalainline{Time}
above are now incomplete, since they extend \scalainline{Comparable}, which
takes a type argument:
\begin{scalacode}
case class Person(name: String, age: Int) extends Comparable[???] = {
  def lessThan(other: Person): Boolean = ...
}
case class Time(h: Int, m: Int, s: Int) extends Comparable[???] = {
  def lessThan(o: Time): Boolean = ...
}
\end{scalacode}
We can reason about the types in exactly the way we did before.
For example, \scalainline{Person} states that the argument of \scalainline{lessThan}
is \scalainline{Person}, whereas the trait states that it is \scalainline{T}.
Therefore, \scalainline{T = Person}:
\begin{scalacode}
case class Person(name: String, age: Int) extends Comparable[Person] = ...
\end{scalacode}
We can make a similar argument for \scalainline{Time}:
\begin{scalacode}
case class Time(h: Int, m: Int, s: Int) extends ComparableTime = ...
\end{scalacode}

Now that both classes extend the \scalainline{Comparable[T]} trait, let's
update \scalainline{insert} to use it. Here is our first attempt, which
uses generics to constrain the type of the argument and result:
%
\begin{scalacode}
def insert[A](x: A, alist: List[A]): List[A] = alist match {
  case Nil => List(x)
  case head :: tail => if (x.lessThan(head)) { x :: head :: tail } else { head :: insert(x, tail) }
}
\end{scalacode}
As before, this code will not type-check, since \scalainline{A} could be any
type, whereas the body requires \scalainline{A}-typed objects to have a \scalainline{lessThan}
method. Fortunately, we have a trait for these kinds of objects:
\begin{scalacode}
def insert[A <: Comparable](x: A, alist: List[A]): List[A] = ...
\end{scalacode}
However, this will not type-check either, because \scalainline{Comparable} needs
a type argument. So, we really need to write something like this:
\begin{scalacode}
def insert[A <: Comparable[???]](x: A, alist: List[A]): List[A] = ...
\end{scalacode}

Let's reason through this systematically again:
%
\begin{itemize}

  \item \scalainline{x} has type \scalainline{A <: Comparable[???]},

  \item \scalainline{x.lessThan} takes an argument of type \scalainline{???},

  \item \scalainline{x.lessThan} is applied to \scalainline{head}, which has
  type \scalainline{A},

  \item Therefore, \scalainline{??? = A}.

\end{itemize}

\Cref{sort_sortable_complete} shows a complete version of sorting using
the \scalainline{Comparable} trait.

\begin{figure}
\begin{scalacode}
trait Comparable[T] {
  def lessThan(other: T): Boolean
}

def insert[A <: Comparable[A]](x: A, alist: List[A]): List[A] = alist match {
  case Nil => List(x)
  case head :: tail => if (x.lessThan(head)) { x :: head :: tail } else { head :: insert(x, tail) }
}

def sort[A <: Comparable[A]](alist: List[A]): List[A] = alist match {
  case Nil => Nil
  case head :: tail => insert(x, sort(tail))
}
\end{scalacode}
\caption{Sorting with a recursive bound.}
\label{sort_sortable_complete}
\end{figure}

\section{Expression Evaluator}


\begin{figure}
\begin{minipage}{0.45\textwidth}
\begin{scalacode}
sealed trait Expr
case class Const(n: Int) extends Expr
case class Add(e1: Expr, e2: Expr) extends Expr
case class Mul(e1: Expr, e2: Expr) extends Expr
case class Sub(e1: Expr, e2: Expr) extends Expr
case class Div(e1: Expr, e2: Expr) extends Expr

def eval(expr: Expr): Int = expr match {
  case Const(n) => n
  case Add(e1, e2) => eval(e1) + eval(e2)
  case Mul(e1, e2) => eval(e1) * eval(e2)
  case Sub(e1, e2) => eval(e1) - eval(e2)
  case Div(e1, e2) => eval(e1) / eval(e2)
}
\end{scalacode}
\caption{Evaluation with \scalainline{Int}s.}
\label{intEval}
\end{minipage}
\quad\vrule\quad
\begin{minipage}{0.45\textwidth}
\begin{scalacode}
sealed trait Expr
case class Const(n: Float) extends Expr
case class Add(e1: Expr, e2: Expr) extends Expr
case class Mul(e1: Expr, e2: Expr) extends Expr
case class Sub(e1: Expr, e2: Expr) extends Expr
case class Div(e1: Expr, e2: Expr) extends Expr

def eval(expr: Expr): Float = expr match {
  case Const(n) => n
  case Add(e1, e2) => eval(e1) + eval(e2)
  case Mul(e1, e2) => eval(e1) * eval(e2)
  case Sub(e1, e2) => eval(e1) - eval(e2)
  case Div(e1, e2) => eval(e1) / eval(e2)
}
\end{scalacode}
\caption{Evaluation with \scalainline{Double}s.}
\label{doubleEval}
\end{minipage}
\caption{Two very similar evaluators.}\label{twoevals}
\end{figure}


We've seen that we can use case-classes to represent arithmetic expressions
and how to write a simple, recursive evaluator. Consider the two evaluators
in \cref{twoevals}. The only difference between them is that \cref{intEval}
evaluators integer-valued expressions whereas \cref{doubleEval} evaluates
float-valued expressions. We should be able to abstract away their commonalities
by creating a generic type:

\begin{scalacode}
sealed trait Expr[A]
case class Const[A](n: A) extends Expr[A]
case class Add[A](e1: Expr[A], e2: Expr[A]) extends Expr[A]
case class Mul[A](e1: Expr[A], e2: Expr[A]) extends Expr[A]
case class Sub[A](e1: Expr[A], e2: Expr[A]) extends Expr[A]
case class Div[A](e1: Expr[A], e2: Expr[A]) extends Expr[A]
\end{scalacode}

With this type, we can write integer-valued expressions:
\begin{scalacode}
val e1: Expr[Int] = Add(Const(12), Const(3))
\end{scalacode}
and float-valued expressions too:
\begin{scalacode}
val e1: Expr[Double] = Div(Const(12), Const(5))
\end{scalacode}

The obvious way to generalize \scalainline{eval} is as follows:

\begin{scalacode}
def eval[A](expr: Expr[A]): A = expr match {
  case Const(n) => n
  case Add(e1, e2) => eval(e1) + eval(e2)
  ...
}
\end{scalacode}

Unfortunately, this doesn't work. The problem is that \scalainline{eval(e1)}
and \scalainline{eval(e2)} produce values of type \scalainline{A}, which could
be \emph{any} type. There is no guarantee that values of this type can
be added, multiplied, and so on. For example, we could have written:

\begin{scalacode}
val e1: Expr[String] = Div(Const("Hello"), Const("Goodbye"))
\end{scalacode}

The problem is that the type of \scalainline{eval} is too generic: it should
only be applicable to a type with addition, division, etc. defined appropriately.
We can define a trait that defines these operations:

\begin{scalacode}
trait NumLike[A] {
  def add(other: A): A
  def mul(other: A): A
  def sub(other: A): A
  def div(other: A): A
}
\end{scalacode}

We can create a wrapper for \scalainline{Int} and \scalainline{Double}
that implements this trait:

\begin{scalacode}
case class N(n: Int) extends NumLike[N] {
  def add(other: N): N = N(n + other.n)
  def mul(other: N): N = N(n * other.n)
  def sub(other: N): N = N(n - other.n)
  def div(other: N): N = N(n / other.n)
}

case class F(x: Double) extends NumLike[F] {
  def add(other: F): N = F(f + other.f)
  def mul(other: F): N = F(f * other.f)
  def sub(other: F): N = F(f - other.f)
  def div(other: F): N = F(f / other.f)
}
\end{scalacode}

We can now define the evaluator as follows:

\begin{scalacode}
def eval[T <: NumLike[T]](expr: Expr[T]): T = expr match {
  case Const(n) => n
  case Add(e1, e2) => eval(e1).add(eval(e2))
  case Mul(e1, e2) => eval(e1).mul(eval(e2))
  case Sub(e1, e2) => eval(e1).sub(eval(e2))
  case Div(e1, e2) => eval(e1).div(eval(e2))
}
\end{scalacode}

Although we've managed to reuse a lot of code in our evaluator,
we had to wrap \scalainline{Int}s and \scalainline{Double}s, which was
quite annoying. We'll learn how to address this problem soon.

\section{Bounded Quantification in the Java and Scala standard libraries}

Bounded quantification is used extensively in libraries. For example,
here is the signature of the \javainline{Integer} class in Java:

\begin{scalacode}
public final class Integer extends Number implements Comparable<Integer>
\end{scalacode}

The standard \javainline{Comparable} interface is very similar to the one we
defined.

\newhw{Generics}

This assignment will exercise your knowledge of generic interfaces,covariance
and bounded quantification.

\section{Preliminaries}

You should create a directory-tree that looks like this:

\dirtree{%
.1 ./generics.
.2 build.sbt.
.2 project.
.3 plugins.sbt.
.2 src.
.3 main.
.4 scala.
.5 Solution.scala.\DTcomment{Your solution goes here}.
.3 test.
.4 scala\DTcomment{Yours tests go here}.
}

Your \texttt{build.sbt} file must have exactly these lines:

\begin{scalacode}
resolvers += "PLASMA" at "https://dl.bintray.com/plasma-umass/maven"
libraryDependencies += "edu.umass.cs" %% "compsci220" % "1.0.1"
\end{scalacode}

The \texttt{project/plugins.sbt} file must have exactly this line:

\begin{scalacode}
addSbtPlugin("edu.umass.cs" % "cmpsci220" % "3.0.1")
\end{scalacode}

The support code for this assignment is in the package \texttt{hw.generics}.

\section{Programming with Bounded Quantification}

The trait \scalainline{hw.generics.ListLike} is a trait for ``list-like''
collections. (i.e., collections that are either \emph{empty} or have
a  \emph{head} and \emph{tail}.) The class \scalainline{hw.generics.MyList}
is a typical list that implements the \scalainline{ListLike} trait.

\begin{enumerate}

  \item In \texttt{Solution.scala}, create the following type for
  binary trees:
  \begin{scalacode}
  sealed trait BinTree[A]
  case class Node[A](lhs: BinTree[A], value: A, rhs: BinTree[A]) extends BinTree[A]
  case class Leaf[A]() extends BinTree[A]
  \end{scalacode}

  Furthermore, have \scalainline{BinTree} extend \scalainline{ListLike}.
  The \emph{head} of a binary-tree is the value on the left-most node
  and the \emph{tail} of a binary-tree is the tree with the left-most
  value removed.

  \item In \texttt{Solution.scala}, create an object called \scalainline{ListFunctions} with the following functions:

    \begin{enumerate}

      \item Create a function \scalainline{filter(f, alist)}
      where \scalainline{alist} is a list-like collection and
      \scalainline{f} is a predicate that can be applied to elements in
      the list. The function should produce a new list-like collection
      with the same type as \scalainline{alist} that only contains the
      elements on which \scalainline{f} produces \scalainline{true}.

      i.e., this filtering function should behave exactly the same
      as Scala's filtering function.

      \item Create a function \scalainline{append(alist1, alist2)}, where
      \scalainline{alist1} and \scalainline{alist2} are two list-like
      collections of the same type. The result should be a new list-like
      collection (with the same type as \scalainline{alist1} and
      \scalainline{alist2}) that has the elements of \scalainline{alist1}
      followed by the elements of \scalainline{alist2} in order.

      i.e., on linked lists, \scalainline{append(alist1, alist2)} should
      behave in a manner simlar to \scalainline{alist1 ++ alist2}. 
      \item Define a function that sorts in ascending order with the
      following name and type:

      \begin{scalacode}
      def sort[A <: hw.generics.Ordered[A], C <: hw.generics.ListLike[A, C]](alist: C): C = {
        ...
      }
      \end{scalacode}

    \end{enumerate}

    You should test applying these functions to the provided
    \scalainline{MyList} type and to the \scalainline{BinTree} type that
    you defined. You should also be able to apply it any other new data
    structure that extends the \scalainline{ListLike} trait. 
\end{enumerate}

\section{Extending Traits}

The package \scalainline{hw.generics} defines three traits \scalainline{T1},
\scalainline{T2}, and \scalainline{T3}
that define exactly the same
set of methods, but have a different set of type-parameters.
In \texttt{Solution.scala}, create the following classes:

\begin{scalacode}
class C1 {
  def f(a: Int, b: Int): Int = 0
  def g(c: String): String = ""
  def h(d: String): Int = 0
}


class C2 {
  def f(a: Int, b: Int): Int = 0
  def g(c: Int):  Int = 0
  def h(d: Int): Int = 0
}

class C3[A](x: A) {
  def f(a: Int, b: A): Int = 0
  def g(c: A): String = ""
  def h(d: String): A = x
}

class C4[A](x: Int, y: C4[A]) {
  def f(a: Int, b: C4[A]): C4[A] = b
  def g(c: Int): C4[A] = y
  def h(d: C4[A]): Int = x
}
\end{scalacode}

Moreover, have these classes extend as many of the traits
traits \scalainline{T1}, \scalainline{T2}, and \scalainline{T3}
as possible. Some classes may be able to extend several
traits. \textbf{You should not modify the class bodies.}

\input{handin}

\section{Template}

You can use the following template for \texttt{Solution.scala}:
\begin{scalacode}
import hw.generics._

sealed trait BinTree[A]
case class Node[A](lhs: BinTree[A], value: A, rhs: BinTree[A]) extends BinTree[A]
case class Leaf[A]() extends BinTree[A]

object ListFunctions {
  // def filter(f, alist)
  // def append(alist1, alist2)
  def sort[A <: Ordered[A], C <: ListLike[A, C]](alist: C): C = ???
}

class C1 {
  // Do not change the class body. Simply extend T1, T2, and/or T3.
  def f(a: Int, b: Int): Int = 0
  def g(c: String): String = ""
  def h(d: String): Int = 0
}

class C2 {
  // Do not change the class body. Simply extend T1, T2, and/or T3.
  def f(a: Int, b: Int): Int = 0
  def g(c: Int):  Int = 0
  def h(d: Int): Int = 0
}


class C3[A](x: A) {
  // Do not change the class body. Simply extend T1, T2, and/or T3.
  def f(a: Int, b: A): Int = 0
  def g(c: A): String = ""
  def h(d: String): A = x
}

class C4[A](x: Int, y: C4[A]) {
  // Do not change the class body. Simply extend T1, T2, and/or T3.
  def f(a: Int, b: C4[A]): C4[A] = b
  def g(c: Int): C4[A] = y
  def h(d: C4[A]): Int = x
}
\end{scalacode}

\newlecture

\begin{instructor}

\section{Recap\classtime{15}}
\classtime{15}

\begin{itemize}
  \item The notation \scalainline{A <: B}.
  \item \emph{Invariance}: typically \scalainline{A <: B} does not imply that \scalainline{Container[A] <: Container[B]}, because the container may have a method that writes to a value of type A.
  \item \emph{Covariance}: If the class is annotated \scalainline{Container[+T]}, then the type-checker ensures we can't write to values of type \scalainline{T} within the class.
  \item Traits can take type parameters too, just like classes. When we extend a trait, we need to supply the type parameters.
  \item Bounded quantification: The type parameter\scalainline{C[A]} means that \scalainline{A} could be any type. We can write \scalainline{C[A <: B]} to restrict it to types that extend \scalainline{B}, which allows us to invoke \scalainline{B}-methods on values of type \scalainline{A}.
\end{itemize}
\end{instructor}

\section{Variance and method arguments\classtime{20}}

Earlier, we wrote the simplest container we could imagine that only stored
a single value. The following container slightly more sophisticated, because
it can store two values:
\begin{scalacode}
class Two[+T](private val x: T, private val y: T) {
  def get1(): T = x
  def get2(): T = y
}
\end{scalacode}
This container uses a covariance annotation, so when \scalainline{A <: B},
we have \scalainline{Two[A] <: Two[B]}. Recall that the
intuition for subtyping is that \scalainline{Two[A]} can be used
wherever a \scalainline{Two[B]} is expected. Now, suppose we modify the class to
add functional update methods:
\begin{scalacode}
class Two[+T](private val x: T, private val y: T) {
  ...
  def update1(newX: T): Two[T] = new Two(newX, y)
  def update2(newY: T): Two[T] = new Two(x, newY)
}
\end{scalacode}
This is a natural operation on containers and we should be able to write it.
But, let's ensure that even with this operation, \scalainline{Two[A]} can
be used whenever a \scalainline{Two[B]} is expected.

Concretely, consider the following two classes:
\begin{scalacode}
class Dog {
  def makeSound(): String = "woof"
}

class Poodle extends Dog {
  def bite(): String = "nip"
}
\end{scalacode}

We should be able to use a \scalainline{Two[Poodle]} in all contexts where
a \scalainline{Two[Dog]} is expected.


Consider the following function, which simply updates a container to
store a \scalainline{Dog}:
\begin{scalacode}
def store[A <: Two[Dog]](x: A): A = x.update1(new Dog)
\end{scalacode}
However, it uses bounded-quantification to any subtype of
\scalainline{Two[Dog]}. Therefore, we can apply it to a \scalainline{Poodle}
container and know that the result is still a \scalainline{Poodle}
container. Of course, this isn't true, since the function stores
a \scalainline{Dog}. Therefore, the following code goes wrong:
\begin{scalacode}
val twoPoodles = new Two[Poodle](new Poodle(), new Poodle())
val aPoodle = storeDog(twoPoodles).get1() // Produces a Dog, not a Poodle!
aPoodle.bite() // Crash! Dogs don't have a .bite() method.
\end{scalacode}

Naturally, Scala (and Java) won't allow this to happen. In general, when
a class has a covariant type parameter \scalainline{T}, its methods can
produce values of type \scalainline{T}, but methods' arguments cannot consume
values of type \scalainline{T} (because of the error described above). Therefore, the type-checker
will not allow us to write the update methods, because they use
a covariant type parameter as the type of a method argument.

\paragraph{A solution}
The problem with the code above is that when a \scalainline{Two[A]}
is treated as a \scalainline{Two[B]}, we can update the container to
store any \scalainline{B}-typed value, which then breaks code that expects
\scalainline{A}-typed values. Instead, we need to ensure that we can only store
subtypes of \scalainline{A} in the container. We can express this constraint
using bounded-quantification:

\begin{scalacode}
class Two[+T](private val x: T, private val y: T) {
  ...
  def update1[S >: T](newX: T): Two[S] = new Two(newX, y)
  def update2[S >: T](newY: T): Two[S] = new Two(x, newY)
}
\end{scalacode}
This version of the class does type-check.

If we have a Poodle-container:
\begin{scalacode}
val x = new Two[Poodle](new Poodle, new Poodle)
\end{scalacode}
And we update one of the poodles:
\begin{scalacode}
x.update1[Poodle](new Poodle)
\end{scalacode}
The type-parameter \scalainline{S} is bound to the type \scalainline{Poodle},
so the return type is \scalainline{Two[Poodle]}. However, we can also
update the the container with a \scalainline{Dog}:
\begin{scalacode}
x.update1[Dog](new Dog)
\end{scalacode}
However, in this case, the return type is \scalainline{Two[Dog]} (although one
of the dogs is a poodle).

\paragraph{Appending Lists}
A similar problem arises with list concatenation. Since lists are covariant,
they cannot have an append method with this type:
\begin{scalacode}
sealed trait List[A] {
  def append[A](other: List[A]): List[A] = ...
  ...
}
\end{scalacode}

However, we can use the same trick we used above to write an append
method with the following type:

\begin{scalacode}
sealed trait List[A] {
  def append[B :> A](other: List[B]): List[B] = alist match {
    case Nil => Nil
    case hd :: tl => hd :: tl.append(other)
  }
  ...
}
\end{scalacode}

\section{A Model of Type-Checking\classtime{40}}

\begin{figure}
\scalafile{includes/ScalaFragment.scala}
\caption{A subset of Scala expressions}\label{scalafragment}
\end{figure}

\begin{instructor}
This section is quite rough. I'd start by getting students to derive the expression data-structure from examples.
\end{instructor}


To understand generics, we've had to develop an intuition for how the Scala
type-checker works. A deep understanding of the Scala (or Java) type system is
beyond the scope of this class. However, it is important to have a reasonably
accurate mental model of type-checking to understand and debug type-errors.

\Cref{scalafragment} is a data structure that represents a fragment of
Scala expressions, including numbers, boolean, addition, the less-than operator,
if-expressions, and identifiers (bound with \scalainline{val}). Since
the only values in this fragment are integers and booleans, we can represent
types as follows:

\begin{scalacode}
sealed trait Type
case object TInt extends Type
case object TBool extends Type
\end{scalacode}

Ignoring identifiers, we can write a simple recursive function to type-check
programs in this fragment, as shown in \cref{simpletc}.

\begin{figure}
\begin{scalacode}
object TypeError extends RuntimeException("Type error")

object TypeChecker {

  def tc(expr: Expr): Type = expr match {
    case EInt(_) => TInt
    case EBool(_) => TBool
    case EAdd(e1, e2) => (tc(e1), tc(e2)) match {
      case (TInt, TInt) => TInt
      case _ => throw TypeError
    }
    case ELT(e1, e2) => (tc(e1), tc(e2)) match {
      case (TInt, TInt) => TBool
      case _ => throw TypeError
    }
    case EIf(e1, e2, e3) => (tc(e1), tc(e2), tc(e3)) match {
      case (TBool, t1, t2) if (t1 == t2) => t1
      case _ => throw TypeError
    }
  }
}
\end{scalacode}
\caption{Type-checking, excluding identifiers}\label{simpletc}
\end{figure}

Type-checking identifiers is a little trickier. When we see an identifier,
there is way to determine its type, unless we remember the type
of the expression it was bound to. Therefore, we need an auxiliary
parameter, known as the environment, to ``remember'' the type of identifiers
so that we can recall them later (\cref{tcid}).

\begin{figure}
\begin{scalacode}
object TypeChecker {
  def tc(env: Map[String, Type], expr: Expr): Type = expr match {
    case EInt(_) => TInt
    case EBool(_) => TBool
    case EAdd(e1, e2) => (tc(env, e1), tc(env, e2)) match {
      case (TInt, TInt) => TInt
      case _ => throw TypeError
    }
    case ELT(e1, e2) => (tc(env, e1), tc(env, e2)) match {
      case (TInt, TInt) => TBool
      case _ => throw TypeError
    }
    case EIf(e1, e2, e3) => (tc(env, e1), tc(env, e2), tc(env, e3)) match {
      case (TBool, t1, t2) if (t1 == t2) => t1
      case _ => throw TypeError
    }
    case EVal(x, e1, e2) => tc(env + (x -> tc(env, e1)), e2)
    case EId(x) => env.getOrElse(x, throw TypeError)
  }
}
\end{scalacode}
\caption{Type-checking identifiers.}\label{tcid}
\end{figure}

The actual Scala type-checker is vastly more complicated. But, it follows
this basic design.

\input{samefringe}

\newlecture

\section{The $n$-Queens Problem}

The $n$-queens problem is to place $n$ queens on an $n \times n$ chessboard
such that no queens threaten each other.
If you aren't familiar with the
rules of Chess: a queen is a chess piece that move horizontally, vertically,
or diagonally across a chessboard, which is typically an $8 \times 8$ matrix.
A queen can ``kill'' any piece that it can move to, so it is unsafe to be
on the same horziontal, vertical, or diagonal line as a queen. The $n$-queens
problem is to arrange $n$-queens on a generalized $n \times n$ chessboard,
such that no pair of queens can kill each other.

The $n$-queens problem is a canonical example of a constraint-satisfaction
problem that can be solved by backtracking search. In this lecture, we'll
begin with a naive implementation of backtracking search, and then refine
it to use constraint-propagation, which will make it a lot faster.

\section{A trait for chessboards}

\begin{figure}
\scalafile{includes/nqueens/src/main/scala/ChessBoardLike.scala}
\caption{A trait for chessboards.}
\label{ChessBoardLike}
\end{figure}

Since we are going to go through a few different representations of chessboards,
it will help to factor out generic code that prints the representation of
chessboards. The \scalainline{ChessBoardLike} trait in \cref{ChessBoardLike}
defines a \scalainline{toString} method that prints a chessboard of queens,
where each queen is printed as \texttt{Q} and each blank space appears as
\texttt{.}. This printing method requires the implementing class to have
a field that specifies that dimensions of the chessboard and set of coordinates
that describe where the queens are placed.

\section{Backtracking Search}

\begin{figure}
\scalafile{includes/nqueens/src/main/scala/NaiveQueens.scala}
\caption{A naive solution to the $n$-queens problem.}
\label{NaiveQueens}
\end{figure}

The core idea of any solution to the $n$-queens problem is to write a recursive
function (called \scalainline{solve}) that places 1 new queen on the current
board in a position where it does not threaten any existing queen and then
recursively calls \scalainline{solve} to place the remaining queens. The
function terminates sucessfully when $n$ queens have been placed on the board.
The function terminates with an error if there are no positions where the next
queen can be safely placed. In any application of \scalainline{solve}, there may
be several positions where a queen can be safely placed. The key to backtracking
is to try a new position if the recursive application produces an error.

\Cref{NaiveQueens} shows a simple implementation of this idea. The key function
is the \scalainline{canPlace} predicate which determines if a new queen
maybe placed at coordinates $(x,y)$ by checking if there are any existing
queens in the set \scalainline{solution} on the same row, column, diagonal,
or antidiagonal.

\begin{instructor}
These notes could be expanded substantially in the future.
\end{instructor}

We can run the solver as follows:

\begin{scalacode}
(new NaiveQueens(n, Set())).solve()
\end{scalacode}
With $n = 11$, the solver produces a solution in less than a second on my
laptop, with $n = 12$, it takes 55 seconds, and $n = 13$ would take much longer.

\section{Constraint Propagation}

\begin{figure}
\scalafile{includes/nqueens/src/main/scala/OptQueens.scala}
\caption{A constraint-propagating solution to the $n$-queens problem.}
\label{OptQueens}
\end{figure}

\Cref{OptQueens} shows a variant of the naive solver that is substantially
faster. The key idea to store a set of locations where a queen can be placed
without violating any constraints and then prune the set whenever a new queen
is placed.


\newlecture

\section{$n$-Queens using Propositional Logic}

\begin{instructor}
These notes are not complete.
\end{instructor}

We covered the $n$-Queens problem with Z3.
Here is the corrected code with some minor cleanup:
 
https://gist.github.com/arjunguha/7c1f9d3a9fad37f17965
 
If you want to actually solve things, you'll need the Z3 Theorem Prover:
 
https://github.com/Z3Prover/z3/releases
 
There is a fun Z3 tutorial here:
 
http://rise4fun.com/Z3/tutorial/guide

\input{implicit_classes}

\input{sudoku}

\input{sudoku_discussion}

\input{streams}

\input{regex}

\input{implicits_hw}

\input{regex_hw}

\input{parsing_hw}

\newdiscussion{Implicits (Apr 6)}

This discussion will cover the first two questions of Homework 8, which asks you to use Scala implicits to wrap ``ugly'' Java interfaces with ``pretty'' Scala interfaces.

\section{What you need to do}

We will be completing HW 8, programming tasks 1 and 2 in class.  These two assignments are reproduced below.

\begin{enumerate}

  \item We should be able to construct paths by using the slash-operator to separate strings. For example, the expression \scalainline{"usr" / "bin" / "scala"} should be equivalent to the expression \scalainline{Paths.get("usr", "bin", "scala")}. 
  \item Similarly, given two paths, we should be able to join them using the slash-operator. For example, if \scalainline{p1} is \scalainline{"usr" / "local"} and \scalainline{p2} is \scalainline{"bin" / "scala"} then \scalainline{p1 / p2} should be equivalent to \scalainline{Paths.get("usr", "local", "bin", "scala")}. 
\end{enumerate}

\section{Hints}

First hint: this assignment requires \emph{neither} Scala implicit functions to work \emph{nor} Scala implicit function parameters.  You \emph{only} need Scala implicit classes.  If you do not remember the difference between these sorts of implicits, I strongly suggest that you familiarize yourself with their definitions.

Second hint: remember that Scala implicit classes require a few ingredients in order to work.  The most important ingredients are described here, but you can find the complete list of rules at: \url{https://www.artima.com/pins1ed/implicit-conversions-and-parameters.html#21.2}

\begin{enumerate}
  \item You must create a class and mark it as \scalainline{implicit}.
  \item Implicit classes must be defined inside an \scalainline{object}, \scalainline{trait}, or \scalainline{class}.
  \item The implicit class must be visible from the scope of the expression that you want rewritten.
  \item The compiler \emph{will not} attempt to rewrite an expression to use an implicit class if it type-checks as-is.  In other words, the expression must fail to type check \emph{unless} the compiler can find an implicit class in scope that causes the type check to succeed.
\end{enumerate}

\begin{instructor}
\section{Solutions}
  
Note that I have elided parts of the solution that are not directly related to the first two programming tasks.  The reason is that I want students to have to think about the rest of the solution on their own.

\begin{scalacode}
  import java.nio.file._

  object PathImplicits {  
    implicit class RichPath(p: Path) {
      def /(p2: String) : Path = p.resolve(p2)
      def /(p2: Path) : Path = p.resolve(p2)
    }

    implicit class RichString(s: String) {
      def /(s2: String) : Path = Paths.get(s).resolve(s2)
      def /(p2: Path) : Path = Paths.get(s).resolve(p2)
    }
  }
\end{scalacode}
  
\end{instructor}


\newdiscussion{Regular Expressions (Apr 13)}

A \emph{regular expression}, also known as ``regex,'' is a powerful feature of most modern programming languages.  Regexes allow programmers to build sophisticated string-manipulating functions with relative ease.  They are built on a simple, elegant formalism called \emph{finite automata}.  You may encounter some ugly regular expressions in the real world, but if you keep in mind that they are simple machines, you will always be able to understand them.~\footnote{For example, here are some seriously ugly regular expressions for validating URLs: \url{https://mathiasbynens.be/demo/url-regex}.}:

\section{Regular Expression Primer}

A regular expression is a sequence of text characters.  For example, the regular expression \texttt{aa} \emph{accepts} the string \scalainline{"aa"} and \emph{rejects} all other strings.  One way to think of \texttt{aa} is as a function that takes a \scalainline{String} as input and that returns a \texttt{Boolean} as output: \scalainline{true} if the string is \scalainline{"aa"} and \scalainline{false} otherwise.

A regular expression is equivalent to a class of \emph{state machines} called a \emph{nondeterministic finite automaton}, or NFA.  NFAs can be drawn as a directed graph, and having this graph in your head helps understand what the regular expression algorithm does.  The rules are simple.  (1) Every possible change in the state of the machine (a ``transition'') is uniquely determined by the source state and input symbol.  (2) The machine ``accepts'' if and only if a sequence of input symbols results in the NFA ending in an ``accepting'' state (a circle with double lines).

Here's the NFA for the regular expression \texttt{aa}:

\begin{center}
  \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm,
                      semithick]
    \tikzstyle{every state}=[fill=none,draw=black,text=black]

    \node[initial,state] (1)              {$q_0$};
    \node[state]         (2) [right of=1] {$q_1$};
    \node[state,accepting]         (3) [right of=2] {$q_2$};
    \path (1) edge              node {a} (2)
          (2) edge              node {a} (3);
  \end{tikzpicture}
\end{center}

\subsection{Analogy: Hunt the Wumpus}

Think of this graph as a maze\footnote{See \url{https://en.wikipedia.org/wiki/Hunt_the_Wumpus}}.  You start at $q_0$, the circle at the beginning of the maze.  Your goal is to get to $q_2$, the circle at the end of the maze (the one with double lines).  You can follow paths (arrows) in the direction that they point, but not the other way.  And unfortunately, this maze is filled with evil, dangerous creatures!  Now, you're no fool.  You brought a map!  If your map is right, you make it out alive.  If not, you meet your doom in the maze.  Is your map any good?

Your map is the input string \scalainline{"aa"}.  Start at $q_0$.  The map says to go down path \scalainline{"a"}.  OK, that takes us to $q_1$.  After that, the map says to go down path \scalainline{"a"}.  Great!  This brings us to $q_2$.  We made it out!  The maze ``accepts'' the map.

What if we had the map \scalainline{"bb"}?  We'd start at $q_0$ and go to $q_1$.  But then the map says to take the path \scalainline{"b"}.  There is no \scalainline{"b"} path.  We're doomed! The maze ``rejects'' the map and the wumpus (\includegraphics[width=0.5cm]{wumpus.jpg}) eats you.

\subsection{One Caveat (Among Many) to My Beautiful Analogy}

Note that my analogy assumes that our input string and our regular expression both start and end in the same place.  This fact would imply that a regular expression matches an \emph{entire input string}.  In practice, it is often useful to write regular expressions that match a \emph{substring}.  In many regular expression implementations, one denotes whole-string matches by prepending the regex with the \texttt{\^{}} character and appending it with the \texttt{\$} character.  For example, \texttt{aa} becomes \texttt{\^{}aa\$}.

Scala's \scalainline{regex.pattern.matcher(str).matches()} (where \scalainline{regex} is a regex and \scalainline{str} is an input string) always matches the entire string, so \texttt{\^{}} and \texttt{\$} are unnecessary.  Other Scala regex methods do not work this way.  You should be careful that the function you use has the semantics that you want, so please check the Scala docs if you are unsure.

\section{Discussion Programming Tasks}

We are going to do programming tasks 2 and 5 in class.  They are:

\begin{itemize}

  \item Define the regular expression \scalainline{time}, which only matches times written as five-character strings \texttt{HH:MM}, where the hours range from 00--23 and the minutes from 00--59.
 
  \item Define the regular expression \scalainline{comment}, which only matches strings that start with \texttt{/*} and end with \texttt{*/}.

\end{itemize}

\section{Homework Hint for the Parity-Checking Regular Expression}

The last regex is a tricky one.  It helps if you know a certain arithmetical law~\footnote{Which is somewhere on this page: \url{https://en.wikipedia.org/wiki/Parity_(mathematics)}}.

\include{parsing}

\include{gadts}

\end{document}
