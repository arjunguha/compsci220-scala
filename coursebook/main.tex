\documentclass[9pt]{extbook}
\usepackage{pervasives}

\title{COMPSCI220 Course Book}

\begin{document}

\maketitle
\tableofcontents

\include{introduction}
\include{lists_hw}
\include{patterns}

\newdiscussion{Scala Technical Support}


\include{hof}
\include{hof_hw}

\include{hof2}

\include{discussion_hof}
\input{errors}
\input{wrangling_hw}


\newdiscussion{Continuation of Previous Discussion (Feb 10)}

The previous discussion is far too long! It spilled into this one.

\include{stack_machines}

\newlecture

This lecture actually uses a slide deck! These are not the lecture notes.
see the file \texttt{/website/lectures/gc.pdf} for a copy of the slides.
The original slides are on Notability on Arjun's iPad.


\include{fundata_hw}
\include{expression_problem}

\newdiscussion{Maps and Error-Handling (Feb 17)}

\underline{Note}: See the end of this handout for formatting and submission instructions.

This assignment has two goals:

\begin{itemize}
  \item To understand the Map data structure.
  \item To understand how to use the Option type to signal errors.
\end{itemize}

\section{Warm-Up}

\subsection{Map}

\underline{Note}: The data structure \scalainline{Map[A,B]} is not the same thing as the \emph{function} \scalainline{map[A,B]}, although they are based on related concepts.

A \scalainline{Map[A,B]} is a data structure that associates values of type \scalainline{A} with values of type \scalainline{B}.  This is useful whenever you want an efficient way of associating two kinds of data.  For example, you might want to associate the names of your friends (of type \scalainline{String}) with their birthdays (of type \scalainline{Date}).

The \scalainline{toMap} function (which is defined in the \scalainline{TraversableOnce} trait) will build a \scalainline{Map[A,B]} given a collection of pairs of \scalainline{A} and \scalainline{B}, e.g., \scalainline{List[(A,B)]}.  For example,

\begin{scalacode}
val friendsBirthdays = List(("Anja", "1994-10-01"), ("Brent", "1995-07-23"), ("Ammar", "1994-01-12"))
val fb = friendsBirthdays.toMap
// fb: scala.collection.immutable.Map[String,String] = Map(Anja -> 1994-10-01, Brent -> 1995-07-23, Ammar -> 1994-01-12)
val anja_bday = fb("Anja")
// anja_bday: String = 1994-10-01
\end{scalacode}

Scala also allows you to specify a \scalainline{Map[A,B]} in \emph{literal form}.  For example, the following does the same thing:

\begin{scalacode}
val fb = Map("Anja" -> "1994-10-01", "Brent" -> "1995-07-23", "Ammar" -> "1994-01-12")
val anja_bday = fb("Anja")
// anja_bday: String = 1994-10-01
\end{scalacode}

In the above examples, the element on the left of the \scalainline{->} (e.g., ``Anja'') is referred to as the \emph{key} and the element on the right (e.g., ``1994-10-01'') is referred to as the \emph{value}.  Thus \scalainline{Map[A,B]} also has two very handy methods.  \scalainline{keys} returns a list of the keys and \scalainline{values} returns a list of the values.

\begin{scalacode}
val fb = Map("Anja" -> "1994-10-01", "Brent" -> "1995-07-23", "Ammar" -> "1994-01-12")
val names = fb.keys
// names: Iterable[String] = Set(Anja, Brent, Ammar)
val dates = fb.values
// dates: Iterable[String] = MapLike(1994-10-01, 1995-07-23, 1994-01-12)
\end{scalacode}

\scalainline{contains(key: A): Boolean} will tell you if a key is present in a \scalainline{Map[A,B]}.

Lastly, note that keys must always be distinct.  A \scalainline{Map[A,B]} will only ever store a single copy of a key-value pair.

\begin{scalacode}
val fb = Map("Anja" -> "1994-10-01", "Anja" -> "1995-07-23")
// fb: scala.collection.immutable.Map[String,String] = Map(Anja -> 1995-07-23)
\end{scalacode}


\subsection{Option[T]}

\scalainline{Option[T]} is very simple algebraic data type.  It has two cases: \scalainline{Some} of \scalainline{T}, and \scalainline{None} of \scalainline{T}.

\scalainline{Option[T]} is useful for lots of things, but a common use is to handle unexpected outcomes in code.  Unlike \scalainline{Exception} in Java, which is a \emph{runtime} mechanism for handling unexpected outcomes in a program, \scalainline{Option[T]} is a \emph{compile time} mechanism.  This means that programmers who rely on \scalainline{Option[T]} can be assured that their code handles all known error cases \emph{before the program runs}.  This magical ability is thanks to the fact that Scala's \emph{exhaustivity check} will ensure that all cases are handled.

Here's a simple example.  Often we want to retrieve the first element in a \scalainline{List}.  But what if the \scalainline{List} is empty?  This case is easy to forget.  \scalainline{headOption} makes handling this case foolproof.  This code does not compile:

\begin{scalacode}
val friends : List[String] = List("Anja", "Brent", "Ammar")
val firstFriend : String = friends.headOption
\end{scalacode}

Think for a minute about why this does not compile.

The right way to use \scalainline{headOption} is with your old friend, \emph{pattern matching}.  The following code \emph{does} compile:

\begin{scalacode}
val friends : List[String] = List("Anja", "Brent", "Ammar")
val firstFriend : String = friends.headOption match {
  case Some(friend) => "My first friend is " + friend + "."
  case None => "I have no friends!"
}
// firstFriend: String = My first friend is Anja.
\end{scalacode}

Since the compiler told us that we made a mistake in our first version, we were able to correct it in the second version before we ran the program.  Contrast this against the following code, which compiles without error but throws an exception when we run the program:

\begin{scalacode}
val friends : List[String] = List()
val firstFriend : String = friends.head
\end{scalacode}

We get:

\begin{scalacode}
java.util.NoSuchElementException: head of empty list
  at scala.collection.immutable.Nil$.head(List.scala:420)
  at scala.collection.immutable.Nil$.head(List.scala:417)
  ... 33 elided
\end{scalacode}

\section{Exercise}

The Willy Wonka candy company calls you one morning because they need help modernizing their operation.  They want customers at supermarkets to be able to scan their candy in the self-checkout lanes at the supermarket.  Right now, customers can't do this because there are no barcodes on Wonka products.  Customers are flocking to Slugworth's Sizzlers because buying Wonka candy is so inconvenient.  Wonka wants you to put barcodes on their candy to deal with this situation.

The Wokna company gives you a \scalainline{Map[String,BigDecimal]} of candy names and their prices:

\begin{scalacode}
val candies : Map[String,BigDecimal] = Map(
  "Snozzberries" -> BigDecimal(2.49),
  "Everlasting Gobstopper" -> BigDecimal(0.99),
  "Fizzy Lifting Drink" -> BigDecimal(1.99),
  "Edible Teacup" -> BigDecimal(4.79),
  "Wonka Bar" -> BigDecimal(1.50)
)
\end{scalacode}

Barcodes will be represented using Java's UUID type.  UUID stands for ``universally unique identifier.''  You can create new UUIDs by calling \scalainline{UUID.randomUUID()}.

The Wonka company wants you to implement two functions.  First, they want a function \scalainline{getBarcodeForCandy(c: String) : Option[UUID]} that returns \scalainline{Some} barcode given a candy name, or \scalainline{None} if the candy name is not known.  Second, they want a function \scalainline{getPriceFromBarcode(b: UUID) : Option[BigDecimal]} that returns \scalainline{Some} price given a barcode, or \scalainline{None} if the barcode is not known.

You will need to create two \scalainline{Map[A,B]} data structures for those two functions to work.

\scalainline{val barcodes : Map[String,UUID]} stores the mapping from candy names to barcodes.

\scalainline{val prices : Map[UUID,BigDecimal]} stores the mapping from barcodes to prices.

\underline{Important note:} You are \emph{not} allowed to create \scalainline{barcodes} and \scalainline{prices} by hand.  You must transform \scalainline{candies} programmatically.  Hint: use our old friend, \scalainline{map} with \scalainline{toMap}.  \scalainline{getBarcodeForCandy} and \scalainline{getPriceFromBarcode} should check whether the appropriate \scalainline{Map} contains the key.  If it does, the function should return \scalainline{Some} of the value, otherwise \scalainline{None}.

\section{Templates}

To facilitate a useful discussion, please use the following templates.  \scalainline{???} indicates where you should provide implementations.

Place the following file in \texttt{Discussion4/src/main/scala/CandyDatabase.scala}

\begin{scalacode}
import java.util.UUID

class CandyDatabase(candies: Map[String, BigDecimal]) {
  val barcodes : Map[String,UUID] = ???

  val prices : Map[UUID,BigDecimal] = ???

  def getPriceFromBarcode(b: UUID) : Option[BigDecimal] = ???

  def getBarcodeForCandy(c: String) : Option[UUID] = ???
}
\end{scalacode}

Place the following test file in \texttt{Discussion4/src/test/scala/CandyDatabaseTests.scala}

\begin{scalacode}
import org.scalatest.FunSuite

class ExerciseTests extends FunSuite {
  val candies : Map[String,BigDecimal] = Map(
    "Snozzberries" -> BigDecimal(2.49),
    "Everlasting Gobstopper" -> BigDecimal(0.99),
    "Fizzy Lifting Drink" -> BigDecimal(1.99),
    "Edible Teacup" -> BigDecimal(4.79),
    "Wonka Bar" -> BigDecimal(1.50)
  )

  def barcodeTester(database: CandyDatabase, candy_name: String) : BigDecimal = {
    database
    // query the database for the barcode
      .getBarcodeForCandy(candy_name)
    // and then query the database for the price using the barcode
      .flatMap(database.getPriceFromBarcode)
    // return $0 if any of those lookups fail
      .getOrElse(BigDecimal(0))
  }

  val db = new CandyDatabase(candies)

  test("Everlasting Gobstoppers cost $0.99.") {
    val price = barcodeTester(db, "Everlasting Gobstopper")

    assert(price == candies("Everlasting Gobstopper"))
  }

  test("There is no price on file for a River of Chocolate.") {
    val price = barcodeTester(db, "River of Chocolate")

    assert(price == BigDecimal(0))
  }
}
\end{scalacode}

\input{handin}

\include{tictactoe_hw}

\include{subtyping}
\include{tictactoe_discussion}
\include{bounded_quantification}
\include{generics_hw}
\newlecture

\begin{instructor}

\section{Recap\classtime{15}}
\classtime{15}

\begin{itemize}
  \item The notation \scalainline{A <: B}.
  \item \emph{Invariance}: typically \scalainline{A <: B} does not imply that \scalainline{Container[A] <: Container[B]}, because the container may have a method that writes to a value of type A.
  \item \emph{Covariance}: If the class is annotated \scalainline{Container[+T]}, then the type-checker ensures we can't write to values of type \scalainline{T} within the class.
  \item Traits can take type parameters too, just like classes. When we extend a trait, we need to supply the type parameters.
  \item Bounded quantification: The type parameter\scalainline{C[A]} means that \scalainline{A} could be any type. We can write \scalainline{C[A <: B]} to restrict it to types that extend \scalainline{B}, which allows us to invoke \scalainline{B}-methods on values of type \scalainline{A}.
\end{itemize}
\end{instructor}

\section{Variance and method arguments\classtime{20}}

Earlier, we wrote the simplest container we could imagine that only stored
a single value. The following container slightly more sophisticated, because
it can store two values:
\begin{scalacode}
class Two[+T](private val x: T, private val y: T) {
  def get1(): T = x
  def get2(): T = y
}
\end{scalacode}
This container uses a covariance annotation, so when \scalainline{A <: B},
we have \scalainline{Two[A] <: Two[B]}. Recall that the
intuition for subtyping is that \scalainline{Two[A]} can be used
wherever a \scalainline{Two[B]} is expected. Now, suppose we modify the class to
add functional update methods:
\begin{scalacode}
class Two[+T](private val x: T, private val y: T) {
  ...
  def update1(newX: T): Two[T] = new Two(newX, y)
  def update2(newY: T): Two[T] = new Two(x, newY)
}
\end{scalacode}
This is a natural operation on containers and we should be able to write it.
But, let's ensure that even with this operation, \scalainline{Two[A]} can
be used whenever a \scalainline{Two[B]} is expected.

Concretely, consider the following two classes:
\begin{scalacode}
class Dog {
  def makeSound(): String = "woof"
}

class Poodle extends Dog {
  def bite(): String = "nip"
}
\end{scalacode}

We should be able to use a \scalainline{Two[Poodle]} in all contexts where
a \scalainline{Two[Dog]} is expected.


Consider the following function, which simply updates a container to
store a \scalainline{Dog}:
\begin{scalacode}
def store[A <: Two[Dog]](x: A): A = x.update1(new Dog)
\end{scalacode}
However, it uses bounded-quantification to any subtype of
\scalainline{Two[Dog]}. Therefore, we can apply it to a \scalainline{Poodle}
container and know that the result is still a \scalainline{Poodle}
container. Of course, this isn't true, since the function stores
a \scalainline{Dog}. Therefore, the following code goes wrong:
\begin{scalacode}
val twoPoodles = new Two[Poodle](new Poodle(), new Poodle())
val aPoodle = storeDog(twoPoodles).get1() // Produces a Dog, not a Poodle!
aPoodle.bite() // Crash! Dogs don't have a .bite() method.
\end{scalacode}

Naturally, Scala (and Java) won't allow this to happen. In general, when
a class has a covariant type parameter \scalainline{T}, its methods can
produce values of type \scalainline{T}, but methods' arguments cannot consume
values of type \scalainline{T} (because of the error described above). Therefore, the type-checker
will not allow us to write the update methods, because they use
a covariant type parameter as the type of a method argument.

\paragraph{A solution}
The problem with the code above is that when a \scalainline{Two[A]}
is treated as a \scalainline{Two[B]}, we can update the container to
store any \scalainline{B}-typed value, which then breaks code that expects
\scalainline{A}-typed values. Instead, we need to ensure that we can only store
subtypes of \scalainline{A} in the container. We can express this constraint
using bounded-quantification:

\begin{scalacode}
class Two[+T](private val x: T, private val y: T) {
  ...
  def update1[S >: T](newX: T): Two[S] = new Two(newX, y)
  def update2[S >: T](newY: T): Two[S] = new Two(x, newY)
}
\end{scalacode}
This version of the class does type-check.

If we have a Poodle-container:
\begin{scalacode}
val x = new Two[Poodle](new Poodle, new Poodle)
\end{scalacode}
And we update one of the poodles:
\begin{scalacode}
x.update1[Poodle](new Poodle)
\end{scalacode}
The type-parameter \scalainline{S} is bound to the type \scalainline{Poodle},
so the return type is \scalainline{Two[Poodle]}. However, we can also
update the the container with a \scalainline{Dog}:
\begin{scalacode}
x.update1[Dog](new Dog)
\end{scalacode}
However, in this case, the return type is \scalainline{Two[Dog]} (although one
of the dogs is a poodle).

\paragraph{Appending Lists}
A similar problem arises with list concatenation. Since lists are covariant,
they cannot have an append method with this type:
\begin{scalacode}
sealed trait List[A] {
  def append[A](other: List[A]): List[A] = ...
  ...
}
\end{scalacode}

However, we can use the same trick we used above to write an append
method with the following type:

\begin{scalacode}
sealed trait List[A] {
  def append[B :> A](other: List[B]): List[B] = alist match {
    case Nil => Nil
    case hd :: tl => hd :: tl.append(other)
  }
  ...
}
\end{scalacode}

\section{A Model of Type-Checking\classtime{40}}

\begin{figure}
\scalafile{includes/ScalaFragment.scala}
\caption{A subset of Scala expressions}\label{scalafragment}
\end{figure}

\begin{instructor}
This section is quite rough. I'd start by getting students to derive the expression data-structure from examples.
\end{instructor}


To understand generics, we've had to develop an intuition for how the Scala
type-checker works. A deep understanding of the Scala (or Java) type system is
beyond the scope of this class. However, it is important to have a reasonably
accurate mental model of type-checking to understand and debug type-errors.

\Cref{scalafragment} is a data structure that represents a fragment of
Scala expressions, including numbers, boolean, addition, the less-than operator,
if-expressions, and identifiers (bound with \scalainline{val}). Since
the only values in this fragment are integers and booleans, we can represent
types as follows:

\begin{scalacode}
sealed trait Type
case object TInt extends Type
case object TBool extends Type
\end{scalacode}

Ignoring identifiers, we can write a simple recursive function to type-check
programs in this fragment, as shown in \cref{simpletc}.

\begin{figure}
\begin{scalacode}
object TypeError extends RuntimeException("Type error")

object TypeChecker {

  def tc(expr: Expr): Type = expr match {
    case EInt(_) => TInt
    case EBool(_) => TBool
    case EAdd(e1, e2) => (tc(e1), tc(e2)) match {
      case (TInt, TInt) => TInt
      case _ => throw TypeError
    }
    case ELT(e1, e2) => (tc(e1), tc(e2)) match {
      case (TInt, TInt) => TBool
      case _ => throw TypeError
    }
    case EIf(e1, e2, e3) => (tc(e1), tc(e2), tc(e3)) match {
      case (TBool, t1, t2) if (t1 == t2) => t1
      case _ => throw TypeError
    }
  }
}
\end{scalacode}
\caption{Type-checking, excluding identifiers}\label{simpletc}
\end{figure}

Type-checking identifiers is a little trickier. When we see an identifier,
there is way to determine its type, unless we remember the type
of the expression it was bound to. Therefore, we need an auxiliary
parameter, known as the environment, to ``remember'' the type of identifiers
so that we can recall them later (\cref{tcid}).

\begin{figure}
\begin{scalacode}
object TypeChecker {
  def tc(env: Map[String, Type], expr: Expr): Type = expr match {
    case EInt(_) => TInt
    case EBool(_) => TBool
    case EAdd(e1, e2) => (tc(env, e1), tc(env, e2)) match {
      case (TInt, TInt) => TInt
      case _ => throw TypeError
    }
    case ELT(e1, e2) => (tc(env, e1), tc(env, e2)) match {
      case (TInt, TInt) => TBool
      case _ => throw TypeError
    }
    case EIf(e1, e2, e3) => (tc(env, e1), tc(env, e2), tc(env, e3)) match {
      case (TBool, t1, t2) if (t1 == t2) => t1
      case _ => throw TypeError
    }
    case EVal(x, e1, e2) => tc(env + (x -> tc(env, e1)), e2)
    case EId(x) => env.getOrElse(x, throw TypeError)
  }
}
\end{scalacode}
\caption{Type-checking identifiers.}\label{tcid}
\end{figure}

The actual Scala type-checker is vastly more complicated. But, it follows
this basic design.

\input{samefringe}

\newlecture

\section{The $n$-Queens Problem}

The $n$-queens problem is to place $n$ queens on an $n \times n$ chessboard
such that no queens threaten each other.
If you aren't familiar with the
rules of Chess: a queen is a chess piece that move horizontally, vertically,
or diagonally across a chessboard, which is typically an $8 \times 8$ matrix.
A queen can ``kill'' any piece that it can move to, so it is unsafe to be
on the same horziontal, vertical, or diagonal line as a queen. The $n$-queens
problem is to arrange $n$-queens on a generalized $n \times n$ chessboard,
such that no pair of queens can kill each other.

The $n$-queens problem is a canonical example of a constraint-satisfaction
problem that can be solved by backtracking search. In this lecture, we'll
begin with a naive implementation of backtracking search, and then refine
it to use constraint-propagation, which will make it a lot faster.

\section{A trait for chessboards}

\begin{figure}
\scalafile{includes/nqueens/src/main/scala/ChessBoardLike.scala}
\caption{A trait for chessboards.}
\label{ChessBoardLike}
\end{figure}

Since we are going to go through a few different representations of chessboards,
it will help to factor out generic code that prints the representation of
chessboards. The \scalainline{ChessBoardLike} trait in \cref{ChessBoardLike}
defines a \scalainline{toString} method that prints a chessboard of queens,
where each queen is printed as \texttt{Q} and each blank space appears as
\texttt{.}. This printing method requires the implementing class to have
a field that specifies that dimensions of the chessboard and set of coordinates
that describe where the queens are placed.

\section{Backtracking Search}

\begin{figure}
\scalafile{includes/nqueens/src/main/scala/NaiveQueens.scala}
\caption{A naive solution to the $n$-queens problem.}
\label{NaiveQueens}
\end{figure}

The core idea of any solution to the $n$-queens problem is to write a recursive
function (called \scalainline{solve}) that places 1 new queen on the current
board in a position where it does not threaten any existing queen and then
recursively calls \scalainline{solve} to place the remaining queens. The
function terminates sucessfully when $n$ queens have been placed on the board.
The function terminates with an error if there are no positions where the next
queen can be safely placed. In any application of \scalainline{solve}, there may
be several positions where a queen can be safely placed. The key to backtracking
is to try a new position if the recursive application produces an error.

\Cref{NaiveQueens} shows a simple implementation of this idea. The key function
is the \scalainline{canPlace} predicate which determines if a new queen
maybe placed at coordinates $(x,y)$ by checking if there are any existing
queens in the set \scalainline{solution} on the same row, column, diagonal,
or antidiagonal.

\begin{instructor}
These notes could be expanded substantially in the future.
\end{instructor}

We can run the solver as follows:

\begin{scalacode}
(new NaiveQueens(n, Set())).solve()
\end{scalacode}
With $n = 11$, the solver produces a solution in less than a second on my
laptop, with $n = 12$, it takes 55 seconds, and $n = 13$ would take much longer.

\section{Constraint Propagation}

\begin{figure}
\scalafile{includes/nqueens/src/main/scala/OptQueens.scala}
\caption{A constraint-propagating solution to the $n$-queens problem.}
\label{OptQueens}
\end{figure}

\Cref{OptQueens} shows a variant of the naive solver that is substantially
faster. The key idea to store a set of locations where a queen can be placed
without violating any constraints and then prune the set whenever a new queen
is placed.


\newlecture

\section{$n$-Queens using Propositional Logic}

\begin{instructor}
These notes are not complete.
\end{instructor}

We covered the $n$-Queens problem with Z3.
Here is the corrected code with some minor cleanup:
 
https://gist.github.com/arjunguha/7c1f9d3a9fad37f17965
 
If you want to actually solve things, you'll need the Z3 Theorem Prover:
 
https://github.com/Z3Prover/z3/releases
 
There is a fun Z3 tutorial here:
 
http://rise4fun.com/Z3/tutorial/guide

\input{implicit_classes}

\input{sudoku}

\input{sudoku_discussion}

\input{streams}

\input{regex}

\input{implicits_hw}

\input{regex_hw}

\input{parsing_hw}

\newdiscussion{Implicits (Apr 6)}

This discussion will cover the first two questions of Homework 8, which asks you to use Scala implicits to wrap ``ugly'' Java interfaces with ``pretty'' Scala interfaces.

\section{What you need to do}

We will be completing HW 8, programming tasks 1 and 2 in class.  These two assignments are reproduced below.

\begin{enumerate}

  \item We should be able to construct paths by using the slash-operator to separate strings. For example, the expression \scalainline{"usr" / "bin" / "scala"} should be equivalent to the expression \scalainline{Paths.get("usr", "bin", "scala")}. 
  \item Similarly, given two paths, we should be able to join them using the slash-operator. For example, if \scalainline{p1} is \scalainline{"usr" / "local"} and \scalainline{p2} is \scalainline{"bin" / "scala"} then \scalainline{p1 / p2} should be equivalent to \scalainline{Paths.get("usr", "local", "bin", "scala")}. 
\end{enumerate}

\section{Hints}

First hint: this assignment requires \emph{neither} Scala implicit functions to work \emph{nor} Scala implicit function parameters.  You \emph{only} need Scala implicit classes.  If you do not remember the difference between these sorts of implicits, I strongly suggest that you familiarize yourself with their definitions.

Second hint: remember that Scala implicit classes require a few ingredients in order to work.  The most important ingredients are described here, but you can find the complete list of rules at: \url{https://www.artima.com/pins1ed/implicit-conversions-and-parameters.html#21.2}

\begin{enumerate}
  \item You must create a class and mark it as \scalainline{implicit}.
  \item Implicit classes must be defined inside an \scalainline{object}, \scalainline{trait}, or \scalainline{class}.
  \item The implicit class must be visible from the scope of the expression that you want rewritten.
  \item The compiler \emph{will not} attempt to rewrite an expression to use an implicit class if it type-checks as-is.  In other words, the expression must fail to type check \emph{unless} the compiler can find an implicit class in scope that causes the type check to succeed.
\end{enumerate}

\begin{instructor}
\section{Solutions}
  
Note that I have elided parts of the solution that are not directly related to the first two programming tasks.  The reason is that I want students to have to think about the rest of the solution on their own.

\begin{scalacode}
  import java.nio.file._

  object PathImplicits {  
    implicit class RichPath(p: Path) {
      def /(p2: String) : Path = p.resolve(p2)
      def /(p2: Path) : Path = p.resolve(p2)
    }

    implicit class RichString(s: String) {
      def /(s2: String) : Path = Paths.get(s).resolve(s2)
      def /(p2: Path) : Path = Paths.get(s).resolve(p2)
    }
  }
\end{scalacode}
  
\end{instructor}


\newdiscussion{Regular Expressions (Apr 13)}

A \emph{regular expression}, also known as ``regex,'' is a powerful feature of most modern programming languages.  Regexes allow programmers to build sophisticated string-manipulating functions with relative ease.  They are built on a simple, elegant formalism called \emph{finite automata}.  You may encounter some ugly regular expressions in the real world, but if you keep in mind that they are simple machines, you will always be able to understand them.~\footnote{For example, here are some seriously ugly regular expressions for validating URLs: \url{https://mathiasbynens.be/demo/url-regex}.}:

\section{Regular Expression Primer}

A regular expression is a sequence of text characters.  For example, the regular expression \texttt{aa} \emph{accepts} the string \scalainline{"aa"} and \emph{rejects} all other strings.  One way to think of \texttt{aa} is as a function that takes a \scalainline{String} as input and that returns a \texttt{Boolean} as output: \scalainline{true} if the string is \scalainline{"aa"} and \scalainline{false} otherwise.

A regular expression is equivalent to a class of \emph{state machines} called a \emph{nondeterministic finite automaton}, or NFA.  NFAs can be drawn as a directed graph, and having this graph in your head helps understand what the regular expression algorithm does.  The rules are simple.  (1) Every possible change in the state of the machine (a ``transition'') is uniquely determined by the source state and input symbol.  (2) The machine ``accepts'' if and only if a sequence of input symbols results in the NFA ending in an ``accepting'' state (a circle with double lines).

Here's the NFA for the regular expression \texttt{aa}:

\begin{center}
  \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm,
                      semithick]
    \tikzstyle{every state}=[fill=none,draw=black,text=black]

    \node[initial,state] (1)              {$q_0$};
    \node[state]         (2) [right of=1] {$q_1$};
    \node[state,accepting]         (3) [right of=2] {$q_2$};
    \path (1) edge              node {a} (2)
          (2) edge              node {a} (3);
  \end{tikzpicture}
\end{center}

\subsection{Analogy: Hunt the Wumpus}

Think of this graph as a maze\footnote{See \url{https://en.wikipedia.org/wiki/Hunt_the_Wumpus}}.  You start at $q_0$, the circle at the beginning of the maze.  Your goal is to get to $q_2$, the circle at the end of the maze (the one with double lines).  You can follow paths (arrows) in the direction that they point, but not the other way.  And unfortunately, this maze is filled with evil, dangerous creatures!  Now, you're no fool.  You brought a map!  If your map is right, you make it out alive.  If not, you meet your doom in the maze.  Is your map any good?

Your map is the input string \scalainline{"aa"}.  Start at $q_0$.  The map says to go down path \scalainline{"a"}.  OK, that takes us to $q_1$.  After that, the map says to go down path \scalainline{"a"}.  Great!  This brings us to $q_2$.  We made it out!  The maze ``accepts'' the map.

What if we had the map \scalainline{"bb"}?  We'd start at $q_0$ and go to $q_1$.  But then the map says to take the path \scalainline{"b"}.  There is no \scalainline{"b"} path.  We're doomed! The maze ``rejects'' the map and the wumpus (\includegraphics[width=0.5cm]{wumpus.jpg}) eats you.

\subsection{One Caveat (Among Many) to My Beautiful Analogy}

Note that my analogy assumes that our input string and our regular expression both start and end in the same place.  This fact would imply that a regular expression matches an \emph{entire input string}.  In practice, it is often useful to write regular expressions that match a \emph{substring}.  In many regular expression implementations, one denotes whole-string matches by prepending the regex with the \texttt{\^{}} character and appending it with the \texttt{\$} character.  For example, \texttt{aa} becomes \texttt{\^{}aa\$}.

Scala's \scalainline{regex.pattern.matcher(str).matches()} (where \scalainline{regex} is a regex and \scalainline{str} is an input string) always matches the entire string, so \texttt{\^{}} and \texttt{\$} are unnecessary.  Other Scala regex methods do not work this way.  You should be careful that the function you use has the semantics that you want, so please check the Scala docs if you are unsure.

\section{Discussion Programming Tasks}

We are going to do programming tasks 2 and 5 in class.  They are:

\begin{itemize}

  \item Define the regular expression \scalainline{time}, which only matches times written as five-character strings \texttt{HH:MM}, where the hours range from 00--23 and the minutes from 00--59.
 
  \item Define the regular expression \scalainline{comment}, which only matches strings that start with \texttt{/*} and end with \texttt{*/}.

\end{itemize}

\section{Homework Hint for the Parity-Checking Regular Expression}

The last regex is a tricky one.  It helps if you know a certain arithmetical law~\footnote{Which is somewhere on this page: \url{https://en.wikipedia.org/wiki/Parity_(mathematics)}}.

\include{parsing}

\include{gadts}

\end{document}
