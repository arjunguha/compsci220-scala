\documentclass{book}
\usepackage{pervasives}

\title{CMPSCI220 Course Book}

\begin{document}

\maketitle
\tableofcontents

\newlecture

\textbf{Course Description}: Development of individual skills necessary for
designing, implementing, testing and modifying larger programs, including: use
of integrated design environments, design strategies and patterns, testing,
working with large code bases and libraries, code refactoring, and use of
debuggers and tools for version control.

\section{Introduction\classtime{15}}

\emph{CMPSCI220 Programming Methodology} introduces you to all the concepts
above in the context of a modern programming language:
\href{http://www.scala-lang.org/what-is-scala.html}{Scala}.
You could use Scala to write exactly the same kind
of object-oriented code that you've seen in Java. In fact, Scala code and Java
code can seamlessly co-exist and interoperate in the same program; we'll
leverage this feature later in the course. In fact, many of the design patterns
that you will learn in this course will be applicable to Java and Scala.

However, a key reason we're using Scala is to expose you to programming techniques
and language features that are beyond the scope of Java. Most
modern software systems are written in a plethora of languages. In fact, large
systems tend to use several programming languages. Therefore, to succeed in your
computing career, you have to be familiar with several languages and be able to
learn new languages on your own. Programming
languages and constantly invented and abandoned\footnote{\href{http://www.oreillynet.com/pub/a/oreilly/news/languageposter_0504.html}{This poster} is a very incomplete history of the birth and death of programming languages.}
 and it is impossible to predict the next big language that everyone
will use or the language you'll need to learn for your first job.

Scala is a big language with many unique features and we are not going to learn
to use them all. Instead, we are going to focus on ideas that Scala shares with
other modern programming languages. Here are some of the key ideas that we will
cover in this course that go beyond Java:
%
\begin{itemize}

\item \emph{First-class functions} are the cornerstone of \emph{functional programming}.
  They are pervasive in JavaScript, Ruby, Python, Swift, and almost all modern
  languages.

  In fact, even \href{{http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html}}{Java} and
  \href{http://msdn.microsoft.com/en-us/library/dd293608.aspx}{C++} recently
  added support for first-class functions.

\item \emph{Algebraic data types} are available in Apple Swift, Mozilla Rust,
  Microsoft F\#, and several other programming languages. Programming with
  algebraic data types is very different from programming in an object-oriented
  style. We'll cover both styles of programming in this course and develop
  a deep understanding of the tradeoffs.

\item \emph{Type inference} is available in modern typed programming languages,
  such as C\# and Swift, and even in a limited form in
  \href{http://docs.oracle.com/javase/tutorial/java/generics/genTypeInference.html}{Java}.
  As the name suggests, in a language with type inference, the compiler can
  often ``infer'' or fill-in types that you omit. So, your programs become shorter, but
  retain all the advantages of type checking.

\end{itemize}

The main themes of the course are not language-specific. We will emphasize
the following broad ideas that are applicable to all software development:
%
\begin{itemize}

\item \emph{Testing} is critical for building reliable software. You will learn how
  to test complex functions and make effective use of testing tools and frameworks.
  Every programming problem you solve in this course will have to be tested. We
  expect you to write good tests yourself. The quality of your tests will be a
  significant portion of your grade on every assignment.

\item \emph{Design patterns} are recipes for solving typical programming
  problems. This course will emphasize object-oriented and functional
  design patterns. We will focus on design patterns that are applicable to
  a variety of programming languages, and not Scala-specific design patterns.

\item \emph{Refactoring} is a key concept that we emphasize throughout the
  course. As we introduce new ideas, we will systematically refactor our old
  code to exploit them.

\item \emph{Debugging} is a necessary skill because even small programs often
  have bugs.

\item \emph{Command-line tools} such as compilers and build tools lie under the
  hood of sophisticated IDEs such as Eclipse. Learning to use the command-line
  will make you a better IDE user. Moreover, since many new languages lack good
  IDEs, we will emphasize the use of command-line tools in this course.

\item \emph{Version control} software is critical for collaborative software
  development and used by all professional programmers. Although you will be
  programming alone in the course, version control will still help you organize
  your programming and save you a lot of time if you accidentally delete or
  break your code.

\item \emph{Using libraries} is critical for writing software that gets real
  work done. Initially, you'll use libraries that were developed specifically
  for this course, but you will eventually learn to discover and use
  libraries from the Web.

\end{itemize}

The overarching goal of this course is to make you a better programmer,
and an important part of that is to get familiar with programming terminology
and culture. Unfortunately, there is a lot of misinformation on the Web
about programming, but we will try to point you to sources that are reliable.
Here are two good places to start:
%
\begin{itemize}

  \item \href{http://paulgraham.com/articles.html}{Paul Graham's Essays}.
  The earlier essays are particularly pertinent, E.g.,
  \href{http://paulgraham.com/avg.html}{Beating the Averages} and
  \href{http://paulgraham.com/popular.html}{Being Popular}.

  \item \href{http://www.joelonsoftware.com}{Joel Spolsky's blog}. E.g.,
  \href{http://www.joelonsoftware.com/articles/CollegeAdvice.html}
  {Advice for Computer Science College Students}
  and \href{http://www.joelonsoftware.com/articles/ResumeRead.html}
  {Getting Your Resume Read}.

\end{itemize}

Finally, \href{http://xkcd.com}{XKCD} comics often make obscure programming
references and this course will help you decipher some of them.

\section{The Command-Line\classtime{5}}

The \emph{Linux command-line}\footnote{The command-line is also known as a
\emph{terminal} or \emph{shell}.} is  a critical part of this course. If you're
using the course virtual-machine, you should use the program \textbf{LXTerminal}
to start the command-line.

Unless you're already familiar with the Linux command-line, you must read
\href{http://learncodethehardway.org/cli/book/cli-crash-course.html}{Zed Shaw's Command Line Crash Course},
up to and including the chapter ``Removing a File (rm)''. Zed likes to swear at
his own readers, so we'd like to apologize in advance on his behalf. The rest
of these lecture notes assume that you are familiar with the command-line.

\begin{instructor}
\begin{itemize}

\item Introduce the course VM.

\item  Introduce the command line (\verb|mkdir|, \verb|cd|, and, \verb|ls|).
\end{itemize}

\end{instructor}

\section{\sbt{} and the Scala REPL\classtime{5}}

\sbt{} is the Swiss Army Knife of Scala programming. It is a command-line tool
that can be use to run Scala programs, compile them, test them, package them
deployment, publish them to the Web, and more. Like many modern programming
languages, \sbt{} has a \emph{REPL} (read-eval-print loop), which you can use to
type in and run one-line programs immediately, without the bother of creating
files, etc.

To start the Scala REPL, open a terminal (LXTerminal on the course VM),
type in \verb|sbt console| and press enter. Your screen will look like this:
%
\begin{console}
student@vm:~$ sbt console
[info] Loading global plugins from /Users/arjun/.sbt/0.13/plugins
[info] Set current project to del (in build file:/Users/arjun/scratch/del/)
[info] Updating {file:/Users/arjun/}arjun...
[info] Resolving org.fusesource.jansi#jansi;1.4 ...
[info] Done updating.
[info] Starting scala interpreter...
[info]
Welcome to Scala version 2.11.7 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_60).
Type in expressions to have them evaluated.
Type :help for more information.

scala>
\end{console}

The \verb|scala>| prompt indicates that you can type in Scala expressions to evaluate.

\section{Scala Basics\classtime{15}}

\subsection{Simple Expressions and Names}

Arithmetic in Scala is very similar to arithmetic in Java:

\begin{console}
scala> 19 * 17
res0: Int = 323
\end{console}

Strings in Scala will also look familiar:

\begin{console}
scala> "Hello, " + "world"
res1: String = Hello, world
\end{console}

Boolean expressions will be familiar too:

\begin{console}
scala> true && false
res2: Boolean = false
\end{console}

Let's examine the last interaction more closely. When you type \scalainline{true && false},
Scala prints three things:
%
\begin{itemize}
\item An automatically-generated \emph{name} (\scalainline{res2}),
\item The \emph{type} of the expression (\scalainline{Boolean}), and
\item The \emph{value} of the expression (\scalainline{false}).
\end{itemize}

On the Scala REPL, you can use the generated name as a variable. But, you're
better off picking meaningful names yourself using \scalainline{val}:

\begin{console}
scala> val mersenne = 524287
mersenne : Int = 524287
scala> val courseName = "Programming Methodology"
courseName : String = Programming Methodology
\end{console}

\subsection{Type Inference}

You'll find that Scala programs are significantly shorter than their Java
counterparts. A key feature of Scala that lets you write less code is \emph{type
inference}. Notice in the variable definitions above, you did not have to write
any types. Instead, Scala \emph{inferred} them for you. This feature is very helpful
in larger programs, where types can become complex.

Type inference is not magic; later in the course, you'll learn more about how it
works and when it doesn't. For now, here's a rule of thumb: Scala can infer the
type of variable named with \verb|val|. But, Scala \emph{cannot} infer the type of
function parameters.

\subsection{Functions}

Here is a very simple Scala function:

\begin{console}
scala> def double(n: Int): Int = n + n
double: (n: Int)Int
\end{console}

This code defines a function called \scalainline{double}, which takes an argument called
\scalainline{n} of type \scalainline{Int} and returns a value of type \scalainline{Int}. We can apply the
function as follows:

\begin{console}
scala> double(10)
res3: Int = 20
\end{console}

The following function takes two arguments, \scalainline{x} and \scalainline{y} and calculates the
distance from the point \scalainline{(x,y)} to the origin:

\begin{console}
scala> def dist(x: Double, y: Double): Double = math.sqrt(x * x + y * y)
dist: (x: Double, y: Double)Double

scala> dist(3.0, 4.0)
res4: Double = 5.0
\end{console}

Notice that unlike variable definitions, we need \emph{type annotations}
on function parameters and result types.

If your function actually fits on a line (without scrolling off your window),
you can define them very tersely as shown above. But, many interesting
functions span several lines and need local variables.

\subsection{Blocks and Local Variables}

You can define local variables within a \emph{block}. A block is code delimited by
curly-braces. For example:

\begin{console}
scala> def dist2(x: Double, y: Double): Double = {
  val xSq = x * x
  val ySq = y * y
  math.sqrt(xSq + ySq)
}
\end{console}

\begin{figure}
\scalafile{code/Lecture1fac.scala}

\caption{A Scala module}
\label{lecture1code}
\end{figure}

\section{\sbt{} Project Structure\classtime{5}}

In principle, you can write a full-fleged program line-by-line in the Scala
console. But, it makes a lot more sense to save large programs to files
for a particular project. To do so, we will being by creating a new directory
for your project.

First, exit the Scala console by typing \verb|:quit| and then exit \sbt{}
by typing \verb|exit|. You should return to the command-line:
%
\begin{console}
scala> :quit

[success] Total time: 3 s, completed Jan 13, 2016 8:47:38 PM

sbt> exit
student@vm:~$
\end{console}

At the terminal, let's create a directory for the project:
%
\begin{console}
student@vm:~$ mkdir lecture1
\end{console}
%
Then, let's enter the directory:
\begin{console}
student@vm:~$ cd lecture1
student@vm:~/lecture1$
\end{console}
Notice that the name of the directory is displayed on the command-line.

Your Scala projects will have two kinds of files: test cases and your implementation.
\sbt{} requires you to organize your files into the following directory
structure:
\dirtree{%
.1 ~/lecture1.
.2 src.
.3 main.
.4 scala\DTcomment{Implementation goes here}.
.3 main.
.4 scala\DTcomment{Tests goes here}.
}

You can create these directories by running the following commands:
\begin{console}
student@vm:~/lecture1$ mkdir src
student@vm:~/lecture1$ mkdir src/main
student@vm:~/lecture1$ mkdir src/main/scala
student@vm:~/lecture1$ mkdir src/test
student@vm:~/lecture1$ mkdir src/test/scala
\end{console}

We will now see how to save Scala code to files. Using a text editor
(e.g., Sublime Text), create a file called \verb|Lecture1.scala| in the
\verb|src/main/scala| directory, with the contents shown in \cref{lecture1code}.
The code creates an object with a single function to calculate factorials.

\begin{instructor}
Scala wart: Do not \verb|extend App| because it can't be evaluated in console.
\end{instructor}

When you write functions in a Scala file, you \emph{have} to place it in
an object. You cannot just write \scalainline{def fac ...} without an enclosing
object. This is a peculiarity of Scala that we will explain later in the course.
In this example, the name of the object is ``Lecture1'', but it can be anything
you like.

Now that we've saved this function to a file, we can use it from the console:
%
\begin{console}
sbt> console
scala> import Lecture1._
scala> fac(10)
\end{console}

\begin{figure}
\begin{scalacode}
// src/main/scala/Lecture1Tests.scala
import Lecture1._

class Lecture1Tests extends org.scalatest.FunSuite {

  test("fac -- base case") {
    assert(fac(0) == 1)
  }

  test("fac -- inductive case") {
    assert(fac(5) == 120)
  }

}
\end{scalacode}
\caption{Unit tests for the code in \cref{lecture1code}}
\label{lecture1tests}
\end{figure}

\section{Testing\classtime{5}}

The \sbt{} console is a convenient way to experiment with new code or write
a ``one off' functionn. However, you must write \emph{unit tests} to test
any actual code you write. \Cref{lecture1tests} shows an example of
unit tests that use the \emph{ScalaTest} library. The code is quite self-explanatory:
each test suite is a class that extends \scalainline{org.scalatest.FunSuite}.
The body of the class has several test blocks, as shown in the figure.

\begin{instructor}

\begin{itemize}

\item Propose a new function to write. Write the test-cases first, then
the implementation and re-run \verb|sbt test|.

\item Recap the development methodology: first write tests cases, then
write the implementation, and re-test continuously. Show continuous
testing with \verb|~test|.

\end{itemize}


\end{instructor}

\section{Building and Pattern-Matching on Lists\classtime{25}}


In this section, we will show how to write simple list-processing functions. We
will cover basic \emph{functional programming} and introduce \emph{pattern
matching}.

\subsection{Constructing Lists}

The simplest list is the empty list, which is written in Scala as
%
\begin{scalacode}
Nil
\end{scalacode}
%
Given the empty list, we can construct larger lists using the \scalainline{::}
operator (which is pronounced \emph{cons}). Here is a simple example that
constructs a one-element list:
%
\begin{scalacode}
50 :: Nil
\end{scalacode}
Given a one-element list, we can build a two-element list by using the 
\scalainline{::} operator again:
%
\begin{scalacode}
100 :: (50 :: Nil)
\end{scalacode}
%
We can use \scalainline{::} again to build a three-element list:
%
\begin{scalacode}
200 :: (100 :: (50 :: Nil))
\end{scalacode}
%
In an expression \scalainline{x :: y},
\scalainline{x} is known as the \emph{head} of the list and \scalainline{y} is
known as the \emph{tail}. Note that the tail of a list is always a list itself,
(though it may be the empty list \scalainline{Nil}). 

For example, consider the list below:
\begin{scalacode}
val letters = "a" :: ("b" :: :: Nil)
\end{scalacode}
%
\begin{itemize}

  \item The head of \scalainline{letters} is \scalainline{"a"}.

  \item The tail of \scalainline{letters} is \scalainline{"b" :: Nil}.

  \item The head of the tail of \scalainline{letters} is \scalainline{"b"}.

  \item The tail of the tail of \scalainline{letters} is \scalainline{Nil}.  

  \item \scalainline{Nil} does not have a head or a tail.

\end{itemize}

In our examples so far, we've used parenthesis to make the head and tail clear.
However, you can simply write \scalainline{"a" :: "b" :: "c" :: Nil}. Intuitively,
everything to the right of a \scalainline{::} is the tail. If you get confused
up, write the parenthesis explicitly.

It is usually easier to write lists in the following way:
%
\begin{itemize}

  \item \scalainline{List("a", "b", "c")} is equivalent to
  \scalainline{"a" :: ("b" :: ("c" :: Nil))}.

  \item \scalainline{List()} is equivalent to \scalainline{Nil}.

\end{itemize}
%
However, it is important to understand that this is just a convenient notation.
Under the hood, Scala transforms these expressions to use \scalainline{::}
and \scalainline{Nil}, as we described above.

\paragraph{Lists and Type Inference}

You should try to type out the expressions above into the \sbt{} console.
For example:
%
\begin{console}
scala> val lst = 1 :: 2 :: 3 :: Nil
lst: List[Int] = List(1, 2, 3)
\end{console}
%
As you can see, Scala prints lists using the shorthand notation,
even if you explicitly use \scalainline{::} and \scalainline{Nil}.
More significantly, Scala has inferred that the type of the list
is \scalainline{List[Int]}. There was no need to explicitly state that
is is the case.

Here is another example, where Scala infers that the type of a list is
\scalainline{List[String]}:
%
\begin{console}
scala> val lst = List("a", "b", "c")
lst: List[String] = List("a", "b", "c")
\end{console}

Type inference is very convenient and spares you from having to explicitly
specify the type of the element. However, type inference is not magic
and can behave in unexpected ways. For example, in the interaction
below, Scala infers that the type of the list is \scalainline{List[Any]}:
%
\begin{console}
scala> val lst = List("a", 10, "c")
lst: List[Any] = List("a", 10, "c")
\end{console}
Although this is technically true, if you write this code, it is more
likely that you made a mistake and intended to actually create a list of
strings. If you're ever unsure, you can write the type explicitly, which
would signal a type error in this case:
\begin{console}
scala> val lst = List[String]("a", 10, "c")
<console>:10: error: type mismatch;
 found   : Int(10)
 required: String
       val lst = List[String]("a", 10, "c")
                                   ^
\end{console}

\begin{figure}

\begin{subfigure}[b]{0.45\textwidth}
\begin{scalacode}
def countDown(n: Int): List[Int] = {
  if (n == 0) {
    Nil
  }
  else {
    n :: countDown(n - 1)
  }
}
\end{scalacode} 
\caption{}
\label{countDown}
\end{subfigure}
\hskip 2em
\begin{subfigure}[b]{0.45\textwidth}
\begin{scalacode}
def fromTo(lo: Int, hi: Int): List[Int] = {
  if (lo == hi) {
    lo :: Nil
  }
  else {
    lo :: fromTo(lo + 1, hi)
  }
}
\end{scalacode} 
\caption{}
\label{fromTo}
\end{subfigure}

\caption{Functions that produce lists.}
\label{listcons}
\end{figure}

\paragraph{Functions that produce lists}

Now that we've seen how to construct lists explicitly, it is straightforward
to write functions that produce lists. \Cref{listcons} shows some simple
recursive functions that construct new lists.

\begin{figure}
\begin{subfigure}[b]{0.45\textwidth}
\begin{scalacode}
def product(lst: List[Int]): Int = lst match {
  case Nil => 1
  case n :: rest => n * product(rest)
}
\end{scalacode}
\caption{Calculate the product of a list of numbers.}
\end{subfigure}
\hskip 2em
\begin{subfigure}[b]{0.45\textwidth}
\begin{scalacode}
def repeatTwice(lst: List[Int]): List[Int] = lst match {
  case Nil => Nil
  case n :: rest => n :: n :: repeatTwice(rest)
}
\end{scalacode}
\caption{Repeats every element of a list twice.}
\end{subfigure}

\caption{Two simple functions that consume lists.}
\label{listconsumers}
\end{figure}


\subsection{Pattern Matching}

Now that we've seen how to write functions that produce lists, we'll
learn how to write functions that consume lists as arguments. We'll
start by writing a simple functions to calculate the sum of a list of numbers.
Here are some examples of of \scalainline{sum} being used:
%
\begin{scalacode}
assert(sum(20 :: 30 :: Nil) == 50)
assert(sum(1 :: 2 :: 3 :: Nil) == 6)
\end{scalacode}

Intuitively, to calculate \scalainline{sum(1 :: 2 :: 3 :: Nil)}, we can
can recursively calculate the sum of the tail and and that value to the
head:
\begin{scalacode}
   sum(1 :: 2 :: 3 :: Nil) 
== 1 + sum(2 :: 3 :: Nil)
== 1 + (2 + sum(3 :: Nil))
== 1 + (2 + (3 + sum(Nil)))
\end{scalacode}
%
The last line shows an important special case. Since the empty list
doesn't have a head or a tail, we need to treat it differently. We'll say
that \scalainline{sum(Nil)} is \scalainline{0}.

We can write \scalainline{sum} by using a powerful feature of
Scala called \emph{pattern matching}.
%
\begin{scalacode}
def sum(lst: List[Int]): Int = {
  lst match {
    case Nil => 0
    case h :: t => h + sum(t)
  }
}
\end{scalacode}
%
This code makes it clear that the function is inspecting \scalainline{lst}
and considering two \emph{cases}. When \scalainline{lst} is \scalainline{Nil},
it produces \scalainline{0} and when \lstinline{lst} is constructed with
the \scalainline{::} operator, the function recurs on the tail and ands
that result to the head. In this code, 
\scalainline{Nil} and \scalainline{h :: t} are called \emph{patterns}.

\Cref{listconsumers} shows two more list-consuming functions that
use pattern-matching. Notice that in \scalainline{::} cases, these functions
use different variable names for the head and the tail. A pattern can use
any variable to refer to the value of the head or the tail.

\begin{figure}
\begin{subfigure}[b]{0.45\textwidth}
\begin{scalacode}
def countOnes(lst: List[Int]): Int = lst match {
  case Nil => 0
  case n :: rest => {
    if (n == 1) {
      1 + countOnes(rest)
    }
    else {
      countOnes(rest)
    }
  }
}
\end{scalacode}
\caption{Counting ones using an if-expression.}
\label{countonescomplex}
\end{subfigure}
\hskip 2em
\begin{subfigure}[b]{0.45\textwidth}
\begin{scalacode}
def countOnes(lst: List[Int]): Int = lst match {
  case Nil => 0
  case 1 :: rest => 1 + countOnes(rest)
  case n :: rest => countOnes(rest)

}
\end{scalacode}
\caption{Counting ones using a composite pattern.}
\label{countonessimple}
\end{subfigure}

\caption{Pattern matching can make complex conditionals clearer.}
\end{figure}

\paragraph{Complex Patterns}
%
Pattern-matching is extremely powerful and can be used to express
complex conditionals. For example, \cref{countonescomplex} is a function
that counts the number of \scalainline{1}s that occur in a list: it uses
pattern matching as introduced above and then an if-expression to
check if the head of the list is \scalainline{1}.

\Cref{countonessimple}
is the same function, rewritten to use pattern matching. This version is shorter
and makes it clear that there are three cases. To do so, we exploit the fact
that patterns can match \emph{almost} any value, including numbers,
strings, lists, and user-defined data structures too (which we will see
in a later class).

\paragraph{Exhaustivity and Reachability Checking}
%
Here is another function that uses pattern matching to count the number
of tens in a list:
%
\begin{scalacode}
def countTens(lst: List[Int]): Int = lst match {
  case 10 :: rest => 1 + countTens(rest)
  case n :: rest => countTens(rest)
}
\end{scalacode}

However, this function had a bug. Do you see it? If you type this into
a console, Scala prints the following:
%
\begin{console}
<console>:10: warning: match may not be exhaustive.
It would fail on the following input: Nil
       def countTens(lst: List[Int]): Int = lst match {
                                            ^
\end{console}
%
Scala has detected that we forgot to write a case for \scalainline{Nil}. 
Scala ensures that your patterns are \emph{exhaustive}. Here is another
buggy version of the function:
%
\begin{scalacode}
def countTens(lst: List[Int]): Int = lst match {
  case n :: rest => 1 + countTens(rest)
  case n :: rest => countTens(rest)
  case Nil => 0
}
\end{scalacode}
%
In this version, we wrote the patterns incorrectly, so the first and second
patterns are identical. Scala reports the following error:
\begin{scalacode}
<console>:13: warning: unreachable code
         case n :: rest => countTens(rest)
\end{scalacode}
%
Scala ensures that all cases are \emph{reachable}.

This automatic exhaustivity and reachability checking makes programs that
use pattern-matching much more robust than programs that use complicated,
nested if-statements. Pattern matching is a very powerful tool that you can
exploit to make your programs more robust. We will emphasize pattern-matching
over conditionals in this course.

\chapter{Homework 1: Introduction to Functional Programming}

Scala ``finger exercises'' that involve writing recursive list-processing
functions and defining datatypes. Ensure that everything is testable.

\newlecture

\begin{instructor}

\section{Lecture 1 Recap\classtime{15}}

\begin{itemize}

  \item Slowly talk through the command-line commands involved in creating,
  changing to it, and starting \sbt{}.

  \item Create a file with a simple list-processing function. (Pick something
  that is not in the homework.)

  \item Create a test-suite for the function and run it using \sbt{}.

  \item Show the \sbt{} console briefly.

\end{itemize}

\end{instructor}

\begin{figure}
\begin{subfigure}[b]{.45\textwidth}
\begin{javacode}
public class Point {

  double x;
  double y;

  public Point(double x, double y) {
    this.x = x;
    this.y = y;
  }

}

Point pt = new Point(1, 2)
\end{javacode}
\caption{A Java class that represents a point.}\label{javapoint}
\end{subfigure}
\vrule
%
\begin{subfigure}[b]{.45\textwidth}
\begin{scalacode}
class Point(x : Double, y : Double)
val pt = new Point(1, 2)
\end{scalacode}
\caption{A Scala class that represents a point.}\label{scalapoint}
\end{subfigure}
\caption{Scala code is usually much shorter and simpler than Java code.}
\end{figure}

\section{Case Classes\classtime{10}}

Just like Java, Scala has classes and even supports advanced features that are
beyond the scope of classes in Java. Scala classes tend to be shorter than their
Java counterparts. For example, \cref{javapoint} shows a \verb|Point| class
in Java and \cref{scalapoint} shows the equivalent class in Scala, which
is much shorter!

Naturally, if want to add methods or other constructors, you'll have to write
more code in Scala too. But, simple classes tend to be very short.
But, we are not going to use classes yet. Instead, we are going to use
\emph{case classes}, which are unique to Scala.

If you write \verb|case class| instead of just \verb|class|, you get several
conveniences:

\begin{scalacode}
case class Point(x: Double, y: Double)
\end{scalacode}

First, you can create values without writing \verb|new|:

\begin{scalacode}
val pt = Point(1, 2)
\end{scalacode}

Second, case classes have an automatically generated \verb|toString| method that
prints the fields:

\begin{verbatim}
scala> pt
pt: Point = Point(1.0,2.0)
\end{verbatim}

Third, all fields are public by default, so you can easily write simple
functions, such as the this one, without writing getters:

\begin{scalacode}
def magnitude(pt: Point) : Double = {
  math.sqrt(pt.x * pt.x + pt.y * pt.y)
}

test("3-4-5 triangles") {
  assert(magnitude(Point(3, 4)) == 5)
}
\end{scalacode}

\section{Sealed Case Classes\classtime{20}}

Imagine you're a new age librarian, tasked with cataloging information on the
Internet. There are many types of information. Here are some significant ones:

\begin{scalacode}
case class Tweet(user: String, number: Long)
case class Xkcd(number: Int)
case class HackerNews(item: Int, points: Int)
\end{scalacode}

Here are some examples:

\begin{scalacode}
// https://twitter.com/PLT_Borat/status/248038616654299136
val tweet = Tweet("PLT_Borat", 248038616654299136L)
// http://xkcd.com/1316/
val comic = Xkcd(1316)
// https://news.ycombinator.com/item?id=8169367
val news = HackerNews(8169367, 305)
\end{scalacode}

Let's write a function called \verb|getURL| that maps these items to their URLs,
which is easy to do with pattern matching.

\begin{scalacode}
def getURL(item: Any): String = item match {
  case Tweet(user, number) => "https://twitter.com/" + user + "/status/" + number
  case Xkcd(number) => "http://xkcd.com/" + number
  case HackerNews(item, _) => "http://news.ycombinator.com/item?id=" + item
  case _ => sys.error("not a library item")
}
\end{scalacode}

This definition is unsatisfactory. \verb|getURL| takes values of \verb|Any|
type. So, it is really easy to get a runtime error:

\begin{console}
scala> getURL("hello")
java.lang.RuntimeException: not a library item
 at scala.sys.package$.error(package.scala:27)
  at cmpsci220.package$$anonfun$1.apply(package.scala:13)
  at cmpsci220.package$$anonfun$1.apply(package.scala:13)
  at .getURL(<console>:38)
  ... 33 elided
\end{console}

To eliminate this kind of error, we need an \verb|Item| type:

\begin{scalacode}
sealed trait Item
case class Tweet(user: String, number: Long) extends Item
case class Xkcd(number: Int) extends Item
case class HackerNews(item: Int, points: Int) extends Item
\end{scalacode}

A \emph{trait} in Scala is like an \emph{interface}. They're also much more
versatile than interfaces, but we'll get into that later.

Now, we can rewrite \verb|getURL|, restricting argument type:

\begin{scalacode}
def getURL(item: Item): String = item match {
  case Tweet(user, number) => "https://twitter.com/" + user + "/status/" + number
  case Xkcd(number) => "http://xkcd.com/" + number
  case HackerNews(item, _) => "http://news.ycombinator.com/item?id=" + item
}
\end{scalacode}

This time, applying \verb|getURL| to a non-item produces a type error as expected:

\begin{console}
scala> item("hello")
<console>:43: error: type mismatch;
 found   : String("hello")
 required: Item
              getURL("hello")
\end{console}

A really nice feature of `match` is that it checks to ensure you've handled all
cases. For example, suppose we forgot to write the HackerNews case. Scala
prints the following error:

\begin{console}
<console>:18: warning: match may not be exhaustive.
It would fail on the following input: HackerNews(_, _)
       def getURL(item: Item): String = item match {
                                        ^
error: No warnings can be incurred under -Xfatal-warnings.
\end{console}

\paragraph{More Pattern Matching}

You can use `match` to also match concrete values. For example, here is
variant of getURL that censors a particular tweet from PLT Borat:

\begin{scalacode}
def getURL(item: Item): String = item match {
  case Tweet("PLT_Borat", 301113983723794432L) => "http://disney.com"
  case Tweet(user, number) => "https://twitter.com/" + user + "/status/" + number
  case Xkcd(number) => "http://xkcd.com/" + number
  case HackerNews(item, _) => "http://news.ycombinator.com/item?id=" + item
}
\end{scalacode}

Imagine you'd added the censoring line, but accidentally removed the line
that handles all other Tweets. Again, Scala will catch the error:

\begin{console}
<console>:62: warning: match may not be exhaustive.
It would fail on the following inputs:
  Tweet("PLT_Borat", (x: Long forSome x not in 301113983723794432L)),
  Tweet((x: String forSome x not in "PLT_Borat"), 301113983723794432L),
  Tweet((x: String forSome x not in "PLT_Borat"), _),
  Tweet(_, (x: Long forSome x not in 301113983723794432L))
       def getURL(item: Item): String = item match {
                                        ^
error: No warnings can be incurred under -Xfatal-warnings.
\end{console}

It is a long error message. But, if you read it carefully, you'll see that it is
very precisely describing exactly the cases that are missing.

\section{Additional Examples\classtime{30}}

[FILL]

\newdiscussion{Homework 1 Help Session (Jan 27)}


\newlecture

\section{Generics and Type Inference\classtime{15}}

\begin{itemize}

\item Students should know generics, so just show the notation for defining
functions:
%
\begin{verbatim}
def length[A](lst: List[A]): Int = lst match {
  case Nil => 0
  case _ :: rest => 1 + length(rest)
}

def reverseHelper[A](lst: List[A], reversed: List[A]): List[A] = lst match {
  case Nil => reversed
  case head :: tail => reverse(tail, head :: reversed)
}
def reverse[A](lst: List[A]): List[A] = reverseHelper(lst, Nil)
\end{verbatim}


\item Discuss type inference: \verb|List[Int](1,2,3)| is the same as
\verb|List(1, 2, 3)|. Scala figures out the type.

\item Show an example of a nested list and discuss type inference.

\item \emph{Scala Pitfall:} \verb|List(1, "2", 3)| has type \verb|List[Any]|,
but it's almost certainly not what you had in mind!
\verb|List[Int](1, "2", 3)| does not type-check.

\item \emph{Preach:} Type inference is not magic. It saves you typing, but
don't expect it to figure out exactly what you mean. It can make mistakes.
Ensure you know what type expressions have. You'll learn how to do this
with practice.

\end{itemize}

\section{Higher-Order Functions on Lists}

[FILL] Introductory stuff


\begin{figure}
\begin{subfigure}[b]{.45\textwidth}
\begin{scalacode}
def incrs(lst: List[Int]): List[Int] =
  lst match {
    case Nil => Nil
    case h :: t => h + 1 :: incrs(t)
  }
\end{scalacode}
\caption{A function that increments all numbers in a list.}
\end{subfigure}
\hskip 2em
\begin{subfigure}[b]{.45\textwidth}
\begin{scalacode}
def lengths(lst: List[String]): List[Int] =
  lst match {
  case Nil => Nil
  case h :: t => h.length :: lengths(t)
}
\end{scalacode}
\caption{A function that calculates the lengths of all strings in a list.}
\end{subfigure}

\vskip 2em

\begin{subfigure}[b]{.45\textwidth}
\begin{scalacode}
def doubles(lst: List[Int]): List[Int] =
  lst match {
    case Nil => Nil
    case h :: t => h * 2 :: doubles(t)
}
\end{scalacode}
\caption{A function that doubles all numbers in a list.}
\end{subfigure}
\hskip 2em
\begin{subfigure}[b]{.45\textwidth}
\begin{scalacode}
def negates(lst: List[Int]): List[Int] =
  lst match {
    case Nil => Nil
    case h :: t => -h :: negates(t)
}
\end{scalacode}
\caption{A function that negates all numbers in a list.}
\end{subfigure}

\caption{Four different functions that transform elements of a list.}
\label{map_motivation}
\end{figure}


\subsection{The Map Function\classtime{15}}

Study the four functions in \cref{map_motivation}. The function \verb|incrs|
adds one to every element in a list of integers, the function \verb|lengths|
calculates the length of every string in a list, the function \verb|doubles|
doubles every number in a list, and the function \verb|negates| negates every
number in a list. Hopefully, you've noticed that these four functions have a lot
of in common. \emph{The only difference between them is the operation that they
perform on the head of the list}.

Here is a variant of \verb|doubles| that makes the operation explicit, by
moving it into a separate function:
%
\begin{scalacode}
def f(n: Int): Int = n * 2

def doubles(lst: List[Int]): List[Int] = lst match {
  case Nil => Nil
  case h :: t => f(h) :: doubles(t)
}
\end{scalacode}

In this version, we're simply applying a function $f$ to $h$, where $f$
is the doubling function. \emph{You should apply the same refactoring to the other
functions}. E.g.,  instead of directly writing \verb|head.length|, refactor
the function so that this expression is in a helper function.

Once we've re-written the operation as \scalainline{f(h)}, all three
functions look identical: the only different that that each refers to a
different function.
Instead of writing three functions that are almost identical, we can
write one function that takes $f$ as an argument:

\begin{scalacode}
def map(f: Int => Int, lst: List[Int]): List[Int] = lst match {
  case Nil => Nil
  case h :: t => f(h) :: map(f, t)
}
\end{scalacode}

With this function, we can make our examples much more succinct:

\begin{scalacode}
def doubles(lst: List[Int]) = {
  def f(n: Int): Int = n * 2
  map(f, lst)
}

def incrs(lst: List[Int]) = {
  def f(n: Int): Int = n + 1
  map(f, lst)
}

def lengths(lst: List[String]) = {
  def f(str: String): Int = str.length
  map(f, lst)
}
\end{scalacode}

Unfortunately, the definition of \scalainline{lengths} above does not type-
check. Scala reports two type errors and they are both very informative:

\begin{console}
<console>:15: error: type mismatch;
 found   : String => Int
 required: Int => Int
         map(f, lst)
             ^
<console>:15: error: type mismatch;
 found   : List[String]
 required: List[Int]
         map(f, lst)
                  ^
\end{console}

The \scalainline{map} function only works of lists of integers. However, if you
look at the definition of \scalainline{map} closely, you'll see that all the
\scalainline{Int}-specific code has been factored out into \scalainline{f}. We
can make the function even more generic by introducing two type-parameters:

\begin{scalacode}
def map[A,B](f: A => B, lst: List[A]): List[B] = lst match {
  case Nil => Nil
  case h :: t => f(h) :: map[A, B](f, t)
}
\end{scalacode}

The type-parameter $A$ is the type of the elements in
\emph{lst} and the type-parameter $B$ is the type elements in the produced list.
In the code above, we've make all the type-arguments explicit. But, as we've
discussed before, we can rely on type-inference to fill them in:

\begin{scalacode}
def map[A,B](f: A => B, lst: List[A]): List[B] = lst match {
  case Nil => Nil
  case h :: t => f(h) :: map(f, t)
}
\end{scalacode}

\subsection{The Filter Function\classtime{10}}

Another common pattern when programming with lists is to select certain elements
that have some property. For example, here is a function that consumes a list,
and produces a new list that only contains the even numbers:

\begin{scalacode}
def filterEven(lst: List[Int]): List[Int] = lst match {
  case Empty() => Empty()
  case Cons(head, tail) =>
    (head % 2 == 0) match {
      case true => Cons(head, filterEven(tail))
      case false => filterEven(tail)
    }
}
\end{scalacode}

This is a very common pattern too. For example, we could write a function to
select the odd numbers or the prime numbers. If we had a list of strings, we
could select all the strings with length 5 or all the strings that represent
English-language words. All these functions have the same shape: they test
the value of `head` in some way. If the test succeeds, `head` is added in
the output list. But, if the test fails, it is excluded.

Following the same strategy we used to derive `map`, we first package
the `head`-test into a function:

\begin{scalacode}
def f(n: Int): Boolean = head % 2

def filterEven(lst: List[Int]): List[Int] = lst match {
  case Empty() => Empty()
  case Cons(head, tail) =>
    f(head) match {
      case true => Cons(head, filterEven(tail))
      case false => filterEven(tail)
    }
}
\end{scalacode}

Now that the pattern is clearer, we generalize `filterEven` to take `f`
as an argument:

\begin{scalacode}
def filter(f: Int => Boolean, lst: List[Int]): List[Int] = lst match {
  case Empty() => Empty()
  case Cons(head, tail) =>
    f(head) match {
      case true => Cons(head, filter(f, tail))
      case false => filter(f, tail)
    }
}

def filterEven(lst: List[Int]): List[Int] = {
  def f(n: Int): Boolean = head % 2
  filter(f, lst)
\end{scalacode}

Finally, just as we did for `map`, we can generalize the type of `filter`
so that it can be applied to `List[A]`:

\begin{scalacode}
def filter[A](f: A => Boolean, lst: List[Int]): List[A] = lst match {
  case Empty() => Empty()
  case Cons(head, tail) =>
    f(head) match {
      case true => Cons(head, filter(f, tail))
      case false => filter(f, tail)
    }
}
\end{scalacode}

\subsection{The Find Function\classtime{10}}

Another common operation on lists is to find an element. For example,
the following function finds the first even number in a list:

\begin{scalacode}
def findEven(lst: List[Int]): Option[Int] = lst match {
  case Empty() => None()
  case Cons(head, tail) => (head % 2 == 0) match {
    case true => Some(head)
    case false => findEven(tail)
  }
}
\end{scalacode}

If we change `(head % 2 == 0)` to `(head % 2 == 1)`, we'll have the
`findOdd` function. Again, instead of defining two slightly different
functions, we can write the general `find` function:

\begin{scalacode}
def find[A](f: A => Boolean, lst: List[A]): Option[A] = lst match {
  case Empty() => None()
  case Cons(head, tail) => f(head) match {
    case true => Some(head)
    case false => find(f, tail)
  }
}
\end{scalacode}


\subsection{Discovering New Higher-Order Functions\classtime{10}}

[FILL]

- A generic sort function
- TakeWhile

\section{Builtin Methods on Lists\classtime{5}}

\section{Method Chaining\classtime{5}}

\chapter{Homework 2: Higher-Order Functions}

\section{New higher-order functions for list processing}
\section{Method chaining using Scala API}

\newlecture

\section{Functions are Values}

We've seen that functions in Scala can appear in almost any place. For example,
we've seen nested functions:

\begin{scalacode}
def doubleAll(lst: List[Int]) = {
  def f(n: Int): Int = n * 2
  map(f, lst)
}
\end{scalacode}

We've seen functions that take other functions as arguments, such as `map`:

\begin{scalacode}
def map[A,B](f: A => B, lst: List[A]): List[B] = lst match {
  case Empty() => Empty[B]()
  case Cons(head, tail) => Cons[B](f(head), map[A,B](f, tail))
}
\end{scalacode}

And, we've even see that functions can produce other functions:

\begin{scalacode}
def compose[A,B,C](f: A => B, g: B => C) : A => C = {
  def h(a: A): C = { g(f(a)) }
  h
}
\end{scalacode}

Here is an even simpler example of a function that produces another function:

\begin{scalacode}
def makeAdder(x: Int): Int => Int = {
  def addX(y: Int): Int = x + y
  addX(x)
}

val addThree = makeAdder(3)
test("add3 test") {
  assert(addThree(10) == 13)
}
\end{scalacode}

Functions can even be stored in data structures. For example, consider
this simple, recursive evaluator for arithmetic expressions:

\begin{scalacode}
sealed trait Expr
case class Num(n: Int) extends Expr
case class Add(e1: Expr, e2: Expr) extends Expr
case class Mul(e1: Expr, e2: Expr) extends Expr

def eval(e: Expr): Expr = e match {
  case Num(n) => n
  case Add(e1, e2) => eval(e1) + eval(e2)
  case Mul(e1, e2) => eval(e1) * eval(e2)
}
\end{scalacode}

Imagine extending this evaluator to support subtraction, division, etc.
We could do so by adding more cases to `Expr` and adding corresponding
lines to `eval`. But, this will quickly become tedious and repetitive.

But, since we can store functions in data structures, we can replace
`Add`, `Mul`, `Div`, `Sub`, `Exp`, and all other binary operators with
a single constructor for binary arithmetic expressions:

\begin{scalacode}
sealed trait Expr
case class Num(n: Int) extends Expr
case class BinOp(op: (Int, Int) => Int, e1: Expr, e2: Expr) extends Expr

def eval(e: Expr): Expr = e match {
  case Num(n) => n
  case BinOp(op, e1, e2) => op(eval(e1), eval(e2))
}
\end{scalacode}

With these definitions, we can represent any binary arithmetic expression
we please:

\begin{scalacode}
def sub(x: Int, y: Int): Int = x - y

test("subtraction test") {
  assert(eval(BinOp(sub, 10, 3)) == 7)
}
\end{scalacode}

\subsection{Anonymous Functions}

In Scala, \emph{functions are values}, just like integers, strings, or any user-
defined type. They can truly appear in all the contexts in which other values
appear: as arguments, as results, as fields in a data-structure, and so on.

Unlike other values, functions seem to have the following special property:
every function has a name, but the other kinds of values do not.
For example, we can simply write `Cons(1, Cons(2, Cons(3, Empty())))`
and don't need to give this list a name. But, all functions
start with `def functionName`.

But, this is just convenience and a convention. Just like other values,
functions don't need names. For example, here is a function that adds two
numbers:

\begin{scalacode}
((x: Int, y: Int) => x + y)
\end{scalacode}

This function does not have a name, but it can be applied just like
any other function:

\begin{scalacode}
((x: Int, y: Int) => x + y)(10, 20)
\end{scalacode}

The code above is not easy to read. It will be a lot clearer of we give the
function a name. You already know how to name a function using `def`. But, all
other values are named using `val`. In fact, we can use `val` to name functions
too, just like any other type of value:

\begin{scalacode}
val adder = ((x: Int, y: Int) => x + y)

adder(10, 20)
\end{scalacode}

You should think of `def` as a convenient shorthand for naming functions.
That is, these two definitions are equivalent:

\begin{scalacode}
val adder = ((x: Int, y: Int) => x + y)

def adder(x: Int, y: Int) = x + y
\end{scalacode}

In general, it is a good idea to name your functions. But, there are
certain situations where a short, anonymous function can made your code
easier to read and write.

For example, we earlier defined the `doubleAll` function, which doubles
every number in a list of numbers. Here is simple, one-line definition
using an anonymous function as an argument to `map`:

\begin{scalacode}
def doubleAll(lst: List[Int]) = map((n: Int) => n * 2, lst)
\end{scalacode}

The anonymous function itself is extremely simple and the name of the enclosing
function, `doubleAll`, really makes it clear what it does.

For another example, suppose we want to remove all the odd numbers
in a list. We can do this using `filter` and a short, anonymous function:

\begin{scalacode}
def removeOdds(lst: List[Int]) = filter((n: Int) => n % 2 == 0, lst)
\end{scalacode}

In these kinds of situations, anonymous functions can be very helpful.

\subsection{Some Definitions}

Here are some terminology that gets thrown around when comparing programming
languages and programming techniques.

\begin{itemize}

  \item \emph{Higher-order functions} are functions that consume or return other
  functions   as values. You can tell if a function is higher-order by inspecting
  its type. Does it have any nested `=>`s in the type? If so, it is a higher-order
  function.

  But, what about the `eval` function we wrote above, which consumes `BinOp`s?
  Is that a higher-order function?

  \item \emph{First-class functions} is a property of a programming language. For
  a programming language to have first-class functions, it must treat functions
  as values, with all the rights and privileges that other values have. You must
  be able to use functions as arguments, produce functions as results, and store
  functions in data-structures.

\end{itemize}

\section{Evaluation by Substitution}

\newdiscussion{TODO -- Dan (Feb 3)}

\newlecture

\section{Trees, Pairs, and Other Containers}

\chapter{Homework 3: Modeling Data}

\section{Working with census data}

\newlecture

\section{Evaluating Expressions}

\section{Garbage collection}

\newlecture

\section{Exceptions and the Option type}

\newdiscussion{TODO -- ??? (Feb 10)}

\chapter{Homework 4: More Data Modelling}

\section{Working with more census data}

Use the option type

\newlecture

\newdiscussion{TODO -- Dan (Feb 17)}

\chapter{Homework 5: Type Checker and Evaluator}

\newlecture

\section{Type checking Scala}

\newlecture

\newdiscussion{TODO -- ??? (Feb 24)}

\chapter{Homework 6: Join Lists}

\newlecture

\newlecture

\newdiscussion{TODO -- Dan (Mar 2)}


\chapter{Homework  7: Graphs}

\newlecture

\newlecture

\newdiscussion{TODO -- Dan (Mar 9)}

\newlecture

\chapter{Homework 8: Tic Tac Toe}

\newlecture

\newdiscussion{TODO -- ??? (Mar 23)}

\newlecture

\newlecture

\newdiscussion{TODO -- Dan (Mar 30)}

\chapter{Homework 9: Sudoku}

\newlecture

\newlecture

\newdiscussion{TODO -- ??? (Apr 6)}

\chapter{Homework 10: Parsing}

\newlecture

\newlecture

\newdiscussion{TODO -- Dan (Apr 13)}

\chapter{Homework 11: ??}

\newlecture

\newlecture

\chapter{Homework 12: ??}

\newlecture

\newlecture

\newdiscussion{TODO -- Dan (Apr 27)}



\end{document}