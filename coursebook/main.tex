% !TEX root = student.tex
\documentclass[9pt]{extbook}
\usepackage{pervasives}

\title{COMPSCI220 Course Book}
\author{Arjun Guha and Rachit Nigam}

\begin{document}

\maketitle
\tableofcontents

\chapter{Acknowledgements}

[FILL]

- Dan Barowy for some discussions
- Typos etc. from Cassian Corey, Aaron Weiss, ... ?

This course could not have come together without materials and inspiration from
several sources.

Many lectures and reading materials are based on these texts:

How to Design Programs by Felleisen, Findler, Flatt, and Krishnamurthi

Pure Functional Data Structures by Okasaki

Programming in Scala by Oderksy, Spoon, and Venners

You should read these, even if you’ve taken this course.

For several assignments, we use a graphics library based on the one documented in this article: A Functional I/O System by Felleisen, Findler, Flatt, and Krishnamurthi.

Some of our assignments are adapted from other sources:

The Join Lists assignment from CS19 at Brown University by Krishnamurthi, et al

The Tic Tac Toe assignment is adapted from CMPSCI383 by Liberatore

The Sudoku assignment is adapted from Solving Every Sudoku Puzzle by Norvig

The Streams assignment is adapted from Micheal Clarkson.

Thanks to Joseph Collard and Nimish Gupta for debugging several assignments.


\chapter{Introduction: Scala, the command-line, and pattern-matching}
\savepdf{intro}

\section{Introduction\classtime{15}}

\emph{COMPSCI220 Programming Methodology} introduces advanced programming
techniques in the context of a modern programming language:
\href{http://www.scala-lang.org/}{Scala}.
You could use Scala to write exactly the same kind
of object-oriented code that you've seen in Java. In fact, Scala code and Java
code can seamlessly co-exist and interoperate in the same program; we'll
leverage this feature later in the course. In fact, many of the design patterns
that you will learn in this course will be applicable to Java and Scala.

However, a key reason we're using Scala is to expose you to programming techniques
and language features that are beyond the scope of Java. Most
modern software systems are written in a plethora of languages. In fact, large
systems tend to use several programming languages. Therefore, to succeed in your
computing career, you have to be familiar with several languages and be able to
learn new languages on your own. Programming
languages are constantly invented and abandoned\footnote{\href{http://www.oreillynet.com/pub/a/oreilly/news/languageposter_0504.html}{This poster} is a very incomplete history of the birth and death of programming languages.}
 and it is impossible to predict the next language that everyone
will use or the language you'll need to learn for your first job.

Scala is a big language with many unique features and we are not going to learn
to use them all. Instead, we are going to focus on ideas that Scala shares with
other modern programming languages. Here are some of the key ideas that we will
cover in this course that go beyond Java:
%
\begin{itemize}

\item \emph{First-class functions} are the cornerstone of \emph{functional programming}.
  They are pervasive in JavaScript, Ruby, Python, Swift, and almost all modern
  languages.
  In fact, even \href{{http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html}}{Java} and
  \href{https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp}{C++} recently
  added support for first-class functions.

\item \emph{Algebraic data types} are available in Apple Swift, Mozilla Rust,
  Microsoft F\#, and several other programming languages. Programming with
  algebraic data types is very different from programming in an object-oriented
  style. We'll cover both styles of programming in this course and develop
  a deep understanding of the tradeoffs.

\item \emph{Type inference} is available in modern typed programming languages,
  such as C\# and Swift, and even in a limited form in
  \href{http://docs.oracle.com/javase/tutorial/java/generics/genTypeInference.html}{Java}.
  As the name suggests, in a language with type inference, the compiler can
  often ``infer'' or fill-in types that you omit. So, your programs become shorter, but
  retain all the advantages of type checking.

\end{itemize}

The main themes of the course are not language-specific. We will emphasize
the following broad ideas that are applicable to all software development:
%
\begin{itemize}

\item \emph{Testing} is critical for building reliable software. You will learn how
  to test complex functions and make effective use of testing tools and frameworks.
  Every programming problem you solve in this course will have to be tested. We
  expect you to write good tests yourself. The quality of your tests will be a
  significant portion of your grade on every assignment.

\item \emph{Design patterns} are recipes for solving typical programming
  problems. This course will emphasize object-oriented and functional
  design patterns. We will focus on design patterns that are applicable to
  a variety of programming languages, and not Scala-specific design patterns.

\item \emph{Refactoring} is a key concept that we emphasize throughout the
  course. As we introduce new ideas, we will systematically refactor our old
  code to exploit them.

\item \emph{Debugging} is a necessary skill because even small programs often
  have bugs.

\item \emph{Command-line tools} such as compilers and build tools lie under the
  hood of sophisticated IDEs such as Eclipse. Learning to use the command-line
  will make you a better IDE user. Moreover, many newer languages lack good
  IDEs. Therefore, if you want to master the latest technologies, you will
  need to master the command-line.

% Seriously, we do not teach this.

% \item \emph{Version control} software is critical for collaborative software
%   development and used by all professional programmers. Although you will be
%   programming alone in the course, version control will still help you organize
%   your programming and save you a lot of time if you accidentally delete or
%   break your code.

\item \emph{Using libraries} is critical for writing software that gets real
  work done. Initially, you'll use libraries that were developed specifically
  for this course, but you will eventually learn to discover and use
  libraries from the Web.

\end{itemize}

The overarching goal of this course is to make you a better programmer,
and an important part of that is to get familiar with programming terminology
and culture. Unfortunately, there is a lot of misinformation on the Web
about programming, but we will try to point you to sources that are reliable.
Here are two good places to start:
%
\begin{itemize}

  \item \href{http://paulgraham.com/articles.html}{Paul Graham's Essays}.
  The earlier essays are particularly pertinent, E.g.,
  \href{http://paulgraham.com/avg.html}{Beating the Averages} and
  \href{http://paulgraham.com/popular.html}{Being Popular}.

  \item \href{http://www.joelonsoftware.com}{Joel Spolsky's blog}. E.g.,
  \href{http://www.joelonsoftware.com/articles/CollegeAdvice.html}
  {Advice for Computer Science College Students}
  and \href{http://www.joelonsoftware.com/articles/ResumeRead.html}
  {Getting Your Resume Read}.

\end{itemize}

Finally, \href{http://xkcd.com}{XKCD} comics often make obscure programming
references and this course will help you decipher some of them.

\section{The Command-Line\classtime{5}}

The \emph{\textsc{Unix} command-line}\footnote{The command-line is also known as a
\emph{terminal} or \emph{shell}.} is  a critical part of this course:

\begin{itemize}

\item If you're
using the course virtual-machine, you should use the program \textbf{LXTerminal}
to start the command-line.

\item If you're using macOS, you get to command line by running the
launching the \textbf{Terminal} application, which is in the
\textbf{Applications} $\blacktriangleright$ \textbf{Utilities} folder.

% \item If you're using Windows 10, you can use \textbf{Bash for Windows}.

% \item If you're using an earlier version of Windows, you can install and
% run \textbf{Cygwin}.

\end{itemize}

Unless you're already familiar with the command-line, you must read
\href{https://learnpythonthehardway.org/python3/appendixa.html}{Zed Shaw's Command Line Crash Course},
up to and including the chapter ``Removing a File (rm)''. Zed likes to swear at
his own readers, so we'd like to apologize in advance on his behalf. The rest
of these lecture notes assume that you are familiar with the command-line.

\section{\sbt{} and the Scala REPL\classtime{5}}

\sbt{} is the Swiss Army Knife of Scala programming. It is a command-line tool
that can be use to run Scala programs, compile them, test them, package them for
deployment, publish them to the Web, and more. Like many modern programming
languages, \sbt{} has a \emph{REPL} (read-eval-print loop), which you can use to
type in and run one-line programs immediately, without the bother of creating
files, etc.

To start the Scala REPL, open a terminal,
type in \verb|sbt console| and press enter. Your screen will look like this:
%
\consolefile{includes/sbtconsole.txt}

The \verb|scala>| prompt indicates that you can type in Scala expressions.

\section{Scala Basics\classtime{15}}

\subsection{Simple Expressions and Names}

Arithmetic in Scala is very similar to arithmetic in Java:

\lstset{language=console}
\begin{lstlisting}
scala> 19 * 17
res0: Int = 323
\end{lstlisting}

Strings in Scala will also look familiar:

\begin{lstlisting}
scala> "Hello, " + "world"
res1: String = Hello, world
\end{lstlisting}

Boolean expressions will be familiar too:

\begin{lstlisting}
scala> true && false
res2: Boolean = false
\end{lstlisting}

\lstset{language=scala}
Let's examine the last interaction more closely. When you type \lstinline|true && false|,
Scala prints three things:
%
\begin{itemize}
\item An automatically-generated \emph{name} (\lstinline|res2|),
\item The \emph{type} of the expression (\lstinline|Boolean|), and
\item The \emph{value} of the expression (\lstinline|false|).
\end{itemize}

On the Scala REPL, you can use the generated name as a variable. But, you're
better off picking meaningful names yourself using \lstinline|val|:
\lstset{language=console}
\begin{lstlisting}
scala> val mersenne = 524287
mersenne : Int = 524287
scala> val courseName = "Programming Methodology"
courseName : String = Programming Methodology
\end{lstlisting}

\subsection{Type Inference}

You'll find that Scala programs are significantly shorter than their Java
counterparts. A key feature of Scala that lets you write less code is \emph{type
inference}. Notice in the variable definitions above, you did not have to write
any types. Instead, Scala \emph{inferred} them for you. This feature is very helpful
in large programs, where types can become long and complicated.

Type inference is not magic; later in the course, you'll learn more about how it
works and when it doesn't. For now, here's a rule of thumb: Scala can infer the
type of variable named with \verb|val|. But, Scala \emph{cannot} infer the type of
function parameters.

\subsection{Functions}

Here is a very simple Scala function:

\begin{lstlisting}
scala> def twice(n: Int): Int = n + n
double: (n: Int)Int
\end{lstlisting}

\lstset{language=scala}
This code defines a function called \lstinline|twice|, which takes an argument
\lstinline|Int|. We can apply the function as follows:
called \lstinline|n| of type \lstinline|Int| and returns a value of type
\lstset{language=console}
\begin{lstlisting}
scala> twice(10)
res3: Int = 20
\end{lstlisting}
\lstset{language=scala}
The following function takes two arguments, \lstinline|x| and \lstinline|y| and calculates the
distance from the point \lstinline|(x,y)| to the origin:
\begin{lstlisting}
scala> def dist(x: Double, y: Double): Double = math.sqrt(x * x + y * y)
dist: (x: Double, y: Double)Double

scala> dist(3.0, 4.0)
res4: Double = 5.0
\end{lstlisting}

Notice that unlike variable definitions, we need \emph{type annotations}
on function parameters and result types.

If your function actually fits on a line (without scrolling off your window),
you can define them very tersely as shown above. But, many interesting
functions span several lines and need local variables.

\subsection{Blocks and Local Variables}

You can define local variables within a \emph{block}. A block is code delimited by
curly-braces. For example:

\begin{lstlisting}
scala> def dist2(x: Double, y: Double): Double = {
  val xSq = x * x
  val ySq = y * y
  math.sqrt(xSq + ySq)
}
\end{lstlisting}

\begin{figure}
\scalafile{code/Lecture1fac.scala}
\caption{A Scala module}
\label{lecture1code}
\end{figure}

\section{\sbt{} Project Structure\classtime{5}}
\lstset{language=console}
In principle, you can write a full-fledged program line-by-line in the Scala
console. But, it makes a lot more sense to save large programs to files
for a particular \emph{project}. To do so, we will being by creating a new directory
for your project. Every time you create a new Scala program (e.g., for a homework
assignment) you should create a new project.

First, exit the Scala console by typing \verb|:quit| and then exit \sbt{}
by typing \verb|exit|. You should return to the command-line:
%
\begin{lstlisting}
scala> :quit

[success] Total time: 3 s, completed Jan 13, 2016 8:47:38 PM

sbt> exit
student@vm:~$
\end{lstlisting}

At the terminal, let's create a directory for the project:
%
\begin{lstlisting}
student@vm:~$ mkdir lecture1
\end{lstlisting}
%
Then, let's enter the directory:
\begin{lstlisting}
student@vm:~$ cd lecture1
student@vm:~/lecture1$
\end{lstlisting}
Notice that the name of the directory is displayed on the command-line.

Your Scala projects will have two kinds of files: test cases and your implementation.
\sbt{} requires you to organize your files into the following directory
structure:

\begin{minipage}{0.5\textwidth}
\dirtree{%
.1 ~/lecture1.
.2 src.
.3 main.
.4 scala\DTcomment{Implementation goes here}.
.3 test.
.4 scala\DTcomment{Tests go here}.
}
\end{minipage}

You can create these directories by running the following commands:
\consolefile{includes/mkdirs.txt}

We will now see how to save Scala code to files. Using a text editor,
create a file called \verb|Lecture1.scala| in the
\verb|src/main/scala| directory, with the contents shown in \cref{lecture1code}.
The code creates an object with a single function to calculate factorials.

When you write functions in a Scala file, you \emph{have} to place it in
an object. You cannot just write \lstinline|def fac ...| without an enclosing
object. This is a peculiarity of Scala that we will explain later in the course.
In this example, the name of the object is ``Lecture1'', but it can be anything
you like.

\lstset{language=console}
Now that we've saved this function to a file, we can use it from the console:
%
\begin{lstlisting}
sbt> console
scala> import Lecture1._
scala> fac(10)
\end{lstlisting}

\begin{figure}
\lstset{language=scala}
\begin{lstlisting}
// src/main/scala/Lecture1Tests.scala
import Lecture1._

class Lecture1Tests extends org.scalatest.FunSuite {

  test("fac -- base case") {
    assert(fac(0) == 1)
  }

  test("fac -- inductive case") {
    assert(fac(5) == 120)
  }

}
\end{lstlisting}
\caption{Unit tests for the code in \cref{lecture1code}}
\label{lecture1tests}
\end{figure}

\section{Testing\classtime{5}}

The \sbt{} console is a convenient way to experiment with new code or write
a ``one off'' functionn. However, you must write \emph{unit tests} to test
any actual code you write. \Cref{lecture1tests} shows an example of
unit tests that use the \emph{ScalaTest} library. The code is quite self-explanatory:
each test suite is a class that extends \lstinline|org.scalatest.FunSuite|.
The body of the class has several test blocks, as shown in the figure.

\section{Building and Pattern-Matching on Lists\classtime{25}}
\lstset{language=scala}

In this section, we will show you how to write simple list-processing functions.
We will cover basic \emph{functional programming} and introduce \emph{pattern
matching}. You should try out all the code yourself using the \sbt{} console.

\subsection{Constructing Lists}

The simplest list is the empty list, which is written in Scala as
%
\begin{lstlisting}
Nil
\end{lstlisting}
%
Given the empty list, we can construct larger lists using the \lstinline|::|
operator (which is pronounced \emph{cons}). Here is a simple example that
constructs a one-element list:
%
\begin{lstlisting}
50 :: Nil
\end{lstlisting}
Given a one-element list, we can build a two-element list by using the
\lstinline|::| operator again:
%
\begin{lstlisting}
100 :: (50 :: Nil)
\end{lstlisting}
%
We can use \lstinline|::| again to build a three-element list:
%
\begin{lstlisting}
200 :: (100 :: (50 :: Nil))
\end{lstlisting}
%
In an expression \lstinline|x :: y|,
\lstinline|x| is known as the \emph{head} of the list and \lstinline|y| is
known as the \emph{tail}. Note that the tail of a list is always a list itself,
(though it may be the empty list \lstinline|Nil|).

For example, consider the list below:
\begin{lstlisting}
val letters = "a" :: ("b" :: Nil)
\end{lstlisting}
%
\begin{itemize}

  \item The head of \lstinline|letters| is \lstinline|"a"|.

  \item The tail of \lstinline|letters| is \lstinline|"b" :: Nil|.

  \item The head of the tail of \lstinline|letters| is \lstinline|"b"|.

  \item The tail of the tail of \lstinline|letters| is \lstinline|Nil|.

  \item \lstinline|Nil| does not have a head or a tail.

\end{itemize}

In our examples so far, we've used parenthesis to make the head and tail clear.
However, you can simply write \lstinline|"a" :: "b" :: "c" :: Nil|. Intuitively,
everything to the right of a \lstinline|::| is the tail. If you get confused, write the parenthesis explicitly.

It is usually easier to write lists in the following way:
%
\begin{itemize}

  \item \lstinline|List("a", "b", "c")| is equivalent to
  \lstinline|"a" :: ("b" :: ("c" :: Nil))|.

  \item \lstinline|List()| is equivalent to \lstinline|Nil|.

\end{itemize}
%
However, it is important to understand that this is just a convenient notation.
Under the hood, Scala transforms these expressions to use \lstinline|::|
and \lstinline|Nil|, as we described above.

\paragraph{Lists and Type Inference}
\lstset{language=console}
Consider the following interaction, which you should try yourself:
%
\begin{lstlisting}
scala> val lst = 1 :: 2 :: 3 :: Nil
lst: List[Int] = List(1, 2, 3)
\end{lstlisting}
%
\lstset{language=scala}

As you can see, Scala prints lists using the shorthand notation,
even if you explicitly use \lstinline|::| and \lstinline|Nil|.
More significantly, Scala has inferred that the type of the list
is \lstinline|List[Int]|. There was no need to explicitly state that
is is the case.

Here is another example, where Scala infers that the type of a list is
\lstinline|List[String]|:
%
\lstset{language=console}
\begin{lstlisting}
scala> val lst = List("a", "b", "c")
lst: List[String] = List("a", "b", "c")
\end{lstlisting}

\lstset{language=scala}
Type inference is very convenient and spares you from having to explicitly
specify the type of the element. However, type inference is not magic
and can behave in unexpected ways. For example, in the interaction
below, Scala infers that the type of the list is \lstinline|List[Any]|:
%
\lstset{language=console}
\begin{lstlisting}
scala> val lst = List("a", 10, "c")
lst: List[Any] = List("a", 10, "c")
\end{lstlisting}
Although this is technically true, if you write this code, it is more
likely that you made a mistake and intended to actually create a list of
strings. If you're ever unsure, you can write the type explicitly, which
would signal a type error in this case:
\begin{lstlisting}
scala> val lst = List[String]("a", 10, "c")
<console>:10: error: type mismatch;
 found   : Int(10)
 required: String
       val lst = List[String]("a", 10, "c")
                                   ^
\end{lstlisting}

\begin{figure}
\lstset{language=scala}
\begin{subfigure}[b]{0.45\textwidth}
\begin{lstlisting}
def countDown(n: Int): List[Int] = {
  if (n == 0) {
    Nil
  }
  else {
    n :: countDown(n - 1)
  }
}
\end{lstlisting}
\caption{}
\label{countDown}
\end{subfigure}
\hskip 2em
\begin{subfigure}[b]{0.45\textwidth}
\begin{lstlisting}
def fromTo(lo: Int, hi: Int): List[Int] = {
  if (lo == hi) {
    lo :: Nil
  }
  else {
    lo :: fromTo(lo + 1, hi)
  }
}
\end{lstlisting}
\caption{}
\label{fromTo}
\end{subfigure}

\caption{Functions that produce lists.}
\label{listcons}
\end{figure}

\paragraph{Functions that produce lists}

Now that we've seen how to construct lists explicitly, it is straightforward
to write functions that produce lists. \Cref{listcons} shows some simple
recursive functions that construct new lists.

\begin{figure}
\begin{subfigure}[b]{0.45\textwidth}
\begin{lstlisting}
def product(alist: List[Int]): Int = {
  alist match {
    case Nil => 1
    case n :: tail => n * product(tail)
  }
}
\end{lstlisting}
\caption{Calculate the product of a list of numbers.}
\end{subfigure}
\hskip 2em
\begin{subfigure}[b]{0.45\textwidth}
\begin{lstlisting}
def repeatTwice(alist: List[Int]): List[Int] = {
  alist match {
    case Nil => Nil
    case n :: tail => n :: n :: repeatTwice(tail)
  }
}
\end{lstlisting}
\caption{Repeats every element of a list twice.}
\end{subfigure}

\caption{Two simple functions that consume lists.}
\label{listconsumers}
\end{figure}


\subsection{Pattern Matching}

Now that we've seen how to write functions that produce lists, we'll
learn how to write functions that consume lists as arguments. We'll
start by writing a simple function to calculate the sum of a list of numbers.
Here are some examples of of \lstinline|sum| being used:
%
\begin{lstlisting}
assert(sum(20 :: 30 :: Nil) == 50)
assert(sum(1 :: 2 :: 3 :: Nil) == 6)
\end{lstlisting}

Intuitively, to calculate \lstinline|sum(1 :: 2 :: 3 :: Nil)|, we can
can recursively calculate the sum of the tail and add that value to the
head:
\begin{lstlisting}
   sum(1 :: 2 :: 3 :: Nil)
== 1 + sum(2 :: 3 :: Nil)
== 1 + (2 + sum(3 :: Nil))
== 1 + (2 + (3 + sum(Nil)))
\end{lstlisting}
%
The last line shows an important special case. Since the empty list
doesn't have a head or a tail, we need to treat it differently. We'll say
that \lstinline|sum(Nil)| is \lstinline|0|.

We can write \lstinline|sum| by using a powerful feature of
Scala called \emph{pattern matching}.
%
\begin{lstlisting}
def sum(lst: List[Int]): Int = alist match {
  case Nil => 0
  case h :: t => h + sum(t)
}
\end{lstlisting}
%
This code makes it clear that the function is inspecting \lstinline|alist|
and considering two \emph{cases}. When \lstinline|alist| is \lstinline|Nil|,
it produces \lstinline|0| and when \lstinline{alist} is constructed with
the \lstinline|::| operator, the function recurs on the tail and ands
that result to the head. In this code,
\lstinline|Nil| and \lstinline|h :: t| are called \emph{patterns}.

\Cref{listconsumers} shows two more list-consuming functions that
use pattern-matching. Notice that in \lstinline|::| cases, these functions
use different variable names for the head and the tail. A pattern can use
any variable to refer to the value of the head or the tail.

\begin{figure}
\begin{subfigure}[b]{0.45\textwidth}
\lstset{language=scala}\begin{lstlisting}
def countOnes(alist: List[Int]): Int = {
  alist match {
    case Nil => 0
    case n :: tail => {
      if (n == 1) {
        1 + countOnes(tail)
      }
      else {
        countOnes(tail)
      }
    }
  }
}
\end{lstlisting}
\caption{Counting ones using an if-expression.}
\label{countonescomplex}
\end{subfigure}
\hskip 2em
\begin{subfigure}[b]{0.45\textwidth}
\lstset{language=scala}\begin{lstlisting}
def countOnes(alist: List[Int]): Int = alist match {
  case Nil => 0
  case 1 :: tail => 1 + countOnes(tail)
  case n :: tail => countOnes(tail)
}
\end{lstlisting}
\caption{Counting ones using a composite pattern.}
\label{countonessimple}
\end{subfigure}

\caption{Pattern matching can make complex conditionals clearer.}
\end{figure}

\paragraph{Complex Patterns}
%
Pattern-matching is extremely powerful and can be used to express
complex conditionals. For example, \cref{countonescomplex} is a function
that counts the number of \lstinline|1|s that occur in a list: it uses
pattern matching as introduced above and then an if-expression to
check if the head of the list is \lstinline|1|.

\Cref{countonessimple}
is the same function, rewritten to use pattern matching. This version is shorter
and makes it clear that there are three cases. To do so, we exploit the fact
that patterns can match \emph{almost} any value, including numbers,
strings, lists, and user-defined data structures too (which we will see
in a later class).

\paragraph{Exhaustivity and Reachability Checking}
%
Here is another function that uses pattern matching to count the number
of tens in a list:
%
\lstset{language=scala}\begin{lstlisting}
def countTens(alist: List[Int]): Int = alist match {
  case 10 :: tail => 1 + countTens(tail)
  case n :: tail => countTens(tail)
}
\end{lstlisting}

However, this function had a bug. Do you see it? If you type this into
the console, Scala prints the following:
%
\lstset{language=console}\begin{lstlisting}
<console>:10: warning: match may not be exhaustive.
It would fail on the following input: Nil
       def countTens(alist: List[Int]): Int = alist match {
                                            ^
\end{lstlisting}
%
Scala has detected that we forgot to write a case for \lstinline|Nil|.
Scala ensures that your patterns are \emph{exhaustive}. Here is another
buggy version of the function:
%
\lstset{language=scala}\begin{lstlisting}
def countTens(alist: List[Int]): Int = alist match {
  case n :: tail => 1 + countTens(tail)
  case n :: tail => countTens(tail)
  case Nil => 0
}
\end{lstlisting}
%
In this version, we wrote the patterns incorrectly, so the first and second
patterns are identical. Scala reports the following error:
\lstset{language=scala}\begin{lstlisting}
<console>:13: warning: unreachable code
         case n :: rest => countTens(rest)
\end{lstlisting}
%
Scala ensures that all cases are \emph{reachable}.

This automatic exhaustivity and reachability checking makes programs that
use pattern-matching much more robust than programs that use complicated,
nested if-statements. Pattern matching is a very powerful tool that you can
exploit to make your programs more robust. We will emphasize pattern-matching
over conditionals in this course.

\section{Immutability \classtime{10}}

We want to emphasize that all the functions we've written to produce
lists \emph{produce a new list} and leave the original list unchanged.

You can observe this behavior in the Scala console:
%
\lstset{language=console}\begin{lstlisting}
scala> val original = List(10, 20, 30)
original: List[Int] = List(10, 20, 30)

scala> val result = repeatTwice(original)
result: List[Int] = List(10, 10, 20, 20, 30, 30)

scala> original
res0: List[Int] = List(10, 20, 30)

scala> result
res1: List[Int] = List(10, 10, 20, 20, 30, 30)
\end{lstlisting}

At no point did we change or \emph{mutate} the original list. In fact, lists in
Scala are \emph{immutable} data structures. There is no way to update their
head or tail. Programming with immutable data structures is a key part of
\emph{functional programming}, which we will emphasize in the first half
of this course.

\chapter{Pattern Matching and Testing}
\savepdf{pattern-matching}

\lstset{language=scala}

\begin{figure}
\begin{subfigure}[b]{.45\textwidth}
\begin{javacode}
public class Point {

  double x;
  double y;

  public Point(double x, double y) {
    this.x = x;
    this.y = y;
  }

}

Point pt = new Point(1, 2)
\end{javacode}
\caption{A Java class that represents a point.}\label{javapoint}
\end{subfigure}
\quad\vrule\quad
%
\begin{subfigure}[b]{.45\textwidth}
\begin{scalacode}
class Point(x : Double, y : Double)
val pt = new Point(1, 2)
\end{scalacode}
\caption{A Scala class that represents a point.}\label{scalapoint}
\end{subfigure}
\caption{Scala code is usually much shorter and simpler than Java code.}
\end{figure}

\section{Case Classes\classtime{10}}

Scala classes tend to be shorter than their
Java counterparts. For example, \cref{javapoint} shows a \scalainline{Point} class
in Java and \cref{scalapoint} shows the equivalent class in Scala, which
is much shorter!
If we start adding methods, you'll have to write
more code in Scala too. But, simple classes tend to be very short.
But, we are not going to use classes yet. Instead, we are going to use
\emph{case classes}, which are unique to Scala.

If you write \scalainline{case class}---
%
\begin{scalacode}
case class Point(x: Double, y: Double)
\end{scalacode}
---instead of just \scalainline{class}, you get several conveniences.
First, you can create values without writing \scalainline{new}:
%
\begin{scalacode}
val pt = Point(1, 2)
\end{scalacode}
%
Second, case classes have an automatically generated \scalainline{toString}
method that prints the fields:
%
\begin{console}
scala> pt
pt: Point = Point(1.0,2.0)
\end{console}
%
Finally, all fields are public by default, so you can easily write simple
functions, such as this one, without writing getters:
%
\begin{scalacode}
def magnitude(pt: Point) : Double = {
  math.sqrt(pt.x * pt.x + pt.y * pt.y)
}

test("3-4-5 triangles") {
  assert(magnitude(Point(3, 4)) == 5)
}
\end{scalacode}

\section{Sealed Case Classes\classtime{20}}

Imagine you're a new age librarian, tasked with cataloging information on the
Internet. There are many types of information. Here are some significant ones:

\begin{scalacode}
case class Tweet(user: String, number: Long)
case class Xkcd(number: Int)
case class HackerNews(item: Int, points: Int)
\end{scalacode}

Here are some examples:

\begin{scalacode}
// https://twitter.com/PLT_Borat/status/248038616654299136
val tweet = Tweet("PLT_Borat", 248038616654299136L)
// http://xkcd.com/1316/
val comic = Xkcd(1316)
// https://news.ycombinator.com/item?id=8169367
val news = HackerNews(8169367, 305)
\end{scalacode}

Let's write a function called \verb|getURL| that maps these items to their URLs,
which is easy to do with pattern matching.

\begin{scalacode}
def getURL(item: Any): String = item match {
  case Tweet(user, number) => "https://twitter.com/" + user + "/status/" + number
  case Xkcd(number) => "http://xkcd.com/" + number
  case HackerNews(item, _) => "http://news.ycombinator.com/item?id=" + item
  case _ => sys.error("not a library item")
}
\end{scalacode}

This definition is unsatisfactory. \verb|getURL| takes values of
\verb|Any|
type. So, it is really easy to get a runtime error:
\consolefile{includes/runtime-match-error.txt}

To eliminate this kind of error, we need an \verb|Item| type:

\begin{scalacode}
sealed trait Item
case class Tweet(user: String, number: Long) extends Item
case class Xkcd(number: Int) extends Item
case class HackerNews(item: Int, points: Int) extends Item
\end{scalacode}

A \emph{trait} in Scala is like an \emph{interface}. They're also much more
versatile than interfaces, but we'll get into that later.

Now, we can rewrite \verb|getURL|, restricting the argument type:

\begin{scalacode}
def getURL(item: Item): String = item match {
  case Tweet(user, number) => "https://twitter.com/" + user + "/status/" + number
  case Xkcd(number) => "http://xkcd.com/" + number
  case HackerNews(item, _) => "http://news.ycombinator.com/item?id=" + item
}
\end{scalacode}

This time, applying \verb|getURL| to a non-item produces a type error as expected:

\begin{console}
scala> item("hello")
<console>:43: error: type mismatch;
 found   : String("hello")
 required: Item
              getURL("hello")
\end{console}

A really nice feature of \scalainline{match} is that it checks to ensure you've handled all
cases. For example, suppose we forgot to write the HackerNews case. Scala
prints the following error:

\begin{console}
<console>:18: warning: match may not be exhaustive.
It would fail on the following input: HackerNews(_, _)
       def getURL(item: Item): String = item match {
                                        ^
error: No warnings can be incurred under -Xfatal-warnings.
\end{console}

\paragraph{More Pattern Matching}

You can use \scalainline{match} to also match concrete values. For example, here is
variant of getURL that censors a particular tweet from PLT Borat:

\begin{scalacode}
def getURL(item: Item): String = item match {
  case Tweet("PLT_Borat", 301113983723794432L) => "http://disney.com"
  case Tweet(user, number) => "https://twitter.com/" + user + "/status/" + number
  case Xkcd(number) => "http://xkcd.com/" + number
  case HackerNews(item, _) => "http://news.ycombinator.com/item?id=" + item
}
\end{scalacode}

Imagine you'd added the censoring line, but accidentally removed the line
that handles all other Tweets. Again, Scala will catch the error:

\begin{console}
<console>:62: warning: match may not be exhaustive.
It would fail on the following inputs:
  Tweet("PLT_Borat", (x: Long forSome x not in 301113983723794432L)),
  Tweet((x: String forSome x not in "PLT_Borat"), 301113983723794432L),
  Tweet((x: String forSome x not in "PLT_Borat"), _),
  Tweet(_, (x: Long forSome x not in 301113983723794432L))
       def getURL(item: Item): String = item match {
                                        ^
error: No warnings can be incurred under -Xfatal-warnings.
\end{console}

It is a long error message. But, if you read it carefully, you'll see that it is
very precisely describing exactly the cases that are missing.

\section{Binary Search Trees\classtime{20}}

\begin{figure}
\begin{scalacode}
sealed trait SBinTree
case class SNode(lhs: BinTree, key: Int, value: String, rhs: BinTree) extends SBinTree
case class SLeaf() extends SBinTree

def find(k: Int, t: SBinTree): String = t match {
  case SLeaf() => sys.error("not found")
  case SNode(_, key, value, _) if (k == key) => value
  case SNode(lhs, key, _, _) if (k < key) => find(k, lhs)
  case SNode(_, key, _, rhs) => find(k, rhs)
}

def insert(k: Int, v: String, t: SBinTree): SBinTree = t match {
  case SLeaf() => SNode(SLeaf(), k, v, SLeaf())
  case SNode(lhs, key, _, rhs) if (k == key) => SNode(lhs, key, v, rhs)
  case SNode(lhs, key, value, rhs) if (k <= key) =>  SNode(insert(k, v, lhs), key, value, rhs)
  case SNode(lhs, key, value, rhs) => SNode(lhs, key, value, insert(k, v, rhs))
}

def size(t: BinTree): SBinTree = t match {
  case SLeaf() => 1
  case SNode(lhs, k, v, rhs) => size(lhs) + size(rhs) + 1
}
\end{scalacode}

\caption{Binary search trees.}
\label{bintree}
\end{figure}

\Cref{bintree} shows a type definition for binary search trees, where
keys are integers and values are strings (which is why we call them
\scalainline{SBinTree}s). There are two
kinds of binary trees: (1) empty trees, or \scalainline{SLeaf()}s, and (2)
non-empty trees, or \scalainline{SNode(..)}s, which have a left-subtree,
a numeric key, a string value, and a right-subtree.
Given this definition, we can write canonical functions such
as \scalainline{size}, \scalainline{find}, and \scalainline{insert},
as shown in the same figure.
We emphasize that the \scalainline{insert} function does not modify the
original tree, and instead produces a new binary tree with the element added.


\subsection{Testing}

There is a lot of code in \cref{bintree} that needs to be tested and there
are two categories of tests that we can write. First, we should \emph{test all the
cases} of a function. For example, the \scalainline{insert} function has
four cases and the four tests below are chosen to exercise each case:
\begin{scalacode}
test("insert into empty tree") {
  assert(insert(200, "A", SLeaf()) == SNode(SLeaf(), 200, "A", SLeaf()))
}

test("insert into left-subtree") {
  assert(insert(200, "A", SNode(SLeaf(), 500, "B", SLeaf()))
    == SNode(SNode(SLeaf(), 200, "A", SLeaf()), 500, "B", SLeaf()))
}

test("insert into right-subtree") {
  assert(insert(700, "A", SNode(SLeaf(), 500, "B", SLeaf()))
    == SNode(Leaf(), 500, "B", SNode(SLeaf(), 700, "A", SLeaf())))
}

test("insert and replace") {
  assert(insert(200, "A", SNode(SLeaf(), 200, "B", SLeaf()))
    == SNode(SLeaf(), 200, "A", SLeaf()))
}
\end{scalacode}

A robust test suite should exercise \scalainline{insert} on larger examples, but
it is important to understand exactly what each case is doing, which is what the
descriptive string states.

The second kind if test is to \emph{test properties that relate functions
to each other}. There isn't a neat recipe for these kinds of tests. You have
to think hard about what your code is actually doing. But, here
are some properties for binary trees.

\begin{property}
After we insert a key-value into a tree, we should be able to
find it again.
\end{property}

The following tests check that this property holds on examples
where a key-value is inserted on the left, inserted on the right, or replaces
the root:
%
\begin{scalacode}
val t1 = SNode(SLeaf(), 200, "A", SLeaf())

test("find after insert on right") {
  assert(find(500, insert(500, "B", t1)) == "B")
}

test("find after insert on left") {
  assert(find(100, insert(100, "B", t1)) == "B")
}

test("find after insert replaces") {
  assert(find(200, insert(200, "B", t1)) == "B")
}
\end{scalacode}

\begin{property}
Inserting a key-value into a binary tree produces a tree with size one
greater than the original tree.
\end{property}

The following tests check that this property holds for the three
cases of \scalainline{insert}:
%
\begin{scalacode}
val t1 = SNode(SLeaf(), 200, "A", SLeaf())

test("insert increases size (rhs)")
  assert(size(insert(500, "B", t1) == size(t1) + 1)
}

test("insert increases size (lhs)") {
  assert(size(insert(100, "B", t1) == size(t1) + 1)
}

test("insert increases size (replacement)") {
  assert(size(insert(200, "B", t1) == size(t1) + 1)
}
\end{scalacode}

Unfortunately, the third test case fails because the property is wrong.
When \scalainline{insert} replaces a value in the tree, the size of the tree
does not change. Here is a revised version of this property that accounts
for this corner-case:

\begin{property}
Inserting a key-value into a binary tree either (1) produces a tree with
size one greater than the original tree or (2) the size of the produced
tree is the same and the key was present in the original tree.
\end{property}

We can write a function to test this property for any given $k$, $v$, and $t$
and use it to write our tests compactly:

\begin{scalacode}
def check(k: Int, v: String, t: SBinTree): Boolean = {
  if (size(insert(k, v, t)) == size(t) + 1) {
    true
  }
  else {
    try {
      val r = find(k, t)
      true
    }
    catch {
      case exn:Exception => false
    }
  }
}

val t1 = SNode(SLeaf(), 200, "A", SLeaf())

test("insert increases size (rhs)")
  assert(check(500, "B", t1))
}

test("insert increases size (lhs)") {
  assert(check(100, "B", t1))
}

test("insert increases size (replacement)") {
  assert(check(200, "B", t1))
}
\end{scalacode}

There are other properties that we can test. For example:
%
\begin{scalacode}
insert(k, v, insert(k, v, t)) == insert(k, v, t)
\end{scalacode}

Moreover, if we write more functions to process binary trees, the number of
interesting properties will keep growing.

\section{Lists\classtime{10}}

Although we've used Scala's builtin lists, we can use case classes to write
very similar types. For example, we can write a type for lists of integers
as follows:
%
\begin{scalacode}
sealed trait IList
case class INil() extends IList
case class ICons(head: Int, tail: IList) extends IList
\end{scalacode}

The following function adds $n$ to every number in a list:
%
\begin{scalacode}
def add(n: Int, lst: IList): IList = alist match {
  case INil() => INil()
  case ICons(head, tail) => ICons(head + n, add(n, tail))
}
\end{scalacode}

A test suite should test the two cases in the function. Moreover, we can
also test simple properties of this function alone.

For example, for all \scalainline{m}, \scalainline{n}, and \scalainline{alist}:
%
\begin{scalacode}
add(n, add(m, alist)) == add(m + n, alist)
\end{scalacode}

The following function appends two lists together:
%
\begin{scalacode}
def append(alist1: IList, alist2: IList): IList = alist1 match {
  case INil() => alist2
  case ICons(head, tail) => ICons(head, append(tail, alist2))
}
\end{scalacode}

Again, we should test the two cases of this function. But, there are
several other properties that we can test. For example, if we append
three lists together, the order in which we apply the function
does not matter:
%
\begin{scalacode}
append(alist1, append(alist2, alist3)) == append(append(alist1, alist2), alist3)
\end{scalacode}
i.e., \scalainline{append} is \emph{associative}.

Here is another property of \scalainline{append}:
\begin{scalacode}
append(alist, INil()) == alist
\end{scalacode}
%
Notice that this is \emph{not} a case of \scalainline{append}: the function
pattern-matches on the first argument. This property shows that both cases
of \scalainline{append} behave in a similar way when the second argument is
\scalainline{INil()}.

Finally, we can write properties that relate the \scalainline{add} and
\scalainline{append} functions:
%
\begin{scalacode}
append(add(n, alist1), add(n, alist2)) == add(n, append(alist1, alist2))
\end{scalacode}

\chapter{First-Class Functions I}
\savepdf{first-class-functions-1}
\lstset{language=scala}

\section{Generics and Type Inference\classtime{15}}

\begin{figure}
\begin{minipage}{0.45\textwidth}
\begin{scalacode}
def ilength(alist : List[Int]): Int = {
  alist match {
  case Nil => 0
  case _ :: tail => 1 + ilength(tail)
  }
}
\end{scalacode}
\subcaption{Length of a list of integers.}
\end{minipage}
\quad\vrule\quad
\begin{minipage}{0.45\textwidth}
\begin{scalacode}
def slength(alist : List[String]): Int = {
  alist match {
    case Nil => 0
    case _ :: tail => 1 + slength(tail)
  }b
}
\end{scalacode}
\subcaption{Length of a list of integers.}
\end{minipage}
\caption{Two very similar length functions.}
\label{monolength}
\end{figure}

\Cref{monolength} shows two functions that calculate (1) the length of a list
of integers and (2) the length of a list of strings. These two functions
are almost identical. The only difference between them in the type of
element in the list. We can abstract away the differences by writing
a \emph{generic} length function:
%
\begin{scalacode}
def length[A](alist: List[A]): Int = alist match {
  case Nil => 0
  case _ :: tail => 1 + length(tail)
}
\end{scalacode}

In the code above, \verb|A| is a \emph{type argument}. It truly is an argument
to the function, just like \verb|alist|. i.e., when \scalainline{length} is
invoked, we need to specify \verb|A|:
%
\begin{scalacode}
length[Int](List(1, 2, 3))
length[String](List("A", "B", "C", "D"))
\end{scalacode}
%
However, \verb|A| holds a type instead of a value.

Scala lets you elide type arguments in most cases. So, we could also write:
%
\begin{scalacode}
length(List(1, 2, 3))
length(List("A", "B", "C", "D"))
\end{scalacode}
%
But, it is important to note that under the hood, Scala figures out that we
meant \scalainline{A} to be \scalainline{Int} on the first line and
\scalainline{String} on the second line and inserts the type arguments for us.
In fact, we relied on this in the definition of \scalainline{length}: Scala
expands the recursive call \scalainline{length(tail)} to
\scalainline{length[A](tail)}. Note that Scala isn't just ``guessing'' the
right type. It uses the type of the value-arguments to infer the missing
type argument.

However, Scala's type inference is not perfect. It saves you typing, but don't
expect it to figure out exactly what you mean. It can make mistakes.
For example, if we write \scalainline{List(1, "2", 3)}, Scala infers
that it has type \scalainline{List[Any]}. But, this is almost certainly
not what we meant! We probably meant to construct a list of integers
or strings. If we instead wrote \scalainline{List[Int](1, "2", 3)}, Scala
would have signalled a type error.

\subsection{Generic Data Structures}

\begin{figure}

\begin{minipage}{0.45\textwidth}
\begin{scalacode}
sealed trait IBinTree
case class ILeaf() extends IBinTree
case class INode(
  lhs: IBinTree,
  key: Int,
  value: Int,
  rhs: IBinTree)
  extends IBinTree
\end{scalacode}
\caption{Values are integers.}
\end{minipage}
\quad\vrule\quad
\begin{minipage}{0.45\textwidth}
\begin{scalacode}
sealed trait SBinTree
case class SLeaf() extends IBinTree
case class SNode(
  lhs: SBinTree,
  key: Int,
  value: String,
  rhs: SBinTree)
  extends SBinTree
\end{scalacode}
\caption{Values are strings.}
\end{minipage}
\caption{Two non-generic binary trees.}
\label{monobintrees}
\end{figure}

In the last lecture, we build a data structure that represents binary
search trees with strings for values. We can write a similar data structure
with integer-values, as shown in \cref{monobintrees}. But, this will force
us to redefine the functions we wrote earlier to proceed \scalainline{SBinTree}s.
Instead, we can write a generic type for binary trees where the values have
some unknown type \scalainline{A}:

%
\begin{scalacode}
sealed trait BinTree[A]
case class Leaf[A]() extends BinTree[A]
case class Node[A](lhs: BinTree[A], key: Int, value: A, rhs: BinTree[A]) extends BinTree[A]
\end{scalacode}

Here are some examples of binary trees with values of different types:

\begin{itemize}

\item This binary tree has integer values:
\begin{scalacode}
Node(Leaf(), 10, 500, Leaf())
\end{scalacode}

\item This binary tree has string values:
\begin{scalacode}
Node(Leaf(), 10, "five hundred", Leaf())
\end{scalacode}

\item This binary tree has boolean values:
\begin{scalacode}
Node(Leaf(), 10, true, Leaf())
\end{scalacode}

\end{itemize}

We can easily update the \scalainline{insert}, \scalainline{find}, and \scalainline{size}
functions from the last lecture to work with generic binary trees.

\section{Higher-Order Functions on Lists}


\begin{figure}
\begin{subfigure}[b]{.45\textwidth}
\begin{scalacode}
def incrs(alist: List[Int]): List[Int] =
  alist match {
    case Nil => Nil
    case h :: t => h + 1 :: incrs(t)
  }
\end{scalacode}
\caption{A function that increments all numbers in a list.}
\end{subfigure}
\quad\vrule\quad
\begin{subfigure}[b]{.45\textwidth}
\begin{scalacode}
def lengths(alist: List[String]): List[Int] =
  alist match {
  case Nil => Nil
  case h :: t => h.length :: lengths(t)
}
\end{scalacode}
\caption{A function that calculates the lengths of all strings in a list.}
\end{subfigure}
\quad
\vskip 1em \hrule \vskip 1em
\begin{subfigure}[b]{.45\textwidth}
\begin{scalacode}
def doubles(alist: List[Int]): List[Int] =
  alist match {
    case Nil => Nil
    case h :: t => h * 2 :: doubles(t)
}
\end{scalacode}
\caption{A function that doubles all numbers in a list.}
\end{subfigure}
\quad\vrule\quad
\begin{subfigure}[b]{.45\textwidth}
\begin{scalacode}
def negates(alist: List[Int]): List[Int] =
  alist match {
    case Nil => Nil
    case h :: t => -h :: negates(t)
}
\end{scalacode}
\caption{A function that negates all numbers in a list.}
\end{subfigure}

\caption{Four different functions that transform elements of a list.}
\label{map_motivation}
\end{figure}


\subsection{The Map Function\classtime{15}}

Study the four functions in \cref{map_motivation}. The function \verb|incrs|
adds one to every element in a list of integers, the function \verb|lengths|
calculates the length of every string in a list, the function \verb|doubles|
doubles every number in a list, and the function \verb|negates| negates every
number in a list. Hopefully, you've noticed that these four functions have a lot
of in common. \emph{The only difference between them is the operation that they
perform on the head of the list}.

Here is a variant of \verb|doubles| that makes the operation explicit, by
moving it into a separate function:
%
\begin{scalacode}
def f(n: Int): Int = n * 2

def doubles(alist: List[Int]): List[Int] = alist match {
  case Nil => Nil
  case h :: t => f(h) :: doubles(t)
}
\end{scalacode}

In this version, we're simply applying a function $f$ to $h$, where $f$
is the doubling function.

\begin{think}
Apply the same refactoring to the other
functions. E.g.,  instead of directly writing \scalainline{head.length}, refactor
the function so that this expression is in a helper function.
\end{think}

Once we've re-written the operation as \scalainline{f(h)}, all three
functions look identical: the only difference is that each refers to a
different function.
Instead of writing three functions that are almost identical, we can
write one function that takes $f$ as an argument:

\begin{scalacode}
def map(f: Int => Int, alist: List[Int]): List[Int] = alist match {
  case Nil => Nil
  case h :: t => f(h) :: map(f, t)
}
\end{scalacode}

With this function, we can make our examples much more succinct:

\begin{scalacode}
def doubles(alist: List[Int]) = {
  def f(n: Int): Int = n * 2
  map(f, alist)
}

def incrs(alist: List[Int]) = {
  def f(n: Int): Int = n + 1
  map(f, alist)
}

def lengths(alist: List[String]) = {
  def f(str: String): Int = str.length
  map(f, alist)
}
\end{scalacode}

Unfortunately, the definition of \scalainline{lengths} above does not
type-check. Scala reports two type errors and they are both very informative:

\begin{console}
<console>:15: error: type mismatch;
 found   : String => Int
 required: Int => Int
         map(f, alist)
             ^
<console>:15: error: type mismatch;
 found   : List[String]
 required: List[Int]
         map(f, alist)
                  ^
\end{console}

The \scalainline{map} function only works of lists of integers. However, if you
look at the definition of \scalainline{map} closely, you'll see that all the
\scalainline{Int}-specific code has been factored out into \scalainline{f}. We
can make the function even more generic by introducing two type-parameters:

\begin{scalacode}
def map[A,B](f: A => B, alist: List[A]): List[B] = alist match {
  case Nil => Nil
  case h :: t => f(h) :: map[A, B](f, t)
}
\end{scalacode}

The type-parameter $A$ is the type of the elements in
\emph{alist} and the type-parameter $B$ is the type elements in the produced list.
In the code above, we've make all the type-arguments explicit. But, as we've
discussed before, we can rely on type-inference to fill them in:

\begin{scalacode}
def map[A,B](f: A => B, alist: List[A]): List[B] = alist match {
  case Nil => Nil
  case h :: t => f(h) :: map(f, t)
}
\end{scalacode}

\subsection{The Filter Function\classtime{10}}

Another common pattern when programming with lists is to select certain elements
that have some property. For example, here is a function that consumes a list,
and produces a new list that only contains the even numbers:

\begin{scalacode}
def filterEven(alist: List[Int]): List[Int] = alist match {
  case Nil => Nil
  case head :: tail =>
    (head % 2 == 0) match {
      case true => head :: filterEven(tail)
      case false => filterEven(tail)
    }
}
\end{scalacode}

This is a very common pattern too. For example, we could write a function to
select the odd numbers or the prime numbers. If we had a list of strings, we
could select all the strings with length 5 or all the strings that represent
English-language words. All these functions have the same shape: they test
the value of \scalainline{head} in some way. If the test succeeds, \scalainline{head} is added in
the output list. But, if the test fails, it is excluded.

Following the same strategy we used to derive \scalainline{map}, we first package
the \scalainline{head}-test into a function:

\begin{scalacode}
def f(n: Int): Boolean = head % 2

def filterEven(alist: List[Int]): List[Int] = alist match {
  case Nil => Nil
  case head :: tail =>
    f(head) match {
      case true => head :: filterEven(tail)
      case false => filterEven(tail)
    }
}
\end{scalacode}

Now that the pattern is clearer, we generalize \scalainline{filterEven} to take \scalainline{f}
as an argument:

\begin{scalacode}
def filter(f: Int => Boolean, alist: List[Int]): List[Int] = alist match {
  case Nil => Nil
  case head :: tail =>
    f(head) match {
      case true => head :: filter(f, tail)
      case false => filter(f, tail)
    }
}

def filterEven(alist: List[Int]): List[Int] = {
  def f(n: Int): Boolean = head % 2
  filter(f, alist)
}
\end{scalacode}

Finally, just as we did for \scalainline{map}, we can generalize the type of \scalainline{filter}
so that it can be applied to \scalainline{List[A]}:

\begin{scalacode}
def filter[A](f: A => Boolean, alist: List[A]): List[A] = alist match {
  case Nil => Nil
  case head :: tail =>
    f(head) match {
      case true => head :: filter(f, tail)
      case false => filter(f, tail)
    }
}
\end{scalacode}

\begin{instructor}
Cannot show find because it relies on Option
\end{instructor}

% \subsection{The Find Function\classtime{10}}

% Another common operation on lists is to find an element. For example,
% the following function finds the first even number in a list:

% \begin{scalacode}
% def findEven(alist: List[Int]): Option[Int] = alist match {
%   case Empty() => None()
%   case Cons(head, tail) => (head % 2 == 0) match {
%     case true => Some(head)
%     case false => findEven(tail)
%   }
% }
% \end{scalacode}

% If we change \scalainline{(head % 2 == 0)} to \scalainline{(head % 2 == 1)}, we'll have the
% \scalainline{findOdd} function. Again, instead of defining two slightly different
% functions, we can write the general \scalainline{find} function:

% \begin{scalacode}
% def find[A](f: A => Boolean, alist: List[A]): Option[A] = alist match {
%   case Empty() => None()
%   case Cons(head, tail) => f(head) match {
%     case true => Some(head)
%     case false => find(f, tail)
%   }
% }
% \end{scalacode}

\subsection{Sorting}

You've written sorting functions that sort lists is ascending or descending
order. But, the following higher-order function can be used to sort any
lists of any type, given an arbitrary ``less than'' operator.

\begin{scalacode}
def insert[A](lessThan: (A, A) => Boolean, x: A, alist: List[A]): List[A] = alist match {
  case Nil => List(x)
  case hd :: tl => {
    if (lessThan(x, hd)) {
      x :: hd :: tl
    }
    else {
      hd :: insert(lessThan, x tl)
    }
  }
}

def sort[A](lessThan: (A, A) => Boolean, alist: List[A]) = alist match {
  case Nil => Nil
  case hd :: tl => insert(lessThan, hd, sort(lessThan, tl))
}

def sortAscending(alist: List[Int]): Int = {
  def f(x: Int, y: Int): Boolean = x < y
  sort(f, alist)
}

def sortDescending(alist: List[Int]): Int = {
  def f(x: Int, y: Int): Boolean = x > y
  sort(f, alist)
}

def sortByLengthAscending(alist: List[String]): Int = {
  def f(x: String, y: String): Boolean = x.length < y.length
  sort(f, alist)
}
\end{scalacode}

\section{Builtin Methods on Lists\classtime{5}}

All the higher-order list-processing functions that we've defined are already
built-in to Scala as methods on lists.

\begin{itemize}

\item
We can map over a list using the \scalainline{map} method:

\begin{scalacode}
def f(n: Int): Int = n + 1

assert(List(10, 20, 30).map(f) == List(11, 21, 22))
\end{scalacode}

\item We can filter a list using the \scalainline{filter} method:

\begin{scalacode}
def f(n: Int): Boolean = n % 2 == 0

assert(List(0, 1, 2, 3, 4, 5).map(f) == List(0, 2, 4))
\end{scalacode}

\item We can sort a list using the \scalainline{sortWith} method:

\begin{scalacode}
def f(x: Int, y: Int): Boolean = x > Y

assert(List(3, 7, 9, 11).sortWith(f) == List(11, 9, 7, 3))
\end{scalacode}

\end{itemize}

There are several other higher-order functions that you can discover from
the documentation or the Scala console.

\chapter{First-Class Functions II}
\savepdf{first-class-functions-2}

\begin{figure}
\begin{subfigure}{.45\textwidth}
\begin{scalacode}
def sum(alist: List[Int]): Int = alist match {
  case Nil => 0
  case hd :: tl => hd + sum tl
}
\end{scalacode}
\caption{Add all numbers in a list}
\end{subfigure}%
\quad\vrule\quad
\begin{subfigure}{.45\textwidth}
\begin{scalacode}
def product(alist: List[Int]): Int = alist match {
  case Nil => 1
  case hd :: tl => hd + product tl
}
\end{scalacode}
\caption{Multiply all numbers in a list}
\end{subfigure}
\vskip .5em \hrule \vskip .5em
\begin{subfigure}{.45\textwidth}
\begin{scalacode}
def concat(alist: List[String]): String = {
  alist match {
    case Nil => ""
    case hd :: tl => hd + concat tl
  }
}
\end{scalacode}
\caption{Concatenate all strings in a list}
\end{subfigure}%
\quad\vrule\quad
\begin{subfigure}{.45\textwidth}
\begin{scalacode}
def totalLen(alist: List[String]): Int = {
  alist match {
    case Nil => 0
    case hd :: tl => hd.length + totalLen tl
  }
}
\end{scalacode}
\caption{Sum the lengths of all strings in a list}
\end{subfigure}
\caption{Several functions that \emph{fold} over a list.}
\label{folding_prototypes}
\end{figure}

\section{Folding\classtime{20}}
%
The four functions in \cref{folding_prototypes} are examples of
\emph{folding functions}. A folding function ``collapses'' a list into
a single value. A fold is characterized by a binary operation used to
combine values and a base case for the empty list.

\begin{itemize}

\item In \scalainline{sum}, the binary operation is \scalainline{+}
and the base value is \scalainline{0}:
\begin{scalacode}
sum(List(10, 20, 30)) = 10 + (20 + (30 + 0))
\end{scalacode}

\item In \scalainline{product}, the binary operation is \scalainline{*}
and the base value is \scalainline{1}:
\begin{scalacode}
product(List(2, 3, 4)) = 2 * (3 + (4 * 1))
\end{scalacode}

\item In \scalainline{concat}, the binary operation is \scalainline{+} (string
concatenation) and the base value is \scalainline{""}:
\begin{scalacode}
concat(List("X", "Y", "Z")) = "X" + ("Y" + ("Z" + ""))
\end{scalacode}

\item In \scalainline{totalLen}, the binary operation is the following
function:
\begin{scalacode}
def binop (hd : String, tailLen : Int) : int = hd.length + tailLen
\end{scalacode}
and the base value is \scalainline{0}:
\begin{scalacode}
totalLen(List("hi", "cs220", "student")) = binop("hi", binop("cs220", binop("student" 0)))
\end{scalacode}

\end{itemize}

Now that we've seen the common pattern, it's clear that we abstract
these functions to a higher-order
function that takes three arguments (1) the original list, (2)
a two-argument function instead of a fixed binary operator, and (3) a
value for the base-case, instead of a fixed base-case:
%
\begin{scalacode}
def fold(baseCase: ???, binOp: (???, ???) => ???, alist: List[???]): ??? = alist match {
  case Nil => baseCase
  case head :: tail => binOp(head, fold(baseCase, binOp, tail))
}
\end{scalacode}

We can rewrite the functions in \cref{folding_prototypes} more
succinctly as follows:
%
\begin{scalacode}
def sum(alist : List[Int]) = fold(0, (x: Int, y: Int) => x + y, alist)

def product(alist : List[Int]) = fold(1, (x: Int, y: Int) => x * y, alist)

def concat(alist : List[String]) = fold("", (x: String, y: String) => x + y, alist)

// binOp was defined above
def totalLen(alist : List[Int]) = fold(0, binOp, alist)
\end{scalacode}

Note that in \scalainline{binOp}, the types of the two arguments
are different. The type of the first argument is the same as the
type of the elements in the list. The type of the second argument
is the same as the type of the result of the function. This is because
when \scalainline{binOp} is applied (internally within \scalainline{fold}),
the first argument to  \scalainline{binOp} is an element of the
list, and the second argument is an intermediate result.
Therefore, we can fill in the types in \scalainline{fold} as follows:
%
\begin{scalacode}
def fold[A,B](baseCase: B, binOp: (A, B) => B, alist: List[A]): B = alist match {
  case Nil => baseCase
  case head :: tail => binOp(head, fold(baseCase, binOp, tail))
}
\end{scalacode}

\section{Functions are Values\classtime{10}}

\paragraph{Functions can be passed as arguments to functions.}
The last lecture introduced functions can be passed as arguments
to other functions. For example, the function \scalainline{filter(f, alist)}
produces a list of all the items of \scalainline{alist} for which \scalainline{f}
is \scalainline{true}:
%
\begin{scalacode}
def filter[A](f: A => Boolean, alist: List[Int]): List[A] = alist match {
  case Nil => Nil
  case Cons(head, tail) =>
    f(head) match {
      case true => head :: filter(f, tail)
      case false => filter(f, tail)
    }
}
\end{scalacode}

This allowed us to write several functions very easily, for example:
%
\begin{scalacode}
def isEven(n: Int): Boolean = n % 2 == 0

def onlyEvens(alist: List[Int]): List[Int] = {
  filter(isEven, alist)
}

def nonZero(n: Int): Boolean = n != 0

def onlyNonZero(alist: List[Int]): List[Int] = {
  filter(nonZero, alist)
}
\end{scalacode}

\paragraph{Functions can be nested within other functions.}

If our goal was to write the list-processing functions, then the
functions \scalainline{isEven} and \scalainline{nonZero}, are
cluttering our code. Another programmer may think that they are signficant,
although they simply exist as trivial helper functions.

Functions can be nested within other functions:
%
\begin{scalacode}
def onlyEvens(alist: List[Int]): List[Int] = {
  def isEven(n: Int): Boolean = n % 2 == 0
  filter(isEven, alist)
}

def onlyNonZero(alist: List[Int]): List[Int] = {
  def nonZero(n: Int): Boolean = n != 0
  filter(nonZero, alist)
}
\end{scalacode}
%
In particular, the names \scalainline{isEven} and \scalainline{nonZero}
are \emph{not defined} outside their respective functions.

\paragraph{Functions can produce functions.}

Functions can also produce other functions. For example:
%
\begin{scalacode}
def makeAdder(x: Int): Int => Int = {
  def addX(y: Int): Int = x + y
  addX(x)
}

val addThree = makeAdder(3)
test("add3 test") {
  assert(addThree(10) == 13)
}
\end{scalacode}

\paragraph{Functions do not need to be named.}

Unlike other values, functions seem to have the following special property:
every function has a name, but the other kinds of values do not.
For example, we can simply write \scalainline{1 :: 2 :: 3 :: Nil}
and don't need to give this list a name. So far, all of the functions we've seen
start with \scalainline{def functionName}.

It turns out that this is just a convention. As with other values,
functions don't need names. For example, here is a function that adds two
numbers:

\begin{scalacode}
((x: Int, y: Int) => x + y)
\end{scalacode}

This function does not have a name, but it can be applied just like
any other function:

\begin{scalacode}
((x: Int, y: Int) => x + y)(10, 20)
\end{scalacode}

The code above is not easy to read. It will be a lot clearer of we give the
function a name. You already know how to name a function using \scalainline{def}. But, all
other values are named using \scalainline{val}. In fact, we can use \scalainline{val} to name functions
too, just like any other type of value:

\begin{scalacode}
val adder = ((x: Int, y: Int) => x + y)

adder(10, 20)
\end{scalacode}

You should think of \scalainline{def} as a convenient shorthand for naming functions.
That is, these two definitions are equivalent:

\begin{scalacode}
val adder = ((x: Int, y: Int) => x + y)

def adder(x: Int, y: Int) = x + y
\end{scalacode}

In general, it is a good idea to name your functions. But, there are
certain situations where a short, anonymous function can make your code
easier to read and write.

For example, we earlier defined the \scalainline{doubleAll} function, which doubles
every number in a list of numbers. Here is simple, one-line definition
using an anonymous function as an argument to \scalainline{map}:

\begin{scalacode}
def doubleAll(alist: List[Int]) = map((n: Int) => n * 2, alist)
\end{scalacode}

The anonymous function itself is extremely simple and the name of the enclosing
function, \scalainline{doubleAll}, really makes it clear what it does.

For another example, suppose we want to remove all the odd numbers
in a list. We can do this using \scalainline{filter} and a short, anonymous function:

\begin{scalacode}
def removeOdds(alist: List[Int]) = filter((n: Int) => n % 2 == 0, alist)
\end{scalacode}

In these kinds of situations, anonymous functions can be very helpful.

\paragraph{Functions can be stored in data structures.}

The following datatype can stores two functions inside it:
%
\begin{scalacode}
case class Foo(m1: Int => Int, m2: Int => Int)
\end{scalacode}

We can create values of type \scalainline{Foo} in the following way:
%
\begin{scalacode}
val myFoo = Foo((x: Int) => x + 1, (y: Int) => y * 20)

assert(myFoo.m1(10) == 11)
assert(myFoo.m2(10) == 200)
\end{scalacode}
%
Admittedly, this isn't very useful, but notice that the function applications
look a lot like method calls.

\subsection{Some Definitions}

Here are some terminology that gets thrown around when comparing programming
languages and programming techniques.

\begin{itemize}

  \item \emph{Higher-order functions} are functions that consume or return other
  functions as values. You can tell if a function is higher-order by inspecting
  its type. Does it have any nested uses of \scalainline{=>} in the type? If so, it is a higher-order
  function.

  \item \emph{First-class functions} is a property of a programming language. For
  a programming language to have first-class functions, it must treat functions
  as values, with all the rights and privileges that other values have. You must
  be able to use functions as arguments, produce functions as results, and store
  functions in data-structures.

\end{itemize}

\section{Scope and Substitution\classtime{20}}

\paragraph{Global vs. Local Variables}

Why does the following program raise an error?

%
\begin{scalacode}
def f(x: Int) = {
  val y = x + 10
  y
}
f(11)
y
\end{scalacode}

Although the program defines a variable called \scalainline{y}, the
\emph{scope} of the variable is limited to the function \scalainline{f}.
Therefore, we cannot refer to the variable outside the function, which
is why we get an error.

\paragraph{Substitution}

What does the following program produce?
%
\begin{scalacode}
val x = 20
def f(x: Int): Int = {
  x + 5
}
f(10) + x
\end{scalacode}

The result is \scalainline{35}. Within the body of \scalainline{f}, the
the name \scalainline{x} refers to the argument to the function, which
\emph{shadows} the global variable \scalainline{val x = 20}. Therefore,
\scalainline{f(10) == 15}. However, outside the function \scalainline{x}
refers to the global variable \scalainline{x == 20}, and
\scalainline{15 + 20 == 35}.

We can make this argument more precise by \emph{substituting} variables
with their values:

\begin{itemize}

\item Given the orignal program above, we first substitute
the global \scalainline{x} with its value \scalainline{20}, to get
the following program:
\begin{scalacode}
def f(x: Int): Int = {
  x + 5
}
f(10) + 20
\end{scalacode}
%
Notice that we substituted the \scalainline{x} on the last line with \scalainline{20},
but left the \scalainline{x} within \scalainline{f} unchanged, since it referred
to the argument \scalainline{x}.

\item Next, we can apply the function \scalainline{f} by substituting
its argument \scalainline{x} with the value \scalainline{10}:
%
\begin{scalacode}
(10 + 5) + 20
\end{scalacode}

\item Finally, we are left with a simple arithmetic expression that is
trivial to evaluate.

\end{itemize}

Here is a more compact way of making the same argument:
%
\[
\small
\begin{array}{l|l|l}
 & \textrm{Expression} & \textrm{Reasoning} \\
\hline
& \lstinline[language=scala]|val x = 20; def f(x: Int): Int = { x + 5 }; f(10) + x|
& \textrm{Original expression} \\
= & \lstinline[language=scala]|def f(x: Int): Int = { x + 5 }; f(10) + 20|
& \textrm{Substitute \lstinline[language=scala]|x| with \lstinline[language=scala]|20|} \\
= & \lstinline[language=scala]|(10 + 5) + 20|
& \textrm{Inline \lstinline[language=scala]|f| and substitute \lstinline[language=scala]|x| with \lstinline[language=scala]|10|} \\
= & \lstinline[language=scala]|15 + 20|
& \textrm{Evaluate \lstinline[language=scala]|10 + 5|} \\
= & \lstinline[language=scala]|35|
& \textrm{Evaluate \lstinline[language=scala]|15 + 20|}
\end{array}
\]

\paragraph{Nested Functions}
Scope can appear tricker when working with higher-order functions. But, we can
use the same substitution principle to reason about nested functions.

For example, we wrote the \scalainline{makeAdder} higher-order function before
and used it to create the \scalainline{add10} function:
\begin{scalacode}
def makeAdder(x: Int): Int => Int = {
  def add(y): Int = { x + y }
  add
}

val add10 = makeAdder(10)
\end{scalacode}

The following calculate starts with the definition above (written in a single
line for brevity) and shows that it is equivalent to the more obvious
definition of \scalainline{add10}:
\[
\small
\begin{array}{l|l|l}
 & \textrm{Expression} & \textrm{Reasoning} \\
\hline
& \multicolumn{2}{l}
{\lstinline[language=scala]|def makeAdder(x: Int): Int => Int = { def add(y): Int = { x + y }; add }; val add10 = makeAdder(10)|}  \\
= & \lstinline[language=scala]|val add10 = { def add(y): Int = { x + 10 }; add }|
& \textrm{Inline \lstinline[language=scala]|makeAdder| and substitute \lstinline[language=scala]|y| with
\lstinline[language=scala]|10|} \\
= & \lstinline[language=scala]|val add10 = { val add = ((y: Int) => { x + 10 }); add }| & \textrm{Rewrite \lstinline[language=scala]|add| using \lstinline[language=scala]|val| notation} \\
= & \lstinline[language=scala]|val add10 = ((y: Int) => { x + 10 })|
& \textrm{Substitute \lstinline[language=scala]|add| with its definition} \\
= & \lstinline[language=scala]|def add10(y: Int) = x + 10|
& \textrm{Rewrite \lstinline[language=scala]|add| using \lstinline[language=scala]|def| notation}
\end{array}
\]

In fact, every line in this calculation is a valid Scala program (which you
should check!) and all the lines are truly equivalent to each other.

It is always possible to perform these kinds of calculations to simplify
expressions with higher-order functions. For large programs, a detailed
calculation may be infeasibly wrong. But, if you understand how these
calculuations work in detail on small programs, you'll be able to reason
carefully about larger programs without needing to actually do the calculuates
in detail.

\section{Storing Functions in Data Structures\classtime{25}}

Although we've seen that functions can be stored in data structures,
we haven't seen any good examples that suggest why we may want to do so.
For example, here is yet another type that stores functions in its
fields:
\begin{scalacode}
case class Point(
  getX: () => Double,
  getY: () => Double,
  magnitude: () => Double,
  add: Point => Point)
\end{scalacode}

Above, \scalainline{getX}, \scalainline{getY}, and \scalainline{magnitude}
are fields that store functions that consume zero arguments and produce
\scalainline{Double}s.

Consider the following higher-order function, which consumes two coordinates
and produces a point:
\begin{scalacode}
def makePoint(x: Double, y: Double): Point = {
  def getX(): Double = x
  def getY(): Double = y
  def magnitude(): Double = math.sqrt(x * x + y * y)
  def add(other: Point): Point = makePoint(x + other.getX(), y + other.getY())
  Point(getX, getY, magnitude, add)
}
\end{scalacode}

We can now construct points using \scalainline{makePoint}
and invoke the functions that it defines. For example:
%
\begin{scalacode}
val pt1 = makePoint(3.0, 4.0)
assert(pt1.magnitude() == 5.0)
val pt2 = pt1.add(makePoint(10.0, 10.0))
assert(pt2.getX() == 13.0)
assert(pt1.getY() == 4.0)
\end{scalacode}

Note that this looks an awful lot like vanilla object-oriented programming.
In fact, you could say that \scalainline{makePoint} is a \emph{constructor}
that produces object that have the \emph{interface} \scalainline{Point}
and that \scalainline{getX}, \scalainline{getY}, etc. are \emph{methods} that the
interface defines.
Furthermore, \scalainline{x} and \scalainline{y} are \emph{private fields},
since they are not in scope outside the \scalainline{makePoint}
function.\footnote{However, \scalainline{x} and \scalainline{y} are in scope
for the methods, since they are local to \scalainline{makePoint}.}

This example shows that you can encode object-oriented programs using
higher-order functions. In fact, this example makes essential use of
scope, functions stored in data structures, functions that return
functions (stored in data structures), and all the other characteristics
of first-class functions. With just a little more effort, other object-oriented
ideas like inheritence can be encoded using higher-order functions too.
Conversely, it turns out that higher-order functions can be encoded using
objects, which we will see later in the course. The point of this exercise
is that functional programming and object-oriented programming are two sides
of the same coin.

\include{discussion_hof}

\chapter{Handling Errors and the Option Type}
\savepdf{handling-errors-option-type}

\section{Required Reading}

Read Chapters 16 and 17 of \emph{Programming in Scala}.\footnote{The
  first edition is available online at
  \url{http://www.artima.com/pins1ed/}. The material in these chapters
  apply to the current version of Scala.} In Chapter 17, focus on
immutable collections. We will not use mutable collections in this class, so you can
skip reading about list buffers, array buffers, and arrays.

\section{Partial Functions and Signalling Errors}

\lstset{language=scala}
Many functions are not defined on all inputs. For example, if you're reading
input from a keyboard (i.e., a string) and want to parse the string as a
number, you can apply \lstinline|Integer.parseInt|:

\lstset{language=console}
\begin{lstlisting}
scala> val n = Integer.parseInt("10")
n: Int = 10
\end{lstlisting}

But, if the string is not a numeral, you get an exception:

\begin{lstlisting}
scala> val n = Integer.parseInt("ten")
java.lang.NumberFormatException: For input string: "ten"
\end{lstlisting}

\lstset{language=scala}
You've encountered other ways of signalling errors. For example, if you lookup
an unbound key in a hashtable, Java (and Scala) produce \lstinline|null|:

\lstset{language=console}
\begin{lstlisting}
scala> val ht = new java.util.Hashtable[Int, String]()
ht: java.util.Hashtable[Int,String] = {}
scala> ht.put(10, "hello")
scala> val r = ht.get(20)
r: String = null
\end{lstlisting}

Finally, here is a more insidious example. The following function calculates the
point where two lines, defined by $y = m_1 \cdot x + b_1$ and
$y = m2_ \cdot x + b_2$, intersect.
The function is not defined when the two lines are parallel (i.e., when their
slopes are the same, or $m_1 = m_2$):

\lstset{language=scala}
\begin{lstlisting}
 case class Point(x: Double, y: Double)

 def inter(m1: Double, b1: Double, m2: Double, b2: Double): Point = {
   val x = (b2 - b1) / (m1 - m2)
   Point(x, m1 * x + b1)
 }
\end{lstlisting}

When the slopes are the same, the denominator, \lstinline|m1 - m2| is
\lstinline|0|. So, you
might expect a divide-by-zero \lstinline|ArithmeticException|.
That's \emph{not}: what happens:
\lstset{language=console}
\begin{lstlisting}
scala> 1.0 / 0.0
res0: Double = Infinity
\end{lstlisting}
\lstset{language=scala}
So you can't even catch this error with an exception handler, since no exception
is raised. In fact, the following interaction produces a \lstinline|NaN| value
(the number called ``not-a-number''):
\lstset{language=console}
\begin{lstlisting}
scala> val r = inter(0, 0, 0, 0)
r: Point = Point(NaN,NaN)
\end{lstlisting}

All these mechanisms for signalling errors share similar flaws:
%
\begin{enumerate}

  \item \emph{Exceptions}: you have to remember to catch them, or your program will
   crash. You can't tell if a function will throw an exception without carefully
   reading its code, which may not even be possible if it is in a library.

  \item  \emph{Producing null}: even worse than exceptions, because your program
   will will \emph{not} crash on an error. When it does crash, you'll spend a
   lot of time trying to figure out what produced the \scalainline{null}.

   \item \emph{Producing other null-like values}: see above.

 \end{enumerate}

The real problem is that the types of all these functions are not useful:

\begin{itemize}

  \item The type of \scalainline{Integer.parseInt} is
  \scalainline{String => Int}, but it may throw an exception instead of producing an \scalainline{Int}.

  \item The type of \scalainline{ht.get} is \scalainline{Any => String}, but it
  may produce a \scalainline{null}.

  \item The type of \scalainline{inter} is \scalainline{(Double, Double, Double, Double) => Point},
  but it can produce \scalainline{Point(NaN, NaN)}, which is clearly not what we
  had in mind.

\end{itemize}

\paragraph{A Solution}

Let's use \scalainline{inter} as an example and modify the function so that its type
makes it obvious that it may not always return a \scalainline{Point}. We introduce
the following sealed trait:

\begin{scalacode}
sealed trait OptionalPoint
case class SomePoint(pt: Point) extends OptionalPoint
case class NoPoint() extends OptionalPoint
\end{scalacode}

And we modify \scalainline{inter} to produce \scalainline{NoPoint} instead of a malformed-\scalainline{Point}:

\begin{scalacode}
def inter(m1: Double, b1: Double, m2: Double, b2: Double): OptionalPoint = {
  if (m1 - m2 == 0) {
    NoPoint()
  }
  else {
    val x = (m1 - m2) / (b2 - b1)
    Point(x, m1 * x + b1)
  }
}
\end{scalacode}

With this new type, any program that applies \scalainline{inter} will be forced to check if
a point was produced:

\begin{scalacode}
  inter(10, 3, 10, 3) match {
    case NoPoint => println("no intersection")
    case SomePoint(Point(x,y)) => println(s"intersection at ($x, $y)")
  }
\end{scalacode}

Consider another example: a type that represents an \emph{alarm clock}. An alarm
clock needs to track the current time and \emph{the alarm time if the alarm is set}:

\begin{scalacode}
case class Time(h: Int, m: Int, s: Int)
case class AlarmClock(time: Time, alarm: Time, alarmOn: Boolean)
\end{scalacode}

But, with this representation, it is easy to make simple errors. For example,
you may accidentally trigger the alarm when \scalainline{time == alarm}, if you forget
to check \scalainline{alarmOn} first. A cleaner represention is to use the same pattern we used
above:

\begin{scalacode}
sealed trait OptionalAlarm
case class NoAlarm() extends OPtionalAlarm
case class AlarmSet(time: Time) extends OptionalAlarm

case class AlarmClock(time: Time, alarm: OptionalAlarm)
\end{scalacode}

In both \scalainline{inter} and \scalainline{AlarmClock}, it is completely
obvious from the type that a point is not always produced and that an alarm is
not always set. Partial functions are \emph{pervasive} in computing and this pattern
will make your programs more robust.

But, it is annoying to define a new type such as \scalainline{OptionalPoint}
and \scalainline{OptionalAlarm} for each type.

\subsection{The Option Type}

Scala has a builtin generic type called \scalainline{Option} that abtracts the
pattern we discussed above. For example, here is \scalainline{inter} rewritten
to use \scalainline{Option}:

\begin{scalacode}
def inter(m1: Double, b1: Double, m2: Double, b2: Double): Option[Point] = {
  if (m1 - m2 == 0) {
    None
  }
  else {
    val x = (m1 - m2) / (b2 - b1)
    Some(Point(x, m1 * x + b1))
  }
}
\end{scalacode}

\section{Built-in List methods}

Scala's \scalainline{List} type has dozens of useful methods. For example,
these methods correspond to the higher-order functions we've seen so far:
%
\begin{itemize}

  \item We can map over a list:

  \begin{scalacode}
  assert(List(10, 20, 30).map(x => x + 1) == List(11, 21, 31))
  \end{scalacode}

  \item We can filter a list:

  \begin{scalacode}
  assert(List(1, 2, 3, 4).filter(x => x % 2 == 0) == List(2, 4))
  \end{scalacode}

  \item We can fold over a list:

  \begin{scalacode}
  assert(List(10, 20, 30).foldRight(0)((x, acc) => x + acc) == 60)
  \end{scalacode}

\end{itemize}

Notice that the syntax of \scalainline{foldRight} is unusual. We'll get into the
details how it works later. For now, there is no need to write sums and products
using folds. Scala's lists have methods that do these directly:

\begin{scalacode}
assert(List(10, 20, 30).sum == 60)
assert(List(10, 20, 30).product == 6000)
\end{scalacode}

There are several other useful methods. For example:

\begin{itemize}

  \item \scalainline{alist.take(n)} produces a list with first \scalainline{n}
  elements of \scalainline{alist}. Similarly, \scalainline{alist.drop(n)} produces
  a list without the first \scalainline{n} elements of \scalainline{alist}.
  %
  \begin{scalacode}
  val alist = List("X", "Y", "Z", "A", "B", "C")
  assert(alist.take(3) == List("X", "Y", "Z"))
  assert(alist.drop(3) == List("A", "B", "C"))
  assert(alist.take(3) ::: alist.drop(3) == alist)
  \end{scalacode}

  In the last line, the \scalainline{:::} operator (pronounced ``append'')
  appends two lists.

  \begin{notation}
  We emphasize that \scalainline{:::} is an ordinary method,
  even though it is written using funny symbols and appears to be an infix
  operator. We could append lists using conventional method-application
  syntax:
  \begin{scalacode}
  assert(alist.:::(alist) == alist ::: alist)
  \end{scalacode}
  In fact, all operators on objects are actually ordinary methods. E.g.,
  we could write \scalainline{2.+(3.*(6))}, to do arithmetic using
  conventional method-application syntax. However, the usual notation
  of \scalainline{2 + (3 * 6)} is typically easier to read.

  \end{notation}

  \item \scalainline{alist.exists(f)} produces \scalainline{true} if there
  exists any element in the list on which \scalainline{f} produces
  \scalainline{true}.

  \begin{scalacode}
  assert(List(1, 2, 3, 4).exists(n => n == 2) == true)
  assert(List(1, 2, 3, 4).exists(n => n == 5) == false)
  \end{scalacode}

  \item \scalainline{alist.forall(f)} checks that all elements in \scalainline{alist}
  satisfy \scalainline{f}:
  %
  \begin{scalacode}
  assert(List(2, 4, 6, 8).forall(x => x % 2 == 0) == true)
  assert(List(2, 3, 4).forall(x => x % 2 == 0) == false)
  \end{scalacode}

\end{itemize}

There are several other useful functions. You should explore the
\href{http://www.scala-lang.org/api/2.11.7/index.html#scala.collection.immutable.List}{List API} to learn more about them.

\section{Sets and Maps}

\paragraph{Sets}
%
The Scala standard library also defines sets and maps, which are two other data
structures that are very common. Note that these represent mathematical sets, so
they don't have duplicate elements and are not ordered. i.e., the three
definitions below are the same:
%
\begin{scalacode}
Set(1, 2, 3)
Set(1, 2, 2, 3)
Set(3, 2, 1)
\end{scalacode}

Sets have methods for calculating set union, set intersection, set difference,
testing emptiness, and so on:
%
\begin{scalacode}
assert(Set(1, 2, 3).union(Set(2, 3, 4)) == Set(1, 2, 3, 4))
assert(Set(1, 2, 3).intersect(Set(2, 3, 4)) == Set(2, 3))
assert(Set(1, 2).intersect(Set(3, 4)).isEmpty == true)
\end{scalacode}

We can also map and filter the elements of sets, similar to lists:
%
\begin{scalacode}
assert(Set(1, 2, 3, 4).filter(x => x % 2 == 0) == Set(2, 4))
assert(Set(1, 2, 3, 4, 5).map(x => x % 2) = Set(0, 1))
\end{scalacode}

There are severy other useful methods in the
\href{http://www.scala-lang.org/api/2.11.7/index.html#scala.collection.immutable.Set}{Set API}.

\paragraph{Maps}
The Map data-structure (which is not the same as the map function) is a finite
map from keys to values. For example:
%
\begin{scalacode}
val dueDates = Map(
  1 -> "Jan 28",
  2 -> "Feb 4",
  3 -> "Feb 11")
\end{scalacode}

\begin{notation}
\scalainline{X -> Y} is just another notation for the tuple
\scalainline{(X, Y)}, but is commonly used with maps to suggest that it
``maps X to Y''. Therefore, we could have writen
\begin{scalacode}
val dueDates = Map(
  (1, "Jan 28"),
  (2, "Feb 4"),
  (3, "Feb 11"))
\end{scalacode}
\end{notation}

We can lookup a key in two ways. First, we can simply apply the map to a key,
just like a function:
\begin{scalacode}
assert(dueDates(1) == "Feb 4")
\end{scalacode}

However, if the key is not found, this throws an exception. An alternative
is to apply the get methods, which produces \scalainline{Some(v)} if the
key is mapped to a value and \scalainline{None} otherwise:
%
\begin{scalacode}
dueDates.get(x) match {
  case Some(v) => v
  case None => "Unknown assignment"
\end{scalacode}

We can augment maps using the following syntax:
\begin{scalacode}
val moreDueDates = dueDates + (4 -> "Feb 18")
\end{scalacode}
We emphasize that this produces a new map with all the contents of
\scalainline{dueDates} and the key mapping for \scalainline{4}.
The original map is not modified.

\begin{notation}
The notation \scalainline{m + (k -> v)} seems to be something
new, but we know how to unpack it. We just learned the arrow notation is
another way of writing tuples, we can first rewrite it as \scalainline{m + (k, v)}.
We also learned that all operators on objects are actually methods, so
can rewrite it again as \scalainline{m.+((k, v))}.

Therefore, we can conclude that maps have a method called \scalainline{+} that
takes one argument. This argument is a tuple where the first component is a key
\scalainline{k} and the second component is the value \scalainline{v}. The
result of applying this method is a new map where \scalainline{k} is mapped to
\scalainline{v}.
\end{notation}

It is often get the set of keys in a map:
\begin{scalacode}
assert(dueDates.keys == Set(1, 2, 3))
\end{scalacode}

Similarly, we can get an \emph{iterator} over the values. Typically, you'll
want to turn the iterator into a list immediately:
\begin{scalacode}
assert(dueDates.values.toList == List("Jan 28", "Feb 4", "Feb 11"))
\end{scalacode}

As usual, there are dozens of handy methods over maps. You should
explore the \href{http://www.scala-lang.org/api/2.11.7/index.html#scala.collection.Map}{Map API}.

\section{Conversions}

It is sometimes necssary and easy to convert lists, sets, and maps to each
other. These objects have methods called \scalainline{toList},
\scalainline{toSet}, and \scalainline{toMap} that do exactly what their
names suggest. For example:
%
\begin{scalacode}
assert(Map("X" -> 10, "Y" -> 20).toList == List(("X", 10), ("Y", 20)))
assert(List(("X", 10), ("Y", 20)).toMap == Map("X" -> 10, "Y" -> 20))
\end{scalacode}

\chapter{Shell Scripting and Function Composition}
\savepdf{shell-scripting-and-composition}

In this chapter, we will first take a small detour from Scala to learn basic
\emph{shell scripting}. Shell scripts let you quickly automate repetitive tasks
that frequently occur while programming. Therefore, knowing how to write shell
scripts will make you a better programmer. Once we are done with shell
scripting, we will study the design principles that underly shell scripting,
known as \emph{combinators}, and see that they are applicable to a wide variety
of problems.

\section{Shell Scripting}

- We've seen basics, e.g., to change directory, remove files, etc.

- Many more commands: cat, sort, uniq, cut, grep, paste, head, tail

- Redirecting standard out, e.g., ls > foo/bar

- Redirecting standard in, e.g.,

  sort < /filename

- Pipes

  sort file > out; head -n 5 out

   OR

  sort file | head -n 5


- Command-line arguments vs. standard in

- Example:

  - Getting student participation IDs out of a moodle.csv

    cut -f 1 -d , | cut -f 2 -d ' '

  - Creating directories for each student

    cut -f 1 -d , | cut -f 2 -d ' ' | xargs mkdir

  - Compile everyone's project

    ls | xargs (cd {}; sbt build)

  - Tackle errors:

    ls | xargs (cd {}; sbt build || echo "Error building project")

\section{Programming with Combinators}

- define a class for operations String => List[String] and a
  sequencing >>> operation
  val numHi = words <input> >> filter (x => x == "hi") >> length

- Why not just use objects? Answer: this way we can define new operations

- Introduce the split combinator

\chapter{Combinators}
\savepdf{combinators-errors-callbacks}

- Recap: the String => List[String] combinators

- Combining functions that produce errors

- Combinators for callbacks

\chapter{Stack Machines}
\savepdf{stack-machines}

In this chapter, we discuss some of the ideas used to build the Scala compiler and the Java virtual machine.
Most of the time, you will not have to think about these kinds of low-level details.
However, to write performance-critical code or to debug low-level
errors, you will need to know this kind of work.


\section{Programs as Trees}

These are examples of arithmetic expressions:

\begin{itemize}

\item \verb|2 * 4|

\item \verb|1 + 2 + 3|

\item \verb|5 * 4 * 2|

\item \verb|1 + 2 * 3|

\end{itemize}
%

We all know how to evaluate these expressions in our heads. But, when we do,
we resolve several ambiguities. For example, should we evaluate \verb|1 + 2 * 3|
like this:

\begin{tabular}{ll}
& \verb|1 + 2 * 3| \\
$=$ & \verb|(1 + 2) * 3| \\
$=$ & \verb|3 * 3| \\
$=$ & \verb|9|
\end{tabular}

\noindent or like this:

\begin{tabular}{ll}
& \verb|1 + 2 * 3| \\
$=$ & \verb|1 + (2 * 3)| \\
$=$ & \verb|1 + 6| \\
$=$ & \verb|7|
\end{tabular}

The latter is the convention in mathematics, but it is an arbitrary choice.
A programming language could adopt either convention or adopt a completely
different notation. For example, the following three programs, written
in three different languages, are trying to express the same thing:
%
\begin{itemize}

\item \verb|1 + 2| infix syntax, in Scala, which (mostly) adopts the notation of
   conventional mathematics

\item \verb|(+ 1 2)| parenthesized prefix syntax, from the Scheme language

\item \verb|1 2 +| postfix syntax, from the Forth language

\end{itemize}
%
These three \emph{concrete syntaxes} are very different, but all mean
``the sum of the number three and the number four''.

Concrete syntax is important, because it is the human-computer interface to a
programming language. It is easy to find acrimonious debates on the Web about
the virtues of Python's indentation-sensitive syntax, whether semicolons should
be optional in JavaScript, how C code should be indented, and so on. However,
we can think of expressions more abstractly as \emph{abstract syntax trees}.  

Scala's case classes make it easy to define a type for abstract syntax trees
of arithmetic expressions:
%
\begin{scalacode}
sealed trait Expr
case class Num(n: Int) extends Expr
case class Add(e1: Expr, e2: Expr) extends Expr
case class Sub(e1: Expr, e2: Expr) extends Expr
case class Mul(e1: Expr, e2: Expr) extends Expr
\end{scalacode}

Here are some examples of abstract arithmetic expressions and their
concrete representations (written in normal, mathematical notation):

\begin{tabular}{l|l}
Concrete Syntax & Abstract Syntax \\
\hline
\texttt{1 + 2 + 3} & \lstinline[language=scala]|Add (Add (Num(1), Num(2)), Num(3))| \\
\texttt{1 + 2 * 3} & \lstinline[language=scala]|Add (Num(1), Mul (Num(2), Num(3)))| \\
\texttt{(1 + 2) / 3} & \lstinline[language=scala]|Div (Add (Num(1), Num(2)), Num(3))|
\end{tabular}

The Scala compiler uses a much larger and more complex type to represent Scala
abstract syntax trees, but it follows the same principle described here. You can
use some low-level Scala APIs to take a string and turn it into an abstract syntax
tree and even evaluate the tree, as shown in \cref{scala_ast}.

\begin{figure}
  \consolefile{includes/reify.txt}
  \caption{Printing a Scala abstract syntax tree.}
  \label{scala_ast}
  \end{figure}

Back to our arithmetic expression trees, we can write a simple recursive
function evaluate trees to values as follows:

\begin{scalacode}
def eval(e: Expr): Int = e match {
  case Num(n) => n
  case Add(e1, e2) => eval(e1) + eval(e2)
  case Sub(e1, e2) => eval(e1) - eval(e2)
  case Mul(e1, e2) => eval(e1) * eval(e2)
  case Div(e1, e2) => eval(e1) / eval(e2)
}
\end{scalacode}

You could evaluate Scala programs by writing a recursive evaluation
function too. However, that's not what happens on your machines. To
understand how Scala is run, it will help to first examine how Java
programs are run.

\section{Stacks of Instructions}

\begin{figure}
\begin{minipage}{0.45\textwidth}
\begin{javacode}
class Simple {

  static int factorial(int n, int result) {
    if (n == 0) {
      return result;
    }
    else {
      return factorial(n - 1, result * n);
    }
  }

  public static void main(String[] args) {
    System.out.println("Hello, world!");
     System.out.println(factorial(5, 1));
  }

}
\end{javacode}
\caption{Java source code.}
\label{simplejava}
\end{minipage}
~\vrule~
\begin{minipage}{0.45\textwidth}
\begin{console}
class Simple {
  Simple();
    Code:
       0: aload_0
       1: invokespecial #1
       4: return

  static int factorial(int, int);
    Code:
       0: iload_0
       1: ifne          6
       4: iload_1
       5: ireturn
       6: iload_0
       7: iconst_1
       8: isub
       9: iload_1
      10: iload_0
      11: imul
      12: invokestatic  #2
      15: ireturn

  public static void main(java.lang.String[]);
    Code:
       0: getstatic     #3
       3: ldc           #4
       5: invokevirtual #5
       8: getstatic     #3
      11: iconst_5
      12: iconst_1
      13: invokestatic  #2
      16: invokevirtual #6
      19: return
}
\end{console}
\caption{Java bytecode.}
\label{javabytecode}
\end{minipage}
\caption{Disassembling Java.}
\end{figure}

Suppose you want to run the Java program in \cref{simplejava}. You
can't simply run it directly. Instead, you need to first
\emph{compile} it:
\begin{console}
javac Simple.java
\end{console}
which produces a file called \verb|Simple.class|. You can run this file by starting
the \emph{Java Virtual Machine} (JVM):
\begin{console}
java Simple
\end{console}
The latter command only uses \verb|Simple.class|. You can delete \verb|Simple.java| and
you'll still be able to run the program. Let's look into what the \verb|javac| and
\verb|java| commands do, before we return to Scala. Even if you've never used \verb|java| and \verb|javac| directly, and you've
only ever used Java within an IDE such as Eclipse or IDEA, you should know that these
IDEs run these commands under the hood.

The command \verb|javac| is a \emph{compiler} that translate Java source code to
\emph{byte-code}, which is stored in \verb|.class| files. Byte-code is not designed
to be human-readable, which is why \verb|.class| are in a binary format that will appear
are gibberish in a text editor. However, you can \emph{disassemble} the byte-code
and print it in a more human-readable format, by running \verb|javap -c Simple.class|.
This command produces the output shown in \cref{javabytecode}.

Observe that all variables in the original program
have been erased. Instead of using variables, Java byte-code uses a stack of values
and a list of instructions, where the instructions pop and push the values on the stack.

\begin{figure}
\begin{scalacode}
sealed trait Instruction
case class INum(n: Int) extends Instruction
case class IAdd() extends Instruction
case class IMul() extends Instruction
case class ISub() extends Instruction

def eval(code: List[Instruction], stack: List[Int]): List[Int] = (e, stack) match {
  case (INum(n), stack) => n :: stack
  case (IAdd(), n1 :: n2 :: stack) => n1 + n2 :: stack
  case (ISub(), n1 :: n2 :: stack) => n1 - n2 :: stack
  ...
}
\end{scalacode}
\caption{A stack-based evaluator for a list of arithmetic instructions.}
\end{figure}

Returning to arithmetic expressions, we can write a stack machine for arithmetic
instructions as shown in
[REF]. The command \verb|java Simple| runs
a (very sophisticated) stack machine that is based on the same basic principle illustrated
in this figure.

The following table shows some arithmetic expressions and equivalent 
instruction sequences

\begin{tabular}{l|l|l}
Concrete Syntax & Abstract Syntax & Instructions \\
\hline
\verb|1 + 2 + 3| & \lstinline[language=scala]|Add (Add (Num(1), Num(2)), Num(3))|
& \lstinline|List(INum(1), INum(2), IAdd(), INum(3), IAdd())| \\
\verb|1 + 2 * 3| & \lstinline[language=scala]|Add (Num(1), Mul (Num(2), Num(3)))|
& \lstinline|List(INum(1), INum(2), INum(3), IMul(), IAdd())| \\
\verb|(1 + 2) / 3| & \lstinline[language=scala]|Div (Add (Num(1), Num(2)), Num(3))|
& \lstinline|List(INum(1), INum(2), IAdd(), INum(3), IDiv())|
\end{tabular}

\begin{figure}
\begin{scalacode}
def compile(e: Expr): List[Instruction] = e match {
  case Num(n) => List(INum(n))
  case Add(e1, e2) => compile(e1) ++ compile(e2) ++ List(IAdd())
  case Sub(e1, e2) => compile(e1) ++ compile(e2) ++ List(ISub())
  case Mul(e1, e2) => compile(e1) ++ compile(e2) ++ List(IMul())
}
\end{scalacode}
\caption{A compiler from arithmetic expressions to arithmetic instructions.}
\label{arithcompiler}
\end{figure}

The command \verb|javac Simple.java| performs the kinds of translations shown
above automatically. The code in \cref{arithcompiler} compiles arithmetic expressions
to instructions using the same principles that \verb|javac| uses.

The Scala compiler translates Scala source code to byte-code for the Java Virtual Machine
in a similar way. The compiler is more complicated, because Scala is actually much more
complex than Java. However, once the \verb|.class| files have been generated, Scala
programs run in the same manner at Java programs.

Although we use \sbt{} in this course, it is also a simple frontend
for the Scala compiler (\verb|scalac|). You can run \verb|scalac| on
Scala source code to produce \verb|.class| files and then disassemble
or run these files in exactly the same way as Java code. In your
\sbt{} projects, there is a directory called
\verb|target/scala-2.11/classes| that has all the class files
generated from your program. \sbt{}, like any other IDE, puts
\verb|.class| files in a separate directory so that they don't clutter
your code.

\include{gc}

\include{fundata_hw}

\chapter{Object-Oriented vs. Functional Programming}
\savepdf{expression-problem}

\section{Reading}

Programming in Scala, Chapter 6.1---6.11.\footnote{\url{http://www.artima.com/pins1ed/}}

\section{Object Oriented Scala}

\begin{figure}
\begin{minipage}{0.45\textwidth}
\begin{scalacode}
class Point(x: Double, y: Double) {

  def getX() = this.x

  def getY() = this.y

  def add(other: Point) = {
    new Point(this.x + other.getX(),
              this.y + other.getY())
  }

  def magnitude() = math.sqrt(x * x + y + y)
}
\end{scalacode}
\caption{A class for points.}\label{pointclass}
\end{minipage}
\quad\vrule\quad
\begin{minipage}{0.45\textwidth}
\begin{javacode}
class Point {
  private Double x;
  private Double y;

  public Point(Double x, Double y) {
    this.x = x;
    this.y = y;
  }

  public Double getX() {
    return this.x;
  }

  public Double getY() {
    return this.y;
  }

  public Point add(Point other) {
    return new Point(this.x + other.getX(),
                     this.y + other.getY());
  }

  public Double magnitude() = {
    return math.sqrt(x * x + y + y);
  }
}
\end{javacode}
\caption{A similar class in Java.}
\end{minipage}
\end{figure}

Although we've focused on functional programming so far, Scala supports
Java-style object-oriented programming too. For example, \cref{pointclass}
defines a \scalainline{Point} class (not a case class) with two private
fields\footnote{Recall that case class fields are public, which
is what allows us to use pattern matching. We cannot pattern match on ordinary classes,
even if their fields are public.} and four methods.

Notice that we didn't have to declare a constructor for \scalainline{Point}.
Scala creates a constructor automatically that initializes the values of
\scalainline{x} and \scalainline{y}.

We could make the fields public by writing:
\begin{scalacode}
class Point(val x: Double, val y: Double) { ... }
\end{scalacode}

We can make methods private by writing:
\begin{scalacode}
private def add(other: Point) = { ... }
\end{scalacode}

If we wanted to compute the value of a field, e.g., if we wanted the magnitude
to be a field whose value is calculated at construction, we could write:
%
\begin{scalacode}
class Point(x: Double, y: Double) {

  val magnitute = math.sqrt(x * x + y + y)

  ...
}
\end{scalacode}

In fact, you can think of the entire body of the class as the constructor.
For example, the following code prints each time a new point is constructed:

%
\begin{scalacode}
class Point(x: Double, y: Double) {

  println(s"Created a new Point with x = $x and y = $y.")

  ...
}
\end{scalacode}

These and other features of Scala's classes are described in depth in the
assigned reading. However, note that they are mostly syntactic differences.
The semantics of classes in Scala and Java are exactly the same (for now).

\section{Converting Functional Code to Object-Oriented Code}

\begin{figure}
\begin{scalacode}
sealed trait Shape
case class Circle(radius: Double) extends Shape // Center of the circle is (0, 0)
case class Square(side: Double) extends Shape // Bottom-left corner of the square is (0, 0)

object Shape {
  def inShape(s: Shape, x: Double, y: Double) = s match {
    case Circle(radius) => math.sqrt(x * x + y * y) <= radius
    case Square(side) => x >= 0 && x <= side && y >= 0 && y <= side
  }
}
\end{scalacode}
\caption{A Functional Shape Library}
\label{fshapes1}
\end{figure}

\Cref{fshapes1} shows a library for shapes, written in a functional style.
The library defines a sealed trait called \scalainline{Shape} and two
constructors for \scalainline{Circle} and \scalainline{Square} using
case classes. The library defines a function called \scalainline{inShape}
to test whether an $(x,y)$ coordinate is within the given shape. The function
uses pattern-matching to handle the two cases for circles and squares.

\begin{figure}
\begin{scalacode}
trait Shape {
  def inShape(x: Double, y: Double) = {
    if (this.isInstanceOf[Circle]) {
      math.sqrt(x * x + y * y) <= this.asInstanceOf[Circle].radius
    }
    else if (this.isInstanceOf[Square]) {
      val side = this.asInstanceOf[Square].side
      x >= 0 && x <= side && y >= 0 && y <= side
    }
    else {
      sys.error("unknown shape!")
    }
  }
}
class Circle(val radius: Double) extends Shape
class Square(val side: Double) extends Shape
\end{scalacode}
\caption{An object-oriented shape library: do not write code like this.}
\label{jshapesbad}
\end{figure}

\paragraph{Object-Oriented Refactoring Done Badly} To refactor this code into an
object-oriented style, we need to stop using case classes and pattern matching
and turn \scalainline{inShape} into a method instead of a function.
A literal translation of the code would be to turn the case classes
into classes with public fields, move the method into the \scalainline{Shape}
trait,\footnote{Think of this trait as an abstract class in Java. Traits are actually more powerful, but we'll get to that later.}, and rewrite the body to
use type-tests and casts.
 \Cref{jshapesbad} shows this refactoring of the
code.

\begin{notation}
In Scala:
\begin{scalacode}
this.instanceOf[Circle]
\end{scalacode}
is the same as
\javainline{this instanceof Circle} in Java.

In Scala:
\begin{scalacode}
this.asInstanceOf[Square]
\end{scalacode}
is the same as \javainline{(Square)this} in Java.
\end{notation}

You should already know that this is terrible code! It is an extremely bad idea
to use \javainline{instanceof} and type-casts in Java (and in Scala) because it
\emph{defeats the type system}. The point of the type system in Java (and Scala)
is to help you catch errors. When you write code like this, the type system
can't help you.
\textbf{You are not permitted to use \scalainline{isInstanceOf} and \scalainline{asInstanceOf},
since writing high-quality code is a major goal of this class.}

\paragraph{Object Oriented Refactoring Done Right}

\begin{figure}
\begin{scalacode}
trait Shape {
  def inShape(x: Double, y: Double): Boolean
}

class Circle(radius: Double) extends Shape {
   def inShape(x: Double, y: Double) = math.sqrt(x * x + y * y) <= radius
}

class Square(side: Double) extends Shape {
  def inShape(x: Double, y: Double) = x >= 0 && x <= side && y >= 0 && y <= side
}
\end{scalacode}
\caption{An object-oriented shape library done well.}
\label{jshapes1}
\end{figure}

The right way to build an object-oriented shape library is shown in \Cref{jshapes1}.
We've made
\scalainline{inShape} an abstract method in the trait
\scalainline{Shape}\footnote{Now, we're using the trait like an interface
in Java.} and each shape provides
an implementation. Note that we are not using any type-casts or type-tests and
that the shapes' fields are private, which is typically good practice in
object-oriented code. \textbf{Most significantly,} notice that the method
bodies are exactly the same as the cases in the function from \cref{fshapes1}.

Functional code that uses pattern matching can be converted to equivalent
object-oriented code by following this recipe:

\begin{enumerate}

  \item Functions that use pattern-matching become abstract methods on the type
  on which they pattern match.

  i.e., a function that looks like this:

  \begin{scalacode}
  def f(x: T, args ...): R = x match { ... }
  \end{scalacode}

  Becomes an abstract method:

  \begin{scalacode}
  trait T {
    def f(args ...): R
  }
  \end{scalacode}

  \begin{think}
  Notice that the \emph{function} $f$ takes an argument caled $x$, but
  the \emph{method} $f$ does not. Why not?
  \end{think}

  \item Each case in a function turns into an implementation of the abstract
  method in the corresponding class.

  i.e., a function that has a case like this:

  \begin{scalacode}
  def f(x: T, args ...): R = x match {
    case C(fields ...) => body
  }
  \end{scalacode}

  Becomes an implementation of the method $f$:

  \begin{scalacode}
  class C(fields ...) extends T {

    def f(args ...): R = body
  }
  \end{scalacode}

\end{enumerate}

\begin{think}
A key feature of pattern-matching is the \emph{exhuastivity check}. If
we forget to write a case in a function, Scala complains that pattern-matching
may not be exhaustive and actually lists all the cases that we have not
handled. Since we are no longer using pattern-matching, we no longer rely
on exhuastivity-checking. Is this okay? How do similar bugs manifest in
object-oriented code and can the Scala compiler catch them?
\end{think}

\section{Using Libraries}

Libraries and APIs are an important part of programming. Without libraries,
we'd be writing a lot of basic functionality from scratch. The Scala
and Java \emph{standard libraries} define a variety of useful data structures
and programming patterns and are available to all code that you write.
SBT makes it easy to use libraries from the Web.

For example,
\href{https://lihaoyi.github.io/upickle-pprint/upickle/}{uPickle} is a
handy library for converting Scala data structures to JSON, which is
often used in systems where programs in several languages need to communicate.
To use uPickle in a project, create a file called \texttt{build.sbt} in the
root directory of the project and add the line:
%
\begin{scalacode}
libraryDependencies += "com.lihaoyi" %% "upickle" % "0.3.8"
\end{scalacode}
%
After restarting SBT, you can use uPickle as documented on its website.
\href{http://mvnrepository.com}{Maven Central} has thousands of libraries
that you can use in a similar way.

\section{Writing Libraries}

Any SBT project can be packaged into a library by simply giving it
a name, organization, and version number in the \texttt{build.sbt} file.
For example, we could use the following \texttt{build.sbt} for our
functional shape library:

\begin{scalacode}
name := "fshapes"
organization := "compsci220"
version := "1.0"
\end{scalacode}

Before publishing a library on the Web, it is a good idea to test it by
publishing it locally. We can run \texttt{sbt publish-local} to do so.

When it completes, we can test the library by using it from another
project. To do so, we'd have to add this line to its \texttt{build.sbt}
file:
\begin{scalacode}
libraryDependencies += "compsci220" %% "fshapes" % "1.0"
\end{scalacode}

It takes a little more work to publish libararies online.
If you want to learn how to do so, we recommend using
\href{https://github.com/softprops/bintray-sbt}{Bintray SBT}. (It is a lot
simpler than using Maven Central directly.)

\section{Reusing and Extending Libraries}

Imagine that we wanted to use a library of shapes and we'd found both the functional
and object-oriented shape library we wrote earlier on the Web. We can use
either one by editing the \texttt{build.sbt} file:

\begin{scalacode}
libraryDependencies += "compsci220" %% "fshapes" % "1.0"
\end{scalacode}
or
\begin{scalacode}
libraryDependencies += "compsci220" %% "jshapes" % "1.0"
\end{scalacode}

So, which one should we use? Recall that both libraries implement the same
features: only two shapes and just one method/function to calculate if
a point is within a shape. So, perhaps the choice is just a matter of taste:
i.e., whether we prefer to think functionally or in an object-oriented way.

But, let's consider the choices more carefully. In particular, suppose neither
library was quite right and we needed to extend them in some way. In fact,
our libraries are so small, it's easy to imagine that we'd want a larger
variety of shapes and other functions or methods. So, let's see what it
takes to extend each library.

Remember that these are meant to be libraries that someone else wrote that
we are re-using in our own project. So, we do not want to read or modify their code. (Imagine that
the library has millions of lines of code). In fact, it may be a closed-source
library, so the original code may not even be available for us to read or modify.
So, imagine that all we have to work with is the Scaladoc and some example code.

We'll consider two kinds of extensions:

\begin{itemize}

  \item \emph{Extending the data model} by adding support for rectangles.

  \item \emph{Extending the feature set} by adding a routine to
  double the size of a shape.

\end{itemize}

\subsection{Extending the Functional Shape Library}

It is easy to write a new function to double the size of a shape. In our
own project, we could simply write:

\begin{scalacode}
object FunctionalExtension {
  def growShape(s: Shape): Shape = s match {
    case Circle(radius) => Circle(radius * 2)
    case Square(side) => Square(side * 2)
  }
}
\end{scalacode}

Now, let's add support for rectangles. The obvious thing to do is write:
\begin{scalacode}
import fshapes._
case class Rectangle(width: Double, height: Double) extends Shape
\end{scalacode}
But, this code does not type-check, because \scalainline{Shape} was \emph{sealed}
earlier. This may appear annoying now, but its a good thing that it doesn't work.
Remember that the \scalainline{inShape} function in the library doesn't
have a case for \scalainline{Rectangle}. How could it? Someone else wrote it
and didn't anticipate that we wanted support for rectangles. Therefore, by
preventing us from extending \scalainline{Shape}, Scala is ensuring that
the library code doesn't fail. (i.e., Scala is ensuring that the exhuastivity
analysis it did on the library remains valid.)

\begin{figure}
\begin{scalacode}
sealed trait ShapeExt
case class Rectangle(width: Double, height: Double) extends ShapeExt
case class OtherShape(s: Shape) extends ShapeExt

object FunctionalExtension {
  def growShape(s: ShapeExt): ShapeExt = s match {
    case OtherShape(Circle(radius)) => OtherShape(Circle(radius * 2))
    case OtherShape(Square(side)) => OtherShape(Square(side * 2))
    case Rectangle(width, height) => Rectangle(width * 2, height * 2)
  }

  def inShape(s: ShapeExt, x: Double, y: Double): Boolean = s match {
    case OtherShape(shape) => Shape.inShape(shape, x, y)
    case Rectangle(width, height) => x >= 0 && y >= 0 && x <= width && y <= height
  }
}
\end{scalacode}
\caption{Extending fshapes with rectangles.}
\label{fshapesext}
\end{figure}

However, all is not lost. We can add support for rectangles by \emph{wrapping}
the previously defined \scalainline{Shape} type in a new type. \Cref{fshapesext}
shows how to do this. The idea is quite straightforward. We simply
have to define a new \scalainline{inShape} function that handles rectangles
and invokes the original \scalainline{inShape} function on other shapes.

Now, imagine doing this on a large library with hundreds of functions. It would
be extremely tiresome. But, this illustrates a \emph{fundamental limitation of
functional programming}: it is easy to extends a library by adding new
functions, but it is hard to extend a library to support new kinds of data.

\begin{think}
Imagine that the original library had a \scalainline{growShape} function
and that we were trying to write the \scalainline{inShape} function.
Would wrapping still work?

Suppose the original library had a constructor for creating composite
shapes:
\begin{scalacode}
case class Overlay(top: Shape, bottom: Shape) extends Shape
\end{scalacode}
Would wrapping still work?
\end{think}

\subsection{Extending the Object-Oriented Shape Library}

It is easy to extend the object-oriented library with rectangles. All we
have to do is create a new class that extends \scalainline{Shape}
and define its \scalainline{inShape} method:
%
\begin{scalacode}
class Rectangle(width: Double, height: Double) extends Shape {
  def inShape(x: Double, y: Double): Boolean = x >= 0 && y >= 0 && x <= width && y <= height
}
\end{scalacode}

Now, let's try to add a feature to double the size of shapes. The object-oriented
way is to have a \scalainline{growShape} method in the \scalainline{Shape}
trait. But, we can't do that because \scalainline{Shape} was defined in
a library that someone else wrote (and we don't have the source code).

\begin{figure}
\begin{scalacode}
object JShapesExtension {
  def growShape(shape: Shape) {
    if (this.isInstanceOf[Circle]) {
      new Circle(this.asInstanceOf[Circle].radius * 2)
    }
    else if (this.isInstanceOf[Square]) {
      new Square(this.asInstanceOf[Square].side * 2)
    }
    else if (this.isInstanceOf[Rectangle]) {
      new Rectangle(this.asInstanceOf[Rectangle].width * 2, this.asInstanceOf[Rectangle].height * 2)
    }
    else {
      sys.error("unknown shape!")
    }
  }
}
\end{scalacode}
\caption{Using type-tests and type-casts to grow shows. Does not compile.}
\label{jshapesext1}
\end{figure}

Instead, we could write a \scalainline{growShape} function using
type-tests and type-casts, as shown in \cref{jshapesext1}. We've already
discussed why this is terrible code. Moreover, it has a simpler problem: it
does not compile.

\begin{think}
Why doesn't the code in \cref{jshapesext1} compile?
\end{think}

\begin{figure}
\begin{scalacode}
trait Growable {
  def growShape(): Shape
}

class MyCircle(radius: Double) extends Circle(radius) with Growable {
  def growShape(): MyCircle = new MyCircle(radius * 2)
}

class MySquare(side: Double) extends Square(side) with Growable {
  def growShape(): MySquare = new MySquare(side * 2)
}

class Rectangle(width: Double, height: Double) extends Shape with Growable {
  def inShape(x: Double, y: Double: Boolean = x >= 0 && y >= 0 && x <= width && y <= height

  def growShape(): Rectangle = new Rectangle(width * 2, height * 2)
}
\end{scalacode}
\caption{Using inheritance to extend the library.}
\label{jshapesext2}
\end{figure}

An alternative approach uses inheritance, as shown
in \cref{jshapesext2}. The key idea is to create  new types for circles
and squares that inherit from the existing libraries.
Again, imagine doing this at scale: if the library had dozens of objects
and dozens of methods, this would be extremely tedious.
 This illustrates a \emph{fundamental limitation of
object-oriented programming}: it is easy to extends a library with new
kinds of data (new classes), but it is hard to extend a library to support
new methods.

\begin{think}
Suppose the original library had a class that represented composite
shapes:
\begin{scalacode}
class Overlay(top: Shape, bottom: Shape) extends Shape { ... }
\end{scalacode}
Would wrapping work?
\end{think}

\section{Perspective}

These two examples illustrate that functional
and object-oriented styles involve fundamental tradeoffs when it comes
to extending and re-using code. There are certain kinds of extensions
that can be done in object-oriented style that cannot be done in
functional style, and vice versa.  It is misguided to argue that
one style is better than the other. What matters is how you expect your code
to be used (and extended). One could argue that a language that forces you to
pick one style of programming limits the kinds of code re-use that are possible.

\chapter{Subtyping}
\savepdf{subtyping}

\section{Reading}

Programming in Scala, Chapters 12 and 19.\footnote{\url{http://www.artima.com/pins1ed/}}

\section{The Singleton Pattern}

\begin{figure}
\begin{javacode}
public class Singleton {
  private static Singleton instance = null;

  private Singleton() { }

  public static Singleton getInstance() {
    if(instance == null) {
      instance = new ClassicSingleton();
    }
    return instance;
  }

  void myMethod() {
    System.out.println("It works")
  }

}
\end{javacode}
\caption{The Singleton Pattern in Java}
\label{javasingleton}
\end{figure}

At times, it is often desirable to only have a single instance of a particular
class. For example, if you have a class that lets you read input from the
user, it doesn't make sense to have two instances, since the user just has
one keyboard. You can create a singleton object in Java by following the
design pattern in \cref{javasingleton}. The only instance of \javainline{Singleton}
that can exist is the one stored in the private field. (Notice that the constructor
is private.) The only way to get
the singleton is by calling the \scalainline{Singleton.getInstance} method.

Here is the equivalent in Scala:

\begin{scalacode}
object Singleton {
  def myMethod() = println("It works")
}
\end{scalacode}

So, all the top-level functions we've created so far (in class and in
assignment) can be thought of as methods of singleton objects.

\section{Case Objects}

We've seen several examples of case classes that take no arguments. For example,
to represent binary trees with values at nodes (and not at the leaves), we could
write the following type:
%
\begin{scalacode}
sealed trait BinTree
case class BinTree(lhs: BinTree, value: Int, rhs: BinTree) extends BinTree
case class Leaf() extends BinTree
\end{scalacode}

However, we can also represent leaves using a \emph{case object}, which is essentially
a singleton that can be used in pattern-matching:
%
\begin{scalacode}
sealed trait BinTree
case class BinTree(lhs: BinTree, value: Int, rhs: BinTree) extends BinTree
case object Leaf extends BinTree
\end{scalacode}

Since \scalainline{Leaf} is an object and not a class, it \emph{cannot}
take any arguments, which why we can simply write \scalainline{Leaf} instead
of \scalainline{Leaf()}. Scala uses case objects extensively. For example,
\scalainline{Nil} and \scalainline{None} are case objects. If they
were case classes, we've have to write \scalainline{Nil()} and
\scalainline{None()} instead.

\section{Subtyping}

Subtyping in Scala is very similar to subtyping in Java.

\begin{notation}
We write $A <: B$ to mean $A$ is a subtype of $B$.
\end{notation}

The intuition behind subtyping is that a subtype always ``adds more features''
to its super-type, and doesn't ``subtract features''. Therefore, if $A <: B$,
then $A$ can be used in any context where $B$ is expected. The context simply
won't try to use the extra features of $A$. However, $B$ \emph{cannot}
be used in contexts where $A$ is expected, because the context may rely on
the ``added features'' of $A$ that $B$ does not provide.

For example, consider the following hierarchy of types, all of which
implement the \scalainline{Animal} trait\footnote{Think of a trait as an interface in Java. Traits
are actually more flexible, but we are only going to use them like interfaces for now.}
%
\begin{scalacode}
trait Animal {
  def sound(): String
}

class Dog extends Animal {
  def sound() = "woof"
  def bite() = "ouch"
}

class Poodle extends Dog {
  override def sound() = "yelp"
}

class Cat extends Animal {
  def sound() = "purr"
  def scratch() = "yow"
}
\end{scalacode}

A function that expects an \scalainline{Animal} can be applied to an object
of any class defined above. Similarly, a function that expects a \scalainline{Dog}
can be applied to a \scalainline{Dog} or a \scalainline{Poodle}, but not to a
\scalainline{Cat}. For example, the following function takes dogs and makes
them bite:
\begin{scalacode}
def dontBite(x: Dog) = {
  x.bite()
}
\end{scalacode}

The expression \scalainline{dontBite(new Cat())} will not type-check, which
is good, because cats don't have a \scalainline{bite} method.

Given the traits and types defined above, we can say that:
\begin{itemize}

  \item \scalainline{Dog <: Animal} because \scalainline{Dog extends Animal}

  \item \scalainline{Poodle <: Dog} because \scalainline{Poodle extends Dog}

  \item \scalainline{Cat <: Animal} because \scalainline{Cat extends Animal}

  \item \scalainline{Poodle <: Animal} because \scalainline{Poodle <: Dog} and
  \scalainline{Dog <: Animal} (subtyping is transitive),

  \item \scalainline{X <: X} for all $X$ (subtyping is reflexive).

\end{itemize}
%
In addition, scala has two special types:
%
\begin{itemize}

  \item \scalainline{X <: Any} for all types X.

  \item \scalainline{Nothing <: X} for all types X.

\end{itemize}

A peculiar property of \scalainline{Nothing} is that
\emph{there are no values with type} \scalainline{Nothing}!
It may seem pointless to have a type with no values. For example, the following
function cannot be applied to anything (not even to \scalainline{null}):
\begin{scalacode}
def useless(x: Nothing): Unit = {
  println("Cannot call me")
}
\end{scalacode}

But, we'll see why \scalainline{Nothing} is useful in a moment.

\section{Generics and Subtyping}

\begin{figure}
\begin{subfigure}[b]{0.26\textwidth}
\begin{scalacode}
def useDog(c: C[Dog]) = {
  c.get().bite()
}

useDog(new C(new Cat()))
\end{scalacode}
\caption{Cats can't bite.}
\label{catdog1}
\end{subfigure}
~\vrule~
\begin{subfigure}[b]{0.33\textwidth}
\begin{scalacode}
def useAnimal(c: C[Animal]) = {
  c.get().sound()
}

val c = new C[Dog](new Dog())
useAnimal(c)
\end{scalacode}
\label{catdog2}
\caption{Scala is being conservative.}
\end{subfigure}
~\vrule~
\begin{subfigure}[b]{0.31\textwidth}
\begin{scalacode}
def useAnimal2(c: C[Animal]) = {
  c.set(new Cat())
  c.get().sound()
}

val c = new C[Dog](new Dog())
useAnimal2(c)
c.get().bite()
\end{scalacode}
\label{catdog3}
\caption{Sneaky function confuses our code.}
\end{subfigure}
\caption{None of these programs type-check.}
\end{figure}

Subtyping becomes more complicated when we working with generics types, such
as lists, sets, or any other container type. To illustrate, we'll work
with the following generic type, which is the simplest possible container:
%
\begin{scalacode}
class C[T](private var x: T) {
  def get(): T = x
  def set(newX: T): Unit = x = newX
}

val c1: C[Dog] = new C(new Dog)
c1.set(new Poodle)
\end{scalacode}

Unsurprisingly, we can't store cats in \scalainline{c1}. If we did, a function
that consumes a container with a dog, might try to \scalainline{.get} the
dog and call the \scalainline{bite} method, which cats don't have.
Therefore, the code in \cref{catdog1} does not type-check.
However, since \scalainline{Dog <: Animal}, can we send a dog-container
to a function that expects an animal container. For example, \cref{catdog2}
appears to be safe. Unfortunately, this code does not type-check either. Although this particular example
is safe, consider the variation in \cref{catdog3}.

The problem above is that \scalainline{useAnimal2} sneakily stores a cat in
the container. After the function returns, \scalainline{c.get} would produce
a cat even though the type indicates that it should produce a dog.
Therefore, the Scala type-checker does not allow this program to type-check.

Unfortunately, \cref{catdog2} (which was safe) does not type-check either, just so that
this kind of unsafe example can be ruled out. Individual methods and functions
are type-checked only once. Similarly, when a function or method call is type-checked,
the body of the function is not re-examined.

\section{Variance}

However, lists and other immutable data structures in Scala are not constrained
this way. For example, the following code does type-check:

\begin{scalacode}
def useAnimals(alist: List[Animal]) = {
  alist.map(animal => animal.sound()).mkString(", ")
}

val alist: List[Cat] = List(new Cat(), new Cat())
useAnimals(alist)
\end{scalacode}

The reason this works is because there are no methods on lists to update
their contents. The problem with our \scalainline{Container[T]} class is
that it writes to \scalainline{T}-typed values. However, if we had a functional
container class, we can use a \emph{covariance annotation} to indicate
that \scalainline{T}-typed values are never updated.

\begin{scalacode}
class Container[+T](private val x: T) {
  def get(): T = x
}
\end{scalacode}

The \scalainline{+T} annotation indicates \scalainline{Container[A] <:
Container[B]} when \scalainline{A <: B}. For this to be safe,
Scala ensures that \scalainline{T}-typed values are never updated
by the class.\footnote{Coavariance is actually more subtle than this. The reading discusses it in more depth, but you don't have to remember all the details.} (The class may have other kind of state, but it can't
update \scalainline{T}s.)

As a rule of thumb, almost any immutable data structure can be made
covariant, which makes it more flexible. E.g., we can a \scalainline{Set[Cat]}
where a \scalainline{Set[Animal]} is expected or a \scalainline{List[Dog]}
where a \scalainline{List[Animal]} is expected.

In fact, the list type in Scala is covariant:
%
\begin{scalacode}
sealed trait List[+A]
\end{scalacode}
Cons is easy to define as follows:
\begin{scalacode}
case class ::[A](head: A, tail: List[A]) extends List[A]
\end{scalacode}
However, the definition of \scalainline{Nil} is trickier. If it were a case-class,
we could write:
\begin{scalacode}
case class Nil[A]() extends List[A]
\end{scalacode}
However, recall that \scalainline{Nil} is a case-object. So, we may try to
write this:
\begin{scalacode}
case object Nil[A] extends List[A]
\end{scalacode}
However, objects can't have type parameters (or any parameters for that matter).

As discussed earlier, Scala has a special type \scalainline{Nothing} that has no values
and is the subtype of all other types: i.e.,
\scalainline{Nothing <: A}. Therefore, by covariance of lists, \scalainline{List[Nil] <: List[A]}, so
we can write:
\begin{scalacode}
case object Nil extends List[Nothing]
\end{scalacode}
Although there a no values of type \scalainline{Nothing}, an empty list of
of type \scalainline{List[A]} doesn't contain any values of type \scalainline{A}.
Therefore, the \scalainline{Nil} object can be given the type \scalainline{List[Nothing]}.

\chapter{Variance and Method Arguments}
\savepdf{variance-2}

\begin{instructor}

\section*{Lecture Outline}
\classtime{15}

\begin{enumerate}

  \item Recap:
\begin{itemize}
  
  \item The notation \scalainline{A <: B}.
  \item \emph{Invariance}: typically \scalainline{A <: B} does not imply that \scalainline{Container[A] <: Container[B]}, because the container may have a method that writes to a value of type A.
  \item \emph{Covariance}: If the class is annotated \scalainline{Container[+T]}, then the type-checker ensures we can't write to values of type \scalainline{T} within the class.
  \item Traits can take type parameters too, just like classes. When we extend a trait, we need to supply the type parameters.
  \item Bounded quantification: The type parameter\scalainline{C[A]} means that \scalainline{A} could be any type. We can write \scalainline{C[A <: B]} to restrict it to types that extend \scalainline{B}, which allows us to invoke \scalainline{B}-methods on values of type \scalainline{A}.
\end{itemize}

\item Define hierarchy with \lstinline|Dog| and \lstinline|Poodle|. Poodles should have a \lstinline|bite| method
  that dogs do not.

\item Define container of two objects \lstinline|class Two[+T](x: T, y: T)|, thus \lstinline|Two[A] <: Two[B]| if \lstinline|A <: B|.

\item Add functional update operations, \emph{but do not compile}.

\item This code fragment would go wrong:

\begin{lstlisting}
def storeDog[A <: Two[Dog]](x: A): A = x.update1(new Dog)
val twoPoodles = new Two[Poodle](new Poodle(), new Poodle())
val aPoodle = storeDog(twoPoodles).get1() // Produces a Dog, not a Poodle!
aPoodle.bite() // Crash! Dogs don't have a .bite() method.
\end{lstlisting}

\item The problem is that when a \lstinline|Two[A]| is treated as a
  \lstinline|Two[B]| (where A <: B), we can update the container to
  store a B, which breaks code that expects A-typed values.

\item Solution:

  \begin{lstlisting}
    def update1[S >: T](newX: T): Two[S] = new Two(newX, y)
  \end{lstlisting}

  Reason through the types when updating with a Dog or a Poodle.

\item The same problem exists with list-append.

\item A model of type-checking:

  \begin{itemize}

  \item Define AST for numbers, booleans, and let-binding (called EVal). Include pretty-printer.
  \item Define types: ints and bools
  \item Define a type-checker without an environment.
  \item Add the environment.     

  \end{itemize}

\end{enumerate}
\end{instructor}

\section{Variance and method arguments\classtime{20}}

Earlier, we wrote the simplest container we could imagine that only stored
a single value. The following container slightly more sophisticated, because
it can store two values:
\begin{scalacode}
class Two[+T](private val x: T, private val y: T) {
  def get1(): T = x
  def get2(): T = y
}
\end{scalacode}
This container uses a covariance annotation, so when \scalainline{A <: B},
we have \scalainline{Two[A] <: Two[B]}. Recall that the
intuition for subtyping is that \scalainline{Two[A]} can be used
wherever a \scalainline{Two[B]} is expected. Now, suppose we modify the class to
add functional update methods:
\begin{scalacode}
class Two[+T](private val x: T, private val y: T) {
  ...
  def update1(newX: T): Two[T] = new Two(newX, y)
  def update2(newY: T): Two[T] = new Two(x, newY)
}
\end{scalacode}
This is a natural operation on containers and we should be able to write it.
But, let's ensure that even with this operation, \scalainline{Two[A]} can
be used whenever a \scalainline{Two[B]} is expected.

Concretely, consider the following two classes:
\begin{scalacode}
class Dog {
  def makeSound(): String = "woof"
}

class Poodle extends Dog {
  def bite(): String = "nip"
}
\end{scalacode}

We should be able to use a \scalainline{Two[Poodle]} in all contexts where
a \scalainline{Two[Dog]} is expected.


Consider the following function, which simply updates a container to
store a \scalainline{Dog}:
\begin{scalacode}
def storeDog[A <: Two[Dog]](x: A): A = x.update1(new Dog)
\end{scalacode}
However, it uses bounded-quantification to any subtype of
\scalainline{Two[Dog]}. Therefore, we can apply it to a \scalainline{Poodle}
container and know that the result is still a \scalainline{Poodle}
container. Of course, this isn't true, since the function stores
a \scalainline{Dog}. Therefore, the following code goes wrong:
\begin{scalacode}
val twoPoodles = new Two[Poodle](new Poodle(), new Poodle())
val aPoodle = storeDog(twoPoodles).get1() // Produces a Dog, not a Poodle!
aPoodle.bite() // Crash! Dogs don't have a .bite() method.
\end{scalacode}

Naturally, Scala (and Java) won't allow this to happen. In general, when
a class has a covariant type parameter \scalainline{T}, its methods can
produce values of type \scalainline{T}, but methods' arguments cannot consume
values of type \scalainline{T} (because of the error described above). Therefore, the type-checker
will not allow us to write the update methods, because they use
a covariant type parameter as the type of a method argument.

\paragraph{A solution}
The problem with the code above is that when a \scalainline{Two[A]}
is treated as a \scalainline{Two[B]}, we can update the container to
store any \scalainline{B}-typed value, which then breaks code that expects
\scalainline{A}-typed values. Instead, we need to ensure that we can only store
subtypes of \scalainline{A} in the container. We can express this constraint
using bounded-quantification:

\begin{scalacode}
class Two[+T](private val x: T, private val y: T) {
  ...
  def update1[S >: T](newX: T): Two[S] = new Two(newX, y)
  def update2[S >: T](newY: T): Two[S] = new Two(x, newY)
}
\end{scalacode}
This version of the class does type-check.

If we have a Poodle-container:
\begin{scalacode}
val x = new Two[Poodle](new Poodle, new Poodle)
\end{scalacode}
And we update one of the poodles:
\begin{scalacode}
x.update1[Poodle](new Poodle)
\end{scalacode}
The type-parameter \scalainline{S} is bound to the type \scalainline{Poodle},
so the return type is \scalainline{Two[Poodle]}. However, we can also
update the the container with a \scalainline{Dog}:
\begin{scalacode}
x.update1[Dog](new Dog)
\end{scalacode}
However, in this case, the return type is \scalainline{Two[Dog]} (although one
of the dogs is a poodle).

\paragraph{Appending Lists}
A similar problem arises with list concatenation. Since lists are covariant,
they cannot have an append method with this type:
\begin{scalacode}
sealed trait List[A] {
  def append[A](other: List[A]): List[A] = ...
  ...
}
\end{scalacode}

However, we can use the same trick we used above to write an append
method with the following type:

\begin{scalacode}
sealed trait List[A] {
  def append[B :> A](other: List[B]): List[B] = alist match {
    case Nil => Nil
    case hd :: tl => hd :: tl.append(other)
  }
  ...
}
\end{scalacode}

\section{A Model of Type-Checking\classtime{40}}

\begin{figure}
\scalafile{includes/ScalaFragment.scala}
\caption{A subset of Scala expressions}\label{scalafragment}
\end{figure}

\begin{instructor}
This section is quite rough. I'd start by getting students to derive the expression data-structure from examples.
\end{instructor}


To understand generics, we've had to develop an intuition for how the Scala
type-checker works. A deep understanding of the Scala (or Java) type system is
beyond the scope of this class. However, it is important to have a reasonably
accurate mental model of type-checking to understand and debug type-errors.

\Cref{scalafragment} is a data structure that represents a fragment of
Scala expressions, including numbers, boolean, addition, the less-than operator,
if-expressions, and identifiers (bound with \scalainline{val}). Since
the only values in this fragment are integers and booleans, we can represent
types as follows:

\begin{scalacode}
sealed trait Type
case object TInt extends Type
case object TBool extends Type
\end{scalacode}

Ignoring identifiers, we can write a simple recursive function to type-check
programs in this fragment, as shown in \cref{simpletc}.

\begin{figure}
\begin{scalacode}
object TypeError extends RuntimeException("Type error")

object TypeChecker {

  def tc(expr: Expr): Type = expr match {
    case EInt(_) => TInt
    case EBool(_) => TBool
    case EAdd(e1, e2) => (tc(e1), tc(e2)) match {
      case (TInt, TInt) => TInt
      case _ => throw TypeError
    }
    case ELT(e1, e2) => (tc(e1), tc(e2)) match {
      case (TInt, TInt) => TBool
      case _ => throw TypeError
    }
    case EIf(e1, e2, e3) => (tc(e1), tc(e2), tc(e3)) match {
      case (TBool, t1, t2) if (t1 == t2) => t1
      case _ => throw TypeError
    }
  }
}
\end{scalacode}
\caption{Type-checking, excluding identifiers}\label{simpletc}
\end{figure}

Type-checking identifiers is a little trickier. When we see an identifier,
there is way to determine its type, unless we remember the type
of the expression it was bound to. Therefore, we need an auxiliary
parameter, known as the environment, to ``remember'' the type of identifiers
so that we can recall them later (\cref{tcid}).

\begin{figure}
\begin{scalacode}
object TypeChecker {
  def tc(env: Map[String, Type], expr: Expr): Type = expr match {
    case EInt(_) => TInt
    case EBool(_) => TBool
    case EAdd(e1, e2) => (tc(env, e1), tc(env, e2)) match {
      case (TInt, TInt) => TInt
      case _ => throw TypeError
    }
    case ELT(e1, e2) => (tc(env, e1), tc(env, e2)) match {
      case (TInt, TInt) => TBool
      case _ => throw TypeError
    }
    case EIf(e1, e2, e3) => (tc(env, e1), tc(env, e2), tc(env, e3)) match {
      case (TBool, t1, t2) if (t1 == t2) => t1
      case _ => throw TypeError
    }
    case EVal(x, e1, e2) => tc(env + (x -> tc(env, e1)), e2)
    case EId(x) => env.getOrElse(x, throw TypeError)
  }
}
\end{scalacode}
\caption{Type-checking identifiers.}\label{tcid}
\end{figure}

The actual Scala type-checker is vastly more complicated. But, it follows
this basic design.


\chapter{Lecture: Generators}
\savepdf{generators}

\section{The \emph{Same Fringe} Problem}



\begin{figure}
\begin{scalacode}
def fringe[A](t: BinTree[A]): List[A] = t match { case Leaf(x) =>
  List(x) case Node(lhs, rhs) => fringe(lhs) ++ fringe(rhs) }
\end{scalacode}
\caption{Recursively calculating the fringe of a binary tree.}
\label{fringeRec}
\end{figure}

Given a binary tree:

\begin{scalacode}
sealed trait BinTree[+A]
case class Node[A](lhs: BinTree[A], rhs: BinTree[A]) extends BinTree[A]
case class Leaf[A](x: A) extends BinTree[A]
\end{scalacode}

The \emph{fringe} of a binary tree are the values in left-to-right order. For
example, the fringe of the following tree:
\begin{scalacode}
val t1 = Node(Leaf(10), Node(Leaf(20), Leaf(40)))
\end{scalacode}
is $10$, $20$, and $40$, in that order. The \emph{same-fringe problem} is to write
a function to determine if two trees have the same fringe. For
example the following tree:
%
\begin{scalacode}
val t2 = Node(Node(Leaf(10), Leaf(20)), Leaf(40))
\end{scalacode}
Has the same fringe as \scalainline{t1}.

We can write a simple recursive function to calculate the fringe of a tree,
as shown in \cref{fringeRec}, so a simple solution to the same-fringe problem
is:
\begin{scalacode}
fringe(t1) == fringe(t2)
\end{scalacode}

But, this is not a very efficient solution:
\begin{itemize}

  \item If the trees are very large, we'll spend a lot of time appending
  lists, and

  \item If the fringes are different, we'll generate the entire fringe instead
  of terminating as soon as a difference is detected.

\end{itemize}

\section{An Imperative Solution}

\begin{figure}
\begin{scalacode}
class FringeIterator[A](tree: BinTree[A]) extends Iterator[A] {
  private val stack = collection.mutable.Stack(tree)
  def hasNext = stack.isEmpty
  def next() = {
    val top = stack.pop()
    top match {
      case Leaf(x) => x
      case Node(lhs, rhs) => { stack.push(rhs); stack.push(lhs); next() }
    }
  }
}

def sameFringe[A](t1: BinTree[A], t2: BinTree[A]): Boolean = {
  val iter1 = new FringeIterator(t1)
  val iter2 = new FringeIterator(t2)
  while (iter1.hasNext && iter2.hasNext) {
    val x = iter1.next
    val y = iter2.next
    if (x != y) {
      return false
    }
  }
  return !iter1.hasNext && !iter2.hasNext
}
\end{scalacode}
\caption{An imperative solution.}
\label{samefringe_imperative}
\end{figure}

A typical Java solution to this problem, which is straightforward to
reproduce in Scala, is to use an iterator. You've seen simple
iterators for lists and arrays before.  You can also write an iterator
that iterates over the fringe of a tree.  The key idea is this:
before we descend into the left-hand side of a node to generate its
fringe, we need to store the right-hand side of the node in a variable so that
we don't forget to generate its fringe. Since the tree may be arbitrarily deep, we
may need to remember a stack of nodes.

\begin{think}
What would happen if we used a queue of nodes?
\end{think}

An iterator that uses this idea is shown in \cref{samefringe_imperative} along with a
solution to the same-fringe problem that doesn't have the two issues we identified
above. An unusual feature of this solution is that it uses two iterators simultaneously
in a single loop.

What's interesting about this problem is that the solution seems to be fundamentally
imperative. In particular, each invocaation of \verb|.next| returns the next value, which
means that the iterators \emph{must} use mutable state internally. Is it possible to solve
this problem without state?

\begin{think}
  Try to solve the problem before proceeding further.
\end{think}

\section{By-Name Arguments}

\begin{figure}
\begin{scalacode}
def g(): Int = {
  println("Evaluating g")
  10
}

def f1(x: Int) = {
  println("Evaluating f1")
  x + 10
}
f1(g())
\end{scalacode}
\caption{Which line prints first?}
\label{evalorder1}
\end{figure}

When you apply a function in Scala (and in most other programming languages), the argument
of the function is first reduced to a value and then that value is passed to the function.
For example, in \scalainline{f(2 + 3)}, the expression \scalainline{2 + 3} is first reduced
to the value \scalainline{5} and then \scalainline{f(5)} is applied.

\begin{think}
  Is the statement above true? Can you think of a way to experimentally validate the
  claim that arguments are reduced to values before they are passed to functions?
 \end{think}

Consider the two functions in \cref{evalorder1} and the expression
\scalainline{f1(g())}.  If the argument is evaluated first, then
``Evaluating g'' will print before ``evaluating f''. Conversely, if
the expression \scalainline{g()} is passed to \scalainline{f1} unevaluated
and only evaluated when it is needed, then we'd expect the lines to print in the opposite
order. If you try this out, you'll find that the former is true, thus validating the
claim.

However, Scala allows you to change the order of evaluation.
In the following function, the \scalainline{=>} annotation means that the argument
is only evaluated when it is \emph{needed}:
\begin{scalacode}
def f2(x: => Int) = {
  println("Evaluating f2")
  x + 10
}
\end{scalacode}
Therefore, the expression \scalainline{f2(g())} prints ``Evaluating f2'' before it prints
``Evaluating g'', since the value of \scalainline{g()} is not needed until after
``Evaluating f2'' is printed.

The following function ignores its argument:
\begin{scalacode}
def f3(x: => Int) = {
  println("Evaluating f3")
  10
}
\end{scalacode}

Therefore, \scalainline{f3(g())} does not evaluate \scalainline{g()}
at all, so ``Evaluating g'' is not printed. In fact, you can even
write \scalainline{f3(throw new Exception("bad"))} and the exception
will not be thrown.

By-name arguments have several applications and are used extensively in the
Scala standard library. For example, Scala maps have a \scalainline{.get} method
that optionally returns a value stored in a map:
\begin{scalacode}
val m = Map("X" -> 1 )
val v = m.get(key) // produces Some(1) if key is "X", otherwise None
val v2 = m.get("Z") // produces None
\end{scalacode}
Suppose we were using maps in a program and that we wanted to return a default value 0
instead of \scalainline{None}. We could write:
\begin{scalacode}
m.get(key) match {
  case Some(v) => v
  case None => 0
}
\end{scalacode}
Alternatively, we could simply write \scalainline{m.getOrElse(key, 0)}. It turns out
that the second argument of this method is a by-name argument. Therefore, we can
write \scalainline{m.getOrElse(key, f())} and be assured that \scalainline{f} will not
be applied unless it is needed. It is safe to write, even if \scalainline{f()} is
an expensive computation that should only be run if \scalainline{key} is not
in the map. We could even write \scalainline{m.getOrElse(key, throw new Exception(...))}
to throw a custom exception if \scalainline{key} is not found.

\section{Functional Generators}

The reason that iterators cannot be functional is evident in the type for iterators. The
\verb|Iterator<T>| interface is part of the Java standard library and it corresponds to
the following Scala trait:
\begin{scalacode}
trait Iterator[T] {
  def hasNext(): Boolean
  def next(): T
  def remove(): Unit // not relevant for our discussion
}
\end{scalacode}
Recall that a key property of functional programs is that a function (or method) always produces
the same result when applies to the same arguments. In this interface, the \scalainline{next()} method
takes zero arguments. Therefore, if an implementation of \scalainline{Iterator[T]} were written
functionally, it could only ever produce one result.

To allow functional programming to work, we're going to have to work with a new kind of iterator,
which we'll call a \emph{generator}, where the \scalainline{next} method produces the next value
and \emph{a new generator that generates the rest of the collection}:
%
\begin{scalacode}
trait Generator[T] {
  def hasNext(): Boolean
  def next(): (T, Generator[T])
}
\end{scalacode}

An important detail of iterators that isn't obvious from the type, is that the \scalainline{next} method
will throw an exception if \scalainline{hasNext} produces \scalainline{false}.  Instead of throwing an exception,
we can make this behavior manifest in the type, by eliminating \scalainline{hasNext} method and changing the type
of \scalainline{next} to optionally produce an element and a generator.
%
\begin{scalacode}
trait Generator[T] {
  def next(): Option[(T, Generator[T])]
}
\end{scalacode}

We can now write some a functional generator. For example, here is a generator that produces three numbers:
\begin{scalacode}
val agen = new Generator[Int] {
  def next() = Some((1, new Generator[Int] {
                          def next() = Some((2, new Generator[Int] {
                                                 def next() = Some((3, new Generator[Int] {
                                                                        def next() = None
                                                                       }))
                                                }))
                        }))
}
\end{scalacode}

Here is a simple function that prints all the elements generated by any generator, including the
one above:
\begin{scalacode}
def printAll[T](gen: Generator[T]): Unit = gen.next() match {
  case None => ()
  case Some((x, rest)) => println(x); printAll(rest)
}
\end{scalacode}

\paragraph{Combining Generators} You probably agree that the definition of \scalainline{agen} is 
too unwieldy. To make generators easier to write, we are going to define three generator building
functions:

\begin{enumerate}

  \item The function \scalainline{zero[T]()} produces a generator that generates zero values of type \scalainline{T}:

  \begin{scalacode}
  def zero[T](): Generator[T] = new Generator[T] { def next() = None }
  \end{scalacode}

  \item The function \scalainline{one(x)} produces a generator that only generates the value \scalainline{x}:

  \begin{scalacode}
  def one[T](x: T): Generator[T] = new Generator[T] { def next() = Some((x, zero[T]())) }
  \end{scalacode}

  \item The function \scalainline{append(gen1, gen2)} takes two generators as arguments and first generates the
  values of \scalainline{gen1} and then the values of \scalainline{gen2}. Furthermore, to avoid generating values
  we don't need, the arguments are passed by-name:

\begin{scalacode}
def append[T](gen1: => Generator[T], gen2: => Generator[T]): Generator[T] = new Generator[T] { 
  def next() = gen1.next match {
    case None => gen2.next
    case Some((x, gen1Rest)) => Some((x, append(gen1Rest, gen2)))
  }
}
\end{scalacode}

To make \scalainline{append} easier to use, we can modify the \scalainline{Generator[T]} trait to include an operator
that invokes \scalainline{append}:
\begin{scalacode}
trait Generator[T] {
  def next(): Option[(T, Generator[T])] // as before
  def ++(other: => Generator[T]): Generator[T] = append(this, other)
}
\end{scalacode}

\end{enumerate}

Using these functions, we can write a generator that generates the fringe of a binary tree:
%
\begin{scalacode}
def fringe[T](t: BinTree[T]): Generator[T] = t match {
  case Leaf(x) => one(x)
  case Node(lhs, rhs) => fringe(lhs) ++ fringe(rhs)
}
\end{scalacode}
%
Notice that it is very similar to the function that generates the fringe as a list. However, it behaves quite differently.
Since the append (\scalainline{++}) operation evaluates its arguments only when needed, it doesn't immediately visit all the
leaves of the tree, which was the problem with the original function.

The following function takes two generators and produces \scalainline{true} if the  generate exactly the same values:
\begin{scalacode}
def sameGen[T](gen1: Generator[T], gen2: Generator[T]): Boolean = (gen1.next, gen2.next) match {
  case (None, None) => true
  case (Some((x, rest1)), Some((y, rest2))) => x == y && sameGen(rest1, rest2)
  case _ => false
}
\end{scalacode}
If the supplied generators only generate values on need, the \scalainline{sameGen} function will abort early and produce
\scalainline{false} if (1) it  encounters two values \scalainline{x != y} or (2) one generator runs out of values before 
the other. Notice that \scalainline{sameGen} has the exactly the same structure as the obvious recursive function that
checks if two lists are equal.

Finally, we can write the \scalainline{sameFringe} function that we wanted as follows:
\begin{scalacode}
def sameFringe[T](t1: BinTree[T], t2: BinTree[T]) = sameGen(fringe(t1), fringe(t2))
\end{scalacode}

\begin{think}
How would you verify that this version of \scalainline{sameFringe} truly aborts early and doesn't incorrectly traverse both
trees when it isn't necessary?
\end{think}

\paragraph{More Generators}

It is staightforward to define other handy generator-building functions. For example, it is easy to define functions
that are analogous to \scalainline{map}, \scalainline{filter}, and \scalainline{fold} for lists. You can even write
a function to flatten a generator-generator into a simple generator:
\begin{scalacode}
def flatten[T](gen: Generator[Generator[T]]): Generator[T] = new Generator[T] {
  def next() = gen.next match {
    case None => None
    case Some((x, rest)) => (x ++ flatten(rest)).next
  }
}
\end{scalacode}

\chapter{Lecture: Streams}
\savepdf{streams}

A \emph{stream} is a data structure that is very similar to a list. We write \lstinline|Stream.Empty| instead
of \lstinline|Nil| to denote the empty stream, and we construct streams using \lstinline|#::| instead of
\lstinline|::|. For example, the following expression is a stream of numbers 1, 2, 3:

\begin{lstlisting}
  1 #:: 2 #:: 3 #:: Stream.Empty
\end{lstlisting}

However, the crucial different between streams and lists is that the tail of a stream (i.e., the right-hand side
of \lstinline|#::| is only evaluated when it is \emph{needed}. For example, the function in
\cref{fromToL} produces a list a numbers and prints to the screen on each recursive call.
If we evaluate \lstinline|fromToL(0, 100)|, we get a list of numbers and 100 lines of output
since the entire list is created immediately.

In contrast, the function \cref{fromToS} produces a
stream of numbers. The expression \lstinline|val astream = fromToS(0, 100)| produces only one
line of output. Instead, each time we evaluate \lstinline|astream.tail|, \lstinline|astream.tail.tail|,
and so on, we get one additional line of output. However, evaluating \lstinline|astream.tail| a second
time doesn't produce any output: i.e., the tail is not re-evaluated.

\begin{figure}
\begin{subfigure}{.45\textwidth}
\begin{scalacode}
def fromToL(m: Int, n: Int): List[Int] = {
  println(s"within fromToL($m, $n)")
  if (m > n)  Nil
  else m :: fromToL(m + 1, n)
}
\end{scalacode}
\caption{Generating a list of numbers.}\label{fromToL}
\end{subfigure}
  \quad
  \vrule
  \quad
  \begin{subfigure}{.45\textwidth}
\begin{scalacode}
def fromToS(m: Int, n: Int): Stream[Int] = {
  println(s"within fromToS($m, $n)")
  if (m > n) Stream.Empty
  else m #:: fromTo(m + 1, n)
}

\end{scalacode}
\caption{Generating a stream of numbers.}\label{fromToS}
  \end{subfigure}
\end{figure}

\section{Infinite Streams}

We can exploit the fact that the tail is only evaluated when needed to create
an infinite stream of numbers:

\begin{scalacode}
def from(n: Int): Stream[Int] = n #:: from(n + 1)

val positives = from(1)
\end{scalacode}

This cannot be done with lists! Morever, the Scala console shows exactly what has
been evaluated:

\begin{console}
scala> positives.tail.tail.tail.tail
res2: scala.collection.immutable.Stream[Int] = Stream(5, ?)
scala> positives
res3: Stream[Int] = Stream(1, 2, 3, 4, 5, ?)
\end{console}

You can work with infinite streams freely, so long as you don't try to access
all the values (your program won't halt--there are inifinitely many values).
E.g., \lstinline|positives.length| does not terminate.


\section{Stream Transformations}

Streams have methods such as \lstinline|.map|, \lstinline|.filter|, \lstinline|.flatMap|, etc.
just like lists. However, they also produce streams. For example, the following expression
produces a stream of even numbers:

\begin{scalacode}
val evens = from(1).filter(n => n % 2 == 0)
\end{scalacode}

However, we have to careful when we use filter. If we filter an infinite stream with a
predicate that matches none of the values in the stream, we will get an infinite loop.
E.g., the following expression is an infinite loop:

\begin{scalacode}
  from(1).filter(n => n < 0)
\end{scalacode}

\section{Fibonnaci Numbers}

The following code produces an infinite stream of fibonnaci numbers:

\begin{scalacode}
def nthFib(nPredPred: Stream[Int], nPred: Stream[Int]): Stream[Int] = {
  (nPredPred.head + nPred.head) #:: nthFib(nPredPred.tail, nPred.tail)
}

val fibs: Stream[Int] = 0 #:: 1 #:: nthFib(fibs, fibs.tail)
\end{scalacode}

\chapter{Streams: Enumerating the Rationals}
\savepdf{enumerating-rationals}

In this lecture, we discussed two sophisticated uses of streams that are presented in the following
article:

\href{http://dl.acm.org/citation.cfm?id=1132893}{http://dl.acm.org/citation.cfm?id=1132893}

If you're off-campus, you may not be able to access the article. (It will prompt you to buy it.) You can visit this address
when you're connected to \emph{eduroam} or any other on-campus network to get the article for free. We only discussed Sections 1 and 2.

The code from class is included below. It simply translates the code in the article to Scala

\scalafile{code/Rationals.scala}

\chapter{Implicit Classes}
\savepdf{implicits}

\begin{figure}
\begin{subfigure}{.45\textwidth}
\scalafile{includes/implicits/Vector2D.java}
\caption{A simple vector library in Java.}
\label{vector2d}
\end{subfigure}
\quad\vrule\quad
\begin{subfigure}{.45\textwidth}
\begin{scalacode}
class Vector2D(x: Double, y: Double) {
  def +(other: Vector2D): Vector2D = {
    new Vector2D(this.x + other.x,
                 this.y + other.y)
  }

  def *(factor: Double): Vector2D = {
    new Vector2D(factor * x,
                 factor * y)
  }

  def unary_- = new Vector2D(-x, -y)
}
\end{scalacode}
\caption{A similar library in Scala.}
\label{vector2dscala}
\end{subfigure}
\end{figure}


A powerful feature of Scala is that can interoperate almost seamlessly with
Java code. So, we can use any Java library from Scala.

Imagine we were using a Java library for vectors, such as the one shown in
\cref{vector2d}. Although this is high-quality Java code, it can feel
very cumbersome to use from Scala. Compared to the terse Scala programs
we've been writing, we have to write lots of verbose method calls:
\begin{scalacode}
val v1 = new Vector2D(2, 3)
val v2 = v1.add(v1).mul(3)
\end{scalacode}
If the library had been written in Scala, it may look more like the
code in \cref{vector2dscala}, which would allow us to write the
following code instead:
\begin{scalacode}
val v1 = new Vector2D(2, 3)
val v2 = (v1 + v1) * 3
\end{scalacode}
Imagine that this is a large, full-featured, and well-tested library, so
it would be foolish to rewrite the whole thing, just to get a nicer
API.

One solution is to ``wrap'' the Java API in Scala class, as shown below:

\begin{scalacode}
class VecAdaptor(vec: Vector2D) {
  def +(other: VecAdaptor)= new VecAdaptor(vec.add(other.vec))
  def *(factor: Double) = new VecAdaptor(vec.mul(factor))
  def unary_- = new VecAdaptor(vec.neg())
}
\end{scalacode}

This is an example of the \emph{adaptor pattern}. Imagine that
the Java class had several other methods that we had not bothered
to adapt. If we wanted to use them too, we'd have to either
add adaptor methods for all them (which would be a lot of code),
or we'd have to continuously wrap and un-wrap in Scala, which would
very tiresome.

\section{Implicit Classes}

In principle, we want to take an existing class, \scalainline{Vector2D}, and add
the methods \scalainline{+}, \scalainline{*}, etc. to  it.
 However, classes cannot be modified after they are declared, so we need to
 create a wrapper. However, instead of explicitly wrapping the class,
 we can create an \emph{implicit class} as follows:
\begin{scalacode}
implicit class RichVector2D(vec: Vector2D) {
  def +(other: Vector2D): Vector2D = vec.add(other)
  def *(factor: Double): Vector2D = vec.mul(factor)
  def unary_- = vec.neg()
}
\end{scalacode}
Given this definition, when Scala sees the following code:
\begin{scalacode}
val v1 = new Vector2D(2, 3)
val v2 = (v1 + v1) * 3
\end{scalacode}
It will automatically insert the wrapper and turn it into the following:
\begin{scalacode}
val v1 = new Vector2D(2, 3)
val v2 = new RichVector2D(new RichVector2D(v1) + v1) * 3
\end{scalacode}

Here is a simpler example:
\begin{scalacode}
(new Vector2D(50, 60)) * 30
\end{scalacode}
Normally, this expression would not type-check, since \scalainline{Vector2D}
does not have a method \scalainline{*} that accepts integers. However, there is
an implicit class that wraps \scalainline{Vector2D} that does accept
integers, so the expression is transformed to:
\begin{scalacode}
(new RichVector2D(new Vector2D(50, 60))) * 30
\end{scalacode}

The \scalainline{RichVector2D} implicit class lets us write
\scalainline{(new Vector2D(50, 60)) * 30}, but we can't write
\scalainline{30 * (new Vector2D(50, 60))}, as it assumes that builtin
integers have a \scalainline{*} method that accepts vectors. However,
we can create an implicit class that wraps built-in integers too:

\begin{scalacode}
implicit class RichInt(n: Int) {
  def *(v: Vector2D): Vector2D = v.mul(n)
}
\end{scalacode}

Scala's type-checker rewrites \scalainline{3 * ...} to \scalainline{(new RichInt(3)) * ...}.
Notably, we didn't have to make any changes to the built-in \scalainline{Int}
type. (Not that we could, since it is truly built in to Scala.)

\section{Implicit Functions}

Although we can use standard mathematical notation to manipulate
vectors, we are still stuck creating constant vectors as follows:
\begin{scalacode}
val v1 = new Vector2D(2, 3)
\end{scalacode}
Suppose we wanted to just write \scalainline{(2, 3)} to denote a vector.
However, we aren't invoking a method in above, implicit classes can't help.

However, can use implicit functions:
\begin{scalacode}
implicit def pointToVector2D(pt: (Int, Int)): Vector2D = {
  new Vector2D(pt._1, pt._2)
}

val v1: Vector2D = (2, 3)
\end{scalacode}

\section{Warning}

\begin{figure}
\scalafile{includes/implicits/Implicits.scala}
\caption{Implicits should be placed in their own object.}
\label{vectorimplicits}
\end{figure}


Code that uses a lot of implicit conversions can become
very unreadable very quickly. So, you should use them with care.
Moreover, when there are several implicit classes available,
it may be ambiguous which conversion is used. When there is
ambiguity, Scala will simply signal an error.
When designing Scala APIs, it is considered good practice to place implicits in
their own object, so that users have to opt-in to using them. For example,
we may declare our implicit conversions for vectors as shown in
\cref{vectorimplicits}. Now, to use these implicits, we would have to
write:
\begin{scalacode}
import Implicits._
\end{scalacode}
This is a signal to the reader that implicit conversions are being used.

\begin{think}
If you know an untyped language such as JavaScript or Python, think about what
it would take to do something similar to implicit classes.
\end{think}

\section{Built-in Implicits in Scala}

Scala has several implicits that are available by default. Many of these
implicits are used to add features to builtin Java classes that Scala
also uses. For example, Scala arrays are just Java arrays. However,
you can use methods such as \scalainline{.map} on arrays in Scala.
This is achieved using implicits conversions.  From the Scala console,
if you enter \lstinline[language=console]{:implicits -v}, you can see the complete
list of implicits that are available.

\chapter{Constaint Propagation and the $n$-Queens Problem}
\savepdf{nqueens}

The $n$-queens problem is to place $n$ queens on an $n \times n$ chessboard
such that no queens threaten each other.
If you aren't familiar with the
rules of Chess: a queen is a chess piece that move horizontally, vertically,
or diagonally across a chessboard, which is typically an $8 \times 8$ matrix.
A queen can ``kill'' any piece that it can move to, so it is unsafe to be
on the same horziontal, vertical, or diagonal line as a queen. The $n$-queens
problem is to arrange $n$-queens on a generalized $n \times n$ chessboard,
such that no pair of queens can kill each other.

The $n$-queens problem is a canonical example of a constraint-satisfaction
problem that can be solved by backtracking search. In this lecture, we'll
begin with a naive implementation of backtracking search, and then refine
it to use constraint-propagation, which will make it a lot faster.

\section{A trait for chessboards}

\begin{figure}
\scalafile{includes/nqueens/src/main/scala/ChessBoardLike.scala}
\caption{A trait for chessboards.}
\label{ChessBoardLike}
\end{figure}

Since we are going to go through a few different representations of chessboards,
it will help to factor out generic code that prints the representation of
chessboards. The \scalainline{ChessBoardLike} trait in \cref{ChessBoardLike}
defines a \scalainline{toString} method that prints a chessboard of queens,
where each queen is printed as \texttt{Q} and each blank space appears as
\texttt{.}. This printing method requires the implementing class to have
a field that specifies that dimensions of the chessboard and set of coordinates
that describe where the queens are placed.

\section{Backtracking Search}

\begin{figure}
\scalafile{includes/nqueens/src/main/scala/NaiveQueens.scala}
\caption{A naive solution to the $n$-queens problem.}
\label{NaiveQueens}
\end{figure}

The core idea of any solution to the $n$-queens problem is to write a recursive
function (called \scalainline{solve}) that places 1 new queen on the current
board in a position where it does not threaten any existing queen and then
recursively calls \scalainline{solve} to place the remaining queens. The
function terminates sucessfully when $n$ queens have been placed on the board.
The function terminates with an error if there are no positions where the next
queen can be safely placed. In any application of \scalainline{solve}, there may
be several positions where a queen can be safely placed. The key to backtracking
is to try a new position if the recursive application produces an error.

\Cref{NaiveQueens} shows a simple implementation of this idea. The key function
is the \scalainline{canPlace} predicate which determines if a new queen
maybe placed at coordinates $(x,y)$ by checking if there are any existing
queens in the set \scalainline{solution} on the same row, column, diagonal,
or antidiagonal.

\begin{instructor}
These notes could be expanded substantially in the future.
\end{instructor}

We can run the solver as follows:

\begin{scalacode}
(new NaiveQueens(n, Set())).solve()
\end{scalacode}
With $n = 11$, the solver produces a solution in less than a second on my
laptop, with $n = 12$, it takes 55 seconds, and $n = 13$ would take much longer.

\section{Constraint Propagation}

\begin{figure}
\scalafile{includes/nqueens/src/main/scala/OptQueens.scala}
\caption{A constraint-propagating solution to the $n$-queens problem.}
\label{OptQueens}
\end{figure}

\Cref{OptQueens} shows a variant of the naive solver that is substantially
faster. The key idea to store a set of locations where a queen can be placed
without violating any constraints and then prune the set whenever a new queen
is placed.

\chapter{Bounded Quantification}
\savepdf{bounded-quantification}

\begin{figure}
\begin{scalacode}
def insert[A](toInt: A => Int, x: A, alist: List[A]): List[A] = alist match {
  case hd :: tl => if (toInt(x) <= toInt(hd)) { x :: hd :: tl } else { hd :: insert(toInt, x tl) }
  case Nil => List(x)
}

def sort[A](toInt: A => Int, alist: List[A]): List[A] = alist match {
  case Nil => Nil
  case hd :: tl => insert(toInt, hd, sort(toInt, tl))
}
\end{scalacode}
\caption{Sorting by mapping values to integers.}
\label{sortToIntHOF}
\end{figure}

We've used higher-order functions to write generic sorting functions.
\Cref{sortToIntHOF} is small variation of the kind of function we've
seen before: instead of taking a comparator function as an argument, it takes a
\scalainline{toInt} function that maps
\scalainline{A}-values to integers, then sorts by the natural ordering
on integers.

For example, given this type:
\begin{scalacode}
case class Person(name: String, age: Int)
\end{scalacode}
We can sort people in ascending order by age:
\begin{scalacode}
val personList: List[Person] = ...
sort((p: Person) => p.age, personList)
\end{scalacode}

However, it can be annoying to pass the \scalainline{toInt} function around,
especially since there is a natural ordering for \scalainline{Person}s.
We can address this issue by adding a \scalainline{toInt} method
to \scalainline{Person} and modifying \scalainline{insert} to invoke this
method instead:
\begin{scalacode}
def insert[A](x: A, alist: List[A]): List[A] = alist match {
  case hd :: tl => if (x.toInt <= hd.toInt) ...
  case Nil => ...
}
\end{scalacode}
Unfortunately, this code does not type-check: \scalainline{x} and \scalainline{hd} both have type \scalainline{A},
would could be \emph{any} type. There is no guarantee that \scalainline{A}-values have a \scalainline{toInt}
method.

\begin{figure}
\begin{scalacode}
trait IntLike {
  def toInt(): Int
}

case class Person(name: String, age: Int) extends IntLike {
  def toInt(): Int = age
}

def insert(x: IntLike, alist: List[IntLike]): List[IntLike] = alist match {
  case Nil => List(x)
  case hd :: tl => if (x.toInt <= hd.toInt) { x :: hd :: tl } else { hd :: insert(x, tl) }
}

def sort(alist: List[IntLike]): List[IntLike] = alist match {
  case Nil => Nil
  case hd :: tl => insert(hd, sort(tl))
}
\end{scalacode}
\caption{This code type-checks, but the types lose too much information.}
\label{sorting_fail}
\end{figure}

We can address this problem by introducing a trait for objects that have a
\scalainline{ToInt} method and modify \scalainline{Person} to extend this trait.
We could then rewrite the sorting function, as shown in \cref{sorting_fail}.
Unfortunately, the type of \scalainline{sort} is not helpful. When we apply
it to a \scalainline{List[Person]}, we get back a list \scalainline{List[IntLike]},
and loose track of the fact that we were working with \scalainline{Person}s:
\begin{scalacode}
val alist = List(Person("Alice", 12), Person("Bob", 7), Person("Carol", 3))
val sortedList = sort(alist)
sortedList.head.age // type error, since head has type IntLike
\end{scalacode}

We need to know that the type of the argument and the type of the result
of \scalainline{sort} are the same, which is what generics did for us:
%
\begin{scalacode}
def sort[A](alist: List[A]): List[A]
\end{scalacode}
However, the problem with this generic type was that \scalainline{A} could
be any type, and not necessary a type with a \scalainline{toInt} method,
which is what this type ensured:
\begin{scalacode}
def sort(alist: List[IntLike]): List[IntLike]
\end{scalacode}
We need to
ensure that \scalainline{alist} and the result have the same type \emph{and}
that they implement \scalainline{IntLike}. We can do this by using
\emph{bounded quantification}:
\begin{scalacode}
def sort[A <: IntLike](alist: List[A]): List[A]
\end{scalacode}
You should read this as ``sort consumes and produces lists of $A$, where $A$
is a subtype of IntLike''. \Cref{sort_bq} shows a complete version of this code.
Note that none of this is Scala-specific. \Cref{sorting_java_omg} converts
this code into Java.

Finally, note that when we write:
\begin{scalacode}
def sort[A](alist: List[A]): List[A]
\end{scalacode}
What we're really saying is that \scalainline{A} can be any type, or:
%
\begin{scalacode}
def sort[A <: Any](alist: List[A]): List[A]
\end{scalacode}
%
The bound \scalainline{Any} is implicit. Using bounded quantification, we're restricting \scalainline{A} to be any
type that implements \scalainline{IntLike}.

\begin{figure}
\begin{scalacode}
def insert[A <: IntLike](x: A, alist: List[A]): List[A] = alist match {
  case Nil => List(x)
  case hd :: tl => if (x.toInt <= hd.toInt) { x :: hd :: tl } else { hd :: insert(x, tl) }
}

def sort[A <: IntLike](alist: List[A]): List[A] = alist match {
  case Nil => Nil
  case hd :: tl => insert(hd, sort(tl))
}
\end{scalacode}
\caption{A well-typed sort using bounded quantification.}
\label{sort_bq}
\end{figure}

\begin{figure}
\begin{javacode}
interface IntLike {
  int toInt();
}

class Person implements IntLike {
  String name;
  int age;
  Person(String name, int age) { this.name = name; this.age = age; }
  public int toInt() { return age; }
}

interface List<T>  { }
class Empty<T> implements List<T> { }
class Cons<T> implements List<T> {
  public final T head;
  public final List<T> tail;
  public Cons(T head, List<T> tail) {
    this.head = head;
    this.tail = tail;
  }
}

class Sorting {

  static <T extends IntLike> List<T> insert(T x, List<T> alist) {
    if (alist instanceof Empty) {
      return new Cons<T>(x, new Empty<T>());
    }
    else {
      T hd = ((Cons<T>)alist).head;
      List<T> tl = ((Cons<T>)alist).tail;
      if (x.toInt() < hd.toInt()) {
        return new Cons<T>(x, new Cons<T>(hd, tl));
      }
      else {
        return new Cons<T>(hd, insert(x, tl));
      }
    }
  }

  static <T extends IntLike> List<T> sort(List<T> alist) {
    if (alist instanceof Empty) {
      return alist;
    }
    else {
      T hd = ((Cons<T>)alist).head;
      List<T> tl = ((Cons<T>)alist).tail;
      return insert(hd, sort(tl));
    }
  }

}
\end{javacode}
\caption{\Cref{sort_bq} converted into Java (with lists and person too).}
\label{sorting_java_omg}
\end{figure}

\section{Type Parameters to Traits}

Traits in Scala (and interfaces in Java) can take type arguments.
For example, the following trait T takes three type arguments:
\begin{scalacode}
trait T[X,Y,Z] {
  def f(x: X): Y
  def g(z: Z): Z
}
\end{scalacode}
Therefore, when a class extends the trait, it needs to supply type-arguments:
\begin{scalacode}
class C1 extends T[???, ???, ???] {
  def f(x: Int): String = x.toString
  def g(z: Boolean): Boolean = !z
}
\end{scalacode}
We can infer the arguments by examining the body of the
class.\footnote{Surprisingly, Scala's type-inference cannot infer these arguments for us.}
\begin{itemize}
  \item The class states that the argument of \scalainline{f} is an \scalainline{Int}
  and the trait states that the argument of \scalainline{f} is an \scalainline{X}.
  Therefore, \scalainline{X = Int}.

  \item The class states that the result of \scalainline{f} is a \scalainline{String}
  and the trait states that the result of \scalainline{f} is a \scalainline{Y}.
  Therefore, \scalainline{Y = String}.

  \item The class states that the argument and result of \scalainline{g} are both \scalainline{Boolean}
  and the trait states that the argument and result of \scalainline{g} are both \scalainline{Z}.
  Therefore, \scalainline{Z = Int}.
\end{itemize}
Therefore, the class can extend the trait as follows:
\begin{scalacode}
class C1 extends T[Int, String, Boolean] {
  def f(x: Int): String = x.toString
  def g(z: Boolean): Boolean = !z
}
\end{scalacode}

Consider the following class that is trying to extend the same trait:
\begin{scalacode}
class C2 extends T[Int, String, ???] {
  def f(x: Int): String = x.toString
  def g(z: Boolean): Int = 42
}
\end{scalacode}
This extension is impossible, since it would imply that \scalainline{Boolean = Int}, which
is a contradiction.

Consider the following class:
\begin{scalacode}
class C3(head: Int, tail: C3) extends T[???, ???, ???] {
  def f(x: Int): C3 = new C3(x, this)
  def g(z: C3): C3 = z
}
\end{scalacode}
We can reason through the type parameters in exactly the same way as before:
\begin{itemize}
  \item The class states that the argument of \scalainline{f} is an \scalainline{Int}
  and the trait states that the argument of \scalainline{f} is an \scalainline{X}.
  Therefore, \scalainline{X = Int}.

  \item The class states that the result of \scalainline{f} is a \scalainline{C3}
  and the trait states that the result of \scalainline{f} is a \scalainline{Y}.
  Therefore, \scalainline{Y = C3}.

  \item The class states that the argument and result of \scalainline{g} are both \scalainline{C3}
  and the trait states that the argument and result of \scalainline{g} are both \scalainline{Z}.
  Therefore, \scalainline{Z = C3}.
\end{itemize}
Here is the complete definition:
\begin{scalacode}
class C3(head: Int, tail: C3) extends T[Int, C3, C3] {
  def f(x: Int): C3 = new C3(x, this)
  def g(z: C3): C3 = z
}
\end{scalacode}

Consider the following generalization:
\begin{scalacode}
class C4[A](head: A, tail: C4[A]) extends T[???, ???, ???] {
  def f(x: A): C4[A] = new C4[A](x, this)
  def g(z: C4[A]): C4[A] = z
}
\end{scalacode}

We can apply the same reasoning to get:
\begin{scalacode}
class C4[A](head: A, tail: C4[A]) extends T[Int, C4[A], C4[A]] { ... }
\end{scalacode}

\begin{instructor}
Note that we have not covered covariant/contravariant type-arguments to traits.
\end{instructor}

\section{Leveraging Recursive Bounded Quantification}

It is cumbersome to sort values by explicitly mapping them to integers,
which is what we did before.
E.g., if we wanted to people sort by name, it would be very annoying to convert
all names to unique integers. Alternative, if we want to sort a list of time
objects, it would be annoying (and needless) to convert them all to seconds
from some fixed date.\footnote{Most computers store the current time as the number of seconds elapsed since Jan 1, 1970.}

A better approach would be to give sortable classes a \scalainline{lessThan} method
and then have them inherit from a common trait:
\begin{scalacode}
case class Person(name: String, age: Int) extends Comparable = {
  def lessThan(other: Person): Boolean = this.name < other.name
}
case class Time(h: Int, m: Int, s: Int) extends Comparable = {
  def lessThan(o: Time): Boolean = this.h < o.h || (this.h == o.h && this.m < o.min || (this.m == o.min && this.s < o.s))
}
\end{scalacode}
But, defining \scalainline{Comparable} is tricky:
\begin{scalacode}
trait Comparable {
  def lessThan(other: ???): Boolean
}
\end{scalacode}
The problem is that \scalainline{Person} requires the type of the argument
to be \scalainline{Person}, whereas \scalainline{Time} requires it to be \scalainline{Time}.
However, \scalainline{Comparable} should be a generic trait that any type can extend.
When a type in a trait must vary, we can simply turn it into a type variable,
\begin{scalacode}
trait Comparable[T] {
  def lessThan(other: T): Boolean
}
\end{scalacode}
However, the definitions of \scalainline{Person} and \scalainline{Time}
above are now incomplete, since they extend \scalainline{Comparable}, which
takes a type argument:
\begin{scalacode}
case class Person(name: String, age: Int) extends Comparable[???] = {
  def lessThan(other: Person): Boolean = ...
}
case class Time(h: Int, m: Int, s: Int) extends Comparable[???] = {
  def lessThan(o: Time): Boolean = ...
}
\end{scalacode}
We can reason about the types in exactly the way we did before.
For example, \scalainline{Person} states that the argument of \scalainline{lessThan}
is \scalainline{Person}, whereas the trait states that it is \scalainline{T}.
Therefore, \scalainline{T = Person}:
\begin{scalacode}
case class Person(name: String, age: Int) extends Comparable[Person] = ...
\end{scalacode}
We can make a similar argument for \scalainline{Time}:
\begin{scalacode}
case class Time(h: Int, m: Int, s: Int) extends ComparableTime = ...
\end{scalacode}

Now that both classes extend the \scalainline{Comparable[T]} trait, let's
update \scalainline{insert} to use it. Here is our first attempt, which
uses generics to constrain the type of the argument and result:
%
\begin{scalacode}
def insert[A](x: A, alist: List[A]): List[A] = alist match {
  case Nil => List(x)
  case head :: tail => if (x.lessThan(head)) { x :: head :: tail } else { head :: insert(x, tail) }
}
\end{scalacode}
As before, this code will not type-check, since \scalainline{A} could be any
type, whereas the body requires \scalainline{A}-typed objects to have a \scalainline{lessThan}
method. Fortunately, we have a trait for these kinds of objects:
\begin{scalacode}
def insert[A <: Comparable](x: A, alist: List[A]): List[A] = ...
\end{scalacode}
However, this will not type-check either, because \scalainline{Comparable} needs
a type argument. So, we really need to write something like this:
\begin{scalacode}
def insert[A <: Comparable[???]](x: A, alist: List[A]): List[A] = ...
\end{scalacode}

Let's reason through this systematically again:
%
\begin{itemize}

  \item \scalainline{x} has type \scalainline{A <: Comparable[???]},

  \item \scalainline{x.lessThan} takes an argument of type \scalainline{???},

  \item \scalainline{x.lessThan} is applied to \scalainline{head}, which has
  type \scalainline{A},

  \item Therefore, \scalainline{??? = A}.

\end{itemize}

\Cref{sort_sortable_complete} shows a complete version of sorting using
the \scalainline{Comparable} trait.

\begin{figure}
\begin{scalacode}
trait Comparable[T] {
  def lessThan(other: T): Boolean
}

def insert[A <: Comparable[A]](x: A, alist: List[A]): List[A] = alist match {
  case Nil => List(x)
  case head :: tail => if (x.lessThan(head)) { x :: head :: tail } else { head :: insert(x, tail) }
}

def sort[A <: Comparable[A]](alist: List[A]): List[A] = alist match {
  case Nil => Nil
  case head :: tail => insert(x, sort(tail))
}
\end{scalacode}
\caption{Sorting with a recursive bound.}
\label{sort_sortable_complete}
\end{figure}

\section{Expression Evaluator}


\begin{figure}
\begin{minipage}{0.45\textwidth}
\begin{scalacode}
sealed trait Expr
case class Const(n: Int) extends Expr
case class Add(e1: Expr, e2: Expr) extends Expr
case class Mul(e1: Expr, e2: Expr) extends Expr
case class Sub(e1: Expr, e2: Expr) extends Expr
case class Div(e1: Expr, e2: Expr) extends Expr

def eval(expr: Expr): Int = expr match {
  case Const(n) => n
  case Add(e1, e2) => eval(e1) + eval(e2)
  case Mul(e1, e2) => eval(e1) * eval(e2)
  case Sub(e1, e2) => eval(e1) - eval(e2)
  case Div(e1, e2) => eval(e1) / eval(e2)
}
\end{scalacode}
\caption{Evaluation with \scalainline{Int}s.}
\label{intEval}
\end{minipage}
\quad\vrule\quad
\begin{minipage}{0.45\textwidth}
\begin{scalacode}
sealed trait Expr
case class Const(n: Float) extends Expr
case class Add(e1: Expr, e2: Expr) extends Expr
case class Mul(e1: Expr, e2: Expr) extends Expr
case class Sub(e1: Expr, e2: Expr) extends Expr
case class Div(e1: Expr, e2: Expr) extends Expr

def eval(expr: Expr): Float = expr match {
  case Const(n) => n
  case Add(e1, e2) => eval(e1) + eval(e2)
  case Mul(e1, e2) => eval(e1) * eval(e2)
  case Sub(e1, e2) => eval(e1) - eval(e2)
  case Div(e1, e2) => eval(e1) / eval(e2)
}
\end{scalacode}
\caption{Evaluation with \scalainline{Double}s.}
\label{doubleEval}
\end{minipage}
\caption{Two very similar evaluators.}\label{twoevals}
\end{figure}


We've seen that we can use case-classes to represent arithmetic expressions
and how to write a simple, recursive evaluator. Consider the two evaluators
in \cref{twoevals}. The only difference between them is that \cref{intEval}
evaluators integer-valued expressions whereas \cref{doubleEval} evaluates
float-valued expressions. We should be able to abstract away their commonalities
by creating a generic type:

\begin{scalacode}
sealed trait Expr[A]
case class Const[A](n: A) extends Expr[A]
case class Add[A](e1: Expr[A], e2: Expr[A]) extends Expr[A]
case class Mul[A](e1: Expr[A], e2: Expr[A]) extends Expr[A]
case class Sub[A](e1: Expr[A], e2: Expr[A]) extends Expr[A]
case class Div[A](e1: Expr[A], e2: Expr[A]) extends Expr[A]
\end{scalacode}

With this type, we can write integer-valued expressions:
\begin{scalacode}
val e1: Expr[Int] = Add(Const(12), Const(3))
\end{scalacode}
and float-valued expressions too:
\begin{scalacode}
val e1: Expr[Double] = Div(Const(12), Const(5))
\end{scalacode}

The obvious way to generalize \scalainline{eval} is as follows:

\begin{scalacode}
def eval[A](expr: Expr[A]): A = expr match {
  case Const(n) => n
  case Add(e1, e2) => eval(e1) + eval(e2)
  ...
}
\end{scalacode}

Unfortunately, this doesn't work. The problem is that \scalainline{eval(e1)}
and \scalainline{eval(e2)} produce values of type \scalainline{A}, which could
be \emph{any} type. There is no guarantee that values of this type can
be added, multiplied, and so on. For example, we could have written:

\begin{scalacode}
val e1: Expr[String] = Div(Const("Hello"), Const("Goodbye"))
\end{scalacode}

The problem is that the type of \scalainline{eval} is too generic: it should
only be applicable to a type with addition, division, etc. defined appropriately.
We can define a trait that defines these operations:

\begin{scalacode}
trait NumLike[A] {
  def add(other: A): A
  def mul(other: A): A
  def sub(other: A): A
  def div(other: A): A
}
\end{scalacode}

We can create a wrapper for \scalainline{Int} and \scalainline{Double}
that implements this trait:

\begin{scalacode}
case class N(n: Int) extends NumLike[N] {
  def add(other: N): N = N(n + other.n)
  def mul(other: N): N = N(n * other.n)
  def sub(other: N): N = N(n - other.n)
  def div(other: N): N = N(n / other.n)
}

case class F(x: Double) extends NumLike[F] {
  def add(other: F): N = F(f + other.f)
  def mul(other: F): N = F(f * other.f)
  def sub(other: F): N = F(f - other.f)
  def div(other: F): N = F(f / other.f)
}
\end{scalacode}

We can now define the evaluator as follows:

\begin{scalacode}
def eval[T <: NumLike[T]](expr: Expr[T]): T = expr match {
  case Const(n) => n
  case Add(e1, e2) => eval(e1).add(eval(e2))
  case Mul(e1, e2) => eval(e1).mul(eval(e2))
  case Sub(e1, e2) => eval(e1).sub(eval(e2))
  case Div(e1, e2) => eval(e1).div(eval(e2))
}
\end{scalacode}

Although we've managed to reuse a lot of code in our evaluator,
we had to wrap \scalainline{Int}s and \scalainline{Double}s, which was
quite annoying. We'll learn how to address this problem soon.

\section{Bounded Quantification in the Java and Scala standard libraries}

Bounded quantification is used extensively in libraries. For example,
here is the signature of the \javainline{Integer} class in Java:

\begin{scalacode}
public final class Integer extends Number implements Comparable<Integer>
\end{scalacode}

The standard \javainline{Comparable} interface is very similar to the one we
defined.

\include{error_handling_discussion}

\include{tictactoe_discussion}

\include{generics_hw}

\include{scalacheck}
\input{gadts}

\input{sudoku}

\input{sudoku_discussion}


\input{regex}

\input{regex2}

\include{parsing}

\input{regex_hw}

\input{json_parsing}

\input{implicits_discussion}

\input{regex_discussion}

\chapter{Project: Data Wrangling with Json}
\savepdf{project-json-data-wrangling}

\section{Background}

\emph{JavaScript Object Notation} (JSON) is format storing and
exchanging data. It originated from JavaScript, but it is now supported by
almost every programming language, including Scala. JSON is designed
to be human-readable. For example, the following text is JSON:
%
\lstset{language=console}
\begin{lstlisting}
[
  {
    "Department": "Computer Science",
    "Course Number": 220,
    "Instructor": "Arjun Guha",
    "Offered": true
  },
  {
    "Department": "Computer Science",
    "Course Number": 631,
    "Instructor": "Arjun Guha",
    "Offered": false
  }
]
\end{lstlisting}
%
This example shows a JSON array with two elements, where each element is a
JSON dictionary. Each JSON dictionary has a set of keys---which are strings---and
values---which are JSON values themselves. The example shows that JSON values include
strings, numbers, and booleans. Note that arrays and objects are JSON values
themselves. Therefore, arrays and dictionary may be nested:
\lstset{language=console}
\begin{lstlisting}
[
  {
    "x": {
      "y": [ 1, 2, 3 ]
    }
  },
  "Something else"
]
\end{lstlisting}
%
The example above also shows that JSON arrays may be \emph{heterogenous}:
the two elements of the array are an object and a string.
Finally, JSON has a special value called \lstinline|null|.

\lstset{language=scala}
To work with a JSON file in Scala, we need to first read it (as a string)
and turn it into a data structure. The course library defines
a type called \lstinline|Json| and a function to read JSON files:
\begin{lstlisting}
import hw.json._

val result: Json = JsonHelper.parse("yelp.json")
\end{lstlisting}
%
The type \lstinline|JSON| is a \lstinline|sealed trait| with a
\lstinline|case class| for each type of JSON value:
\begin{lstlisting}
sealed trait Json
case class JsonNull() extends Json
case class JsonNumber(value: Double) extends Json
case class JsonString(value: String) extends Json
case class JsonBool(value: Boolean) extends Json
case class JsonDict(value: Map[JsonString, Json]) extends Json
case class JsonArray(value: List[Json]) extends Json
\end{lstlisting}

Note that you should not define these types yourself. They are part of the
\lstinline|hw.json| package. All the case class and functions are documented in
the \emph{Course package documentation} link on Moodle.

\section{The Yelp Dataset}

The restaurant review site Yelp releases a large dataset of restaurants
(and other businesses) in a
JSON format. In this assignment, you will use this dataset to answer vital
questions such as \emph{``What is the most popular restaurant in
California?''}. Unfortunately, the full dataset is nearly 7GB, which is too
large for most computers. Therefore, you will instead use a subset of the Yelp
data. Each review is a JSON object that looks like this:
\begin{lstlisting}
{
    "name": "Jade Palace",
    "city": "San Francisco",
    "state": "CA",
    "stars": 4.5,
    "review_count": 1140,
    "attributes": { ... },
    "categories": [ "Chinese", "TakeOut" ],
}
\end{lstlisting}

\section{Preliminaries}

Using the command-line, run the command
\verb|sbt new umass-compsci220/scala-json-data-wrangling.g8|. When prompted for
a project name, press ``Enter'' to accept the default name. This will create
a directory called \verb|scala-json-data-wrangling|.
You also need to download \verb|yelp.json| from the assignment page
and place it in the project directory.


\section{Programming Task}


Within the file \verb|scala-json-data-wrangling/src/main/scala/Main.scala|,
implement the following functions:

\begin{enumerate}

    \item Write a function that takes a key as an argument and produces the
    value associated with that key. If the provided argument is not a JSON
    dictory, or if the key does not exist, the function should produce
    \lstinline|None|.
    \begin{scalacode}
    def key(json: Json, key: String): Option[Json]
    \end{scalacode}

    \item \textbf{(Covered in discussion.)} Write a function that consumes a
    list of restaurants and only produces reviews of restaurants in the given
    state.
    \begin{scalacode}
    def fromState(data: List[Json], state: String): List[Json]
    \end{scalacode}

    \item Write a function that consumes a list of restaurants and only
    produces those restaurants that are rated less than
    or equal to \lstinline|rating|.
    \begin{scalacode}
    def ratingLT(data: List[Json], rating: Double): List[Json]
    \end{scalacode}

    \item Write a function that consumes a list of restaurants
    and returns only those restaurants that are rated greater than
    or equal to \lstinline|rating|.
    \begin{scalacode}
    def ratingGT(data: List[Json], rating: Double): List[Json]
    \end{scalacode}

    \item Write a function that consumes a list of rrestaurants
     and produces only those restaurants
    that have the given category.
    \begin{scalacode}
    def category(data: List[Json], category: String): List[Json]
    \end{scalacode}

    \item \textbf{(Covered in discussion.)} Write a function that consumes a
    list of restaurants and returns a \lstinline|Map| from states to
    restaurants in that state.
    \begin{scalacode}
    def groupByState(data: List[Json]): Map[String, List[Json]]
    \end{scalacode}

    \item Write a function that consumes a list of restaurants and returns a
    map from categories to restaurants in that category.
    \textbf{Note:} If a rerestaurant has multiple categories, it should
    occur multiple times in the output.
    \begin{scalacode}
    def groupByCategory(data: List[Json]): Map[String, List[Json]]
    \end{scalacode}

    \item Write a function that consumes a list of restaurants and returns the
    ``best'' restaurant. The ``best'' restaurant is has the highest rated
    restaurant. If there is a tie, pick the one with the most reviews.
    \begin{scalacode}
    def bestPlace(data: List[Json]): Option[Json]
    \end{scalacode}

    \item Each restaurant record contains an \texttt{attributes} key that
    \textit{may} contain an \texttt{Ambience} key, which
    itself is an object:
    \begin{scalacode}
    {   ...
        "attributes": {
            ...
            "Ambience": {
                "hipster": false,
                "trendy": false,
                "upscale": false,
                "casual": false
            }
        }
    }
    \end{scalacode}
    Write a function that consumes a list of restaurants and produces those
    restaurants that have the given ambience.
    \begin{scalacode}
    def hasAmbience(data: List[Json], ambience: String): List[Json]
    \end{scalacode}

    \item \textbf{(Not graded.)} There
    is no way to uniquely identify the restaurants in the dataset. 
    Write a function that adds a
    new key called \verb|uid| to every restaurant record.
    \begin{scalacode}
    def addUid(json: List[Json]): List[Json]
    \end{scalacode}

\end{enumerate}

You'll notice that many of the functions produce a list of JSON
objects. The key idea is that you can compose these functions together to
pose complex queries. For example, suppose \texttt{yelpJson} holds the
complete yelp data.

\begin{itemize}
\item The following query finds the best takeout restaurant in California:
    \begin{scalacode}
    bestPlace(category(fromState(yelpJson, "CA"), "takeout"))
    \end{scalacode}

\item The following query finds the best establishment in each state:
    \begin{scalacode}
    groupByState(yelpJson).map((state, els) => (s, best(els)))
    \end{scalacode}
\end{itemize}

\input{handin}

\chapter{Project: List Processing}
\savepdf{project-list-processing}

This assignment has several ``finger exercises'' that introduce you
to functional programming in Scala.

\section{Setup}

Before you start programming, you need to complete a few preliminary steps.

\begin{enumerate}

\item Follow the directions on the course website to install Scala and SBT.

\item Using the command-line, run the command
\verb|sbt new umass-compsci220/scala-list-processing.g8|. When prompted for
a project name, press ``Enter'' to accept the default name.
This will create a directory called \verb|scala-list-processing|. 

\item To verify that the previous step worked, enter the directory from
the command-line using the command \verb|cd scala-list-processing|
and then run the command \verb|sbt test|. You should
see output that looks like this:

\lstset{language=console}
\begin{lstlisting}
[info] Updating {file:/Users/arjun/Teaching/cmpsci220/hw/lists/template/}template...
[info] Resolving jline#jline;2.12.1 ...
[info] Done updating.
[info] Compiling 1 Scala source to /Users/arjun/Teaching/cmpsci220/hw/lists/template/target/scala-2.11/classes...
[info] Compiling 1 Scala source to /Users/arjun/Teaching/cmpsci220/hw/lists/template/target/scala-2.11/test-classes...
[info] TestSuite:
[info] - oddNumbers properly defined
[info] Run completed in 421 milliseconds.
[info] Total number of tests run: 1
[info] Suites: completed 1, aborted 0
[info] Tests: succeeded 1, failed 0, canceled 0, ignored 0, pending 0
[info] All tests passed.
[success] Total time: 7 s, completed Jan 17, 2016 11:52:54 AM
\end{lstlisting}
\lstset{language=scala}

\noindent \emph{There should be no errors or warnings printed.}

\end{enumerate}

\section{Exercises}

For this assignment, you'll be write several list-processing
functions. You must place these within the \verb|Lists| object in the
file \verb|src/main/scala/Lists.scala|.
You must write tests cases, within the \verb|TestSuite|
class, which is in the file \verb|src/test/scala/Tests.scala|.

\begin{enumerate}

  \item Write a function called \scalainline{sumDouble} that consumes a
  \scalainline{List[Int]} and produces an \scalainline{Int}. The produced
  value should be double the sum of the list of integers.

  \item Write a function called \scalainline{removeZeroes} that consumes a
  \scalainline{List[Int]} and produces a \scalainline{List[Int]}.
  The produced list should be the same as the input list, but with all zeroes
  removed. The function must not change the order of elements.

  \item Write a function called \scalainline{countEvens} that consumes a
  \scalainline{List[Int]} and produces an \scalainline{Int} that represents
  that number of even numbers in the input list.

  \item Write a function called \scalainline{removeAlternating} that consumes a
  \scalainline{List[String]} and produces a \scalainline{List[String]} that
  has every other element in the input list.

  The first element of the input list must be in the output list.
  For example:
  \begin{scalacode}
  assert(removeAlternating(List("A", "B")) == List("A"))
  assert(removeAlternating(List("A", "B")) != List("B"))
  \end{scalacode}

  The function must not change the order of elments.

  \item Write a function called \scalainline{isAscending} that consumes a
  \scalainline{List[Int]} and produces a \scalainline{Boolean} that is
  \scalainline{true} if the numbers in the input list are in ascending order.
  Note that the input may have repeated numbers.

  \item Write a function called \scalainline{addSub} that consumes a
  \scalainline{List[Int]} and produces an \scalainline{Int}. The
  function should add all the elements in even position and subtract all the
  elements in odd position.

  Note that the first element of a list is considered
  ``zeroth'' element, thus it is in even position.
  For example, \scalainline{addSub(List(10, 20, 30, 40))} should be
  \scalainline{10 - 20 + 30 - 40}.

  \item Write a function called \scalainline{alternate} that consumes \emph{two}
  \scalainline{List[Int]} arguments and produces a \scalainline{List[Int]}.
  The elements of the resulting list should alternate between the elements of
  the arguments. You may assume that the two arguments have the same
  length.

  For example:

  \begin{scalacode}
  assert(alternate(List(1, 3, 5), List(2, 4, 6)) == List(1, 2, 3, 4, 5, 6))
  \end{scalacode}

  \item Write a function called \scalainline{fromTo} that takes
  two \scalainline{Int}s as arguments and produces a \scalainline{List[Int]}.
  The value of \scalainline{fromTo(x, y)} should be the list of consecutive
  integers that start from and include $x$, going up to and excluding $y$.
  You may assume that $x < y$.

  For example:
  \begin{scalacode}
  assert(fromTo(9, 13) == List(9, 10, 11, 12))
  \end{scalacode}

  \item Write the following function:

  \begin{scalacode}
  def insertOrdered(n: Int, lst: List[Int]): List[Int]
  \end{scalacode}

  Assuming that \scalainline{lst} is in ascending order,
  \scalainline{insertOrdered} should produce a list that is the same as
  the input, but with $n$ inserted such that the order is preserved.
  For example, \scalainline{insertOrdered(5, List(1, 3, 7, 9))} should be
  \scalainline{List(1, 3, 5, 7, 9)}.

  You should assume that \scalainline{lst} is in ascending order. Your function
   may produce any result or even throw an exception if it is not.

   \item Write the following function:

   \begin{scalacode}
   def sort(lst: List[Int]): List[Int]
   \end{scalacode}

   The result should be the sorted input list.

   \item \textbf{Not graded.} Write a function called \lstinline|allLT|
   that consumes a list of integers and a value $n$ and produces all the numbers
   in the list that are less than $n$.

   \item \textbf{Not graded.} Write a function called \lstinline|allGTE|
   that consumes a list of integers and a value $n$ and produces all the numbers
   in the list that are greater than or equal $n$.

   \item \textbf{Not graded.} Use the two functions that you wrote above
   to implement the following function:
   \begin{lstlisting}
   def quickSort(alist: List[Int]): List[Int]
   \end{lstlisting}

\end{enumerate}

\input{handin}

\chapter{Project: Higher-Order Functions}
\savepdf{project-higher-order-functions}

In this assignment, you'll write several higher-order functions over lists.

\textbf{Restrictions}: You must not use Scala's builtin methods. In particular, you must not
use any of the methods on Scala's lists. However, feel free to use any of the list-processing
functions that we've written in class or the code you wrote for the previous assignment.
You
may not use imperative features, such as \scalainline{while} and \scalainline{var}.
You should also write any helper functions you think are necessary. You
may also use functions you write for one part of the assignment to solve
another part of the assignment.

\section{Preliminaries}

Using the command-line, run the command
\verb|sbt new umass-compsci220/scala-higher-order-functions.g8|. When prompted for
a project name, press ``Enter'' to accept the default name.

Within the file \verb|scala-higher-order-functions/src/main/scala/Main.scala|,
implement the following functions.

\begin{enumerate}

\item
Write the \scalainline{map2} function, which maps over two lists:

\begin{scalacode}
def map2[A,B,C](f: (A, B) => C, alist1: List[A], alist2: List[B]): List[C]
\end{scalacode}

You may assume that \scalainline{alist1} and \scalainline{alist2} have the same
length. (i.e., do whatever you think is reasonable if they have different
lengths).

\item
Scala lets you write \scalainline{(x, y)} to create \emph{tuples}. For example:

\begin{scalacode}
val nameSsn: (String, Int) = ("John Smith", 19970293)
val emailAdmin: (String, Boolean) = ("carberry@cs.umass.edu", true)
val xy: (Double, Double) = (3.0, 4.0)
\end{scalacode}

Tuples are a convenient way to package two related values together, without
having to create a new type to hold them. You can use pattern matching to
extract the components of tuples, or simply write \scalainline{xy._1}
and \scalainline{xy._2} to access the first and second component respectively.

Write the \scalainline{zip} function, which tuples corresponding elements in a list:

\begin{scalacode}
def zip[A,B](alist1: List[A], alist2: List[B]): List[(A, B)]
\end{scalacode}

\item
Write the function \scalainline{flatten}, which flattens a nested list:

\begin{scalacode}
def flatten[A](alist: List[List[A]]): List[A]
\end{scalacode}

\item
Write the \scalainline{flatten3} function, which flattens a triple-nested list:

\begin{scalacode}
def flatten3[A](alist: List[List[List[A]]]): List[A]
\end{scalacode}

\item
Write the \scalainline{buildList} function, which builds a list of the given length. Each
element is determined by applying \scalainline{f} to the index of the element:

\begin{scalacode}
def buildList[A](length: Int, f: Int => A): List[A]
\end{scalacode}

\item
Write the \scalainline{mapList} function, which maps each element to a list and returns
the list of all results:

\begin{scalacode}
def mapList[A, B](alist: List[A], f: A => List[B]): List[B]
\end{scalacode}

\item
Write the \scalainline{partition(f, alist)} function, which splits a list into
two sub-lists, where the first list has all the elements of \scalainline{alist}
on which \scalainline{f} produces \scalainline{true} and the second
list has all the elements of \scalainline{alist} on which \scalainline{f}
produces \scalainline{false}.

The ordering of elements in the two sub-lists should be the same
as in \scalainline{alist}.

\begin{scalacode}
def partition[A](f: A => Boolean, alist: List[A]): (List[A], List[A])
\end{scalacode}

\item
Write the \scalainline{merge(lessThan, alist1, alist2)} function, which merges
the elements of the two lists. You should assume that \scalainline{alist1}
and \scalainline{alist2} are sorted by the ordering defined by \scalainline{lessThan}.
the produced list should also be sorted by the same ordering.

\begin{scalacode}
def merge[A](lessThan: (A, A) => Boolean, alist1: List[A], alist2: List[A]): List[A]
\end{scalacode}

\item
Write the \scalainline{sort(lessThan, alist)} function, which sorts \scalainline{alist} by the ordering
defined by \scalainline{lessThan}.

\begin{scalacode}
def sort[A](lessThan: (A, A) => Boolean, alist: List[A]): List[A]
\end{scalacode}


\item \textbf{(Not graded.)}  The lecture notes discuss the
\lstinline|fold| function, which is reproduced below:
\begin{lstlisting}
def fold[A,B](baseCase: B, binOp: (A, B) => B, alist: List[A]): B = alist match {
  case Nil => baseCase
  case head :: tail => binOp(head, fold(baseCase, binOp, tail))
}
\end{lstlisting}

Rewrite the following functions using \lstinline|fold|. (i.e., do not directly
recur; let \lstinline|fold| handle recursion.)

\begin{lstlisting}
def length[A](alist: List[A]): Int = alist match {
  case Nil => 0
  case _ :: tail => 1 + length(tail)
}
  
def filter[A](f: A => Boolean, alist: List[Int]): List[A] = alist match {
  case Nil => Nil
  case head :: tail => f(head) match {
    case true => head :: filter(f, tail)
    case false => filter(f, tail)
  }
}

def map(f: Int => Int, alist: List[Int]): List[Int] = alist match {
  case Nil => Nil
  case h :: t => f(h) :: map(f, t)
}
\end{lstlisting}

\item \textbf{(Not graded.)} A folding function collapses a list into a value.
Conversely, an unfolding function builds a list from a sequence of values and
terminates the list when a condition becomes true. The general recursive
pattern of an unfolding function is shown below:

\begin{lstlisting}
def unfold[A,B](stop: B => Boolean, gen: B => (A, B), v: B): List[A] = {
  if (stop(v)) {
    Nil
  }
  else {
    val (x, vNext) = gen(v)
    x :: unfold(stop, gen, vNext)
  }
}
\end{lstlisting}

Use \lstinline|unfold| to write \lstinline|map| and \lstinline|filter|.

\item \textbf{(Not graded.)} Write a \lstinline|sort| function that uses
a combination of \lstinline|fold| and \lstinline|unfold| instead of direct
recursion. You may need to use \lstinline|fold| and/or \lstinline|unfold| several times.

\end{enumerate}

\input{handin}

\chapter{CSV Wrangling}
\savepdf{project-csv-wrangling}

The Social Security Administration (SSA) releases data dating back to
1880 on newborn babies' first names, genders, and the
popularity of these names.\footnote{\url{https://www.ssa.gov/oact/babynames/limits.html}}
The Centers for Disease Control (CDC) releases data on life expectancy
in the United States.\footnote{\url{http://www.cdc.gov/nchs/products/life_tables.htm}}.
In this assignment, you'll be putting these two data sources together
to answer questions such as
\emph{``What is the most popular baby name in 2007?''},
\emph{``Approximately how many Emmas are alive today?''}, and so on.
Both these datasets are in a format called CSV (\emph{comma-separated values}),
which is the format in which a lot of public datasets are released.

In this assignment, you will learn about CSV files and use Scala's builtin
data structures (lists, sets, and maps) to write several data-processing functions.
You may write all these functions directly using recursion, but the
the point of the assignment is to sequence Scala's built-in methods together
to write them quickly and compactly. Most of the functions only need
one line of code, if you exploit the right built-in methods.

\section{Preliminaries}

Using the command-line, run the following command:
\begin{lstlisting}
sbt new umass-compsci220/scala-csv-wrangling.g8
\end{lstlisting}
When prompted for a project name, press ``Enter'' to accept the default name.
This will create a directory with the following contents:

\dirtree{%
.1 ./scala-csv-wrangling.
.2 cdc-life-expectancy.csv\DTcomment{The CDC dataset.}.
.2 ssa-births.csv\DTcomment{A subset of the SSA dataset.}.
.2 build.sbt.
.2 project.
.3 plugins.sbt.
.3 build.properties.
.2 src.
.3 main.
.4 scala.
.5 Main.scala\DTcomment{Your solution goes here.}.
.3 test.
.4 scala.
.5 Tests.scala\DTcomment{Your test cases go here.}.
}

\section{Background: Comma Separated Values}

In a CSV file, each line has a row of data, where each row
has a sequence of columns, separated by a commas. For example, the
first few rows of \texttt{ssa-births.csv} are:

\begin{verbatim}
1880,Mary,F,7065
1880,Anna,F,2604
1880,Emma,F,2003
1880,Elizabeth,F,1939
\end{verbatim}

We can interpret this data as ``In the year 1880, 7065 female babies were born
named Mary; in the year 1880, 2604 female babies were born named Anna'' and so on.
In fact, the file has over 180,000 lines of rows like this, with data
as recent as 2014.\footnote{The original dataset has over 1.8 million rows.
We have removed several rows to ensure that it isn't too large for your
computer.}

The file \texttt{cdc-life-expectancy.csv} is much shorter and has entries
that look like this:

\begin{verbatim}
2010,76,81
2009,75,80
2008,75,80
\end{verbatim}

We can interpret this data as ``The average life expectancy of U.S. babies born
in 2010 is 76 years for males and 81 years for females'', and so
on.\footnote{The CDC releases more precise statistics. The numbers have been
cleaned up to make the assignment a little easier.}

The support code for this assignment includes a library for reading
CSV Files. For example, the expression
\begin{scalacode}
hw.csv..CSVReader.fromFile("ssa-births.csv")
\end{scalacode}
Produces the value:
\begin{scalacode}
List(
  List("1880", "Mary", "F", "7065"),
  List("1880", "Anna", "F", "2604"),
  List("1880", "Emma", "F", "2003"),
  List("1880", "Elizabeth", "F", "1939"),
  ...)
\end{scalacode}
Notice that the type of the value is \lstinline|List[List[String]|---
each row is an element of the outer list and each row is a list of strings.
In particular, even the numbers in the file are read as strings. You will
have to convert these strings to numbers. In Scala, strings have a 
\lstinline|.toInt| method that you can use to do so.

Finally, it is cumbersome to work with lists of strings,
when in fact each row has a simple structure. The template code defines
the following types, which you should not change:

\begin{lstlisting}
sealed trait Gender
case class Male() extends Gender
case class Female() extends Gender

case class SSARow(birthYear Int, name: String, gender: Gender, count: Int)

case class CDCRow(birthYear: Int, maleLifeExpectancy: Int, femaleLifeExpectancy: Int)
\end{lstlisting}

Your first step will be to write functions to convert a
row (represented as a list of strings) into these types.
Doing so will make the rest of the programming task significantly simpler.


\section{Programming Task}

Your programming task is to implement the functions in \texttt{Main.scala},
which we describe below.

\begin{enumerate}

  \item \textbf{(Covered in discussion).} The function \lstinline|readSSARow| takes a single line of data 
  \texttt{ssa-births.csv} and produces an \lstinline|SSARow| value.

  \item  \textbf{(Covered in discussion).} The function \lstinline|readCDCRow| takes a single line of data 
  \texttt{cdc-life-expectancy.csv} and produces a \lstinline|CDCRow| value.

  \item  \textbf{(Covered in discussion).} Write a function that consumes a list of SSA rows and only produces
  those rows from a given year:
  \begin{scalacode}
  def yearIs(data: List[SSARow], n: Int): List[SSARow]
  \end{scalacode}

  \item Write a function that consumes a list of SSA rows and only produces
  those rows for years greater than the given bound:
  \begin{scalacode}
  def yearGT(data: List[SSARow], bound: Int): List[SSARow]
  \end{scalacode}

  \item Write a function that consumes a list of SSA rows and only produces
  those rows for years lower than the given bound:
  \begin{scalacode}
  def yearLT(data: List[SSARow], bound: Int): List[SSARow]
  \end{scalacode}

  \item Write a function that consumes a list of SSA rows and only produces
  rows with the given name:
  \begin{scalacode}
  def onlyName(data: List[SSARow], name: String): List[SSARow]
  \end{scalacode}

  \item Write a function to calculate the most popular name in the given dataset
  and the \emph{total} number of children born with that name.

  \begin{scalacode}
  def mostPopular(data: List[SSARow]): (String, Int)
  \end{scalacode}

  \textbf{Hint:} It is likely that children are born with the same
      name in several years. So, you should first calculate the total
      number of childen with each name.
  
  \item Write a function to calculate the number of children born in the given dataset.
  \begin{scalacode}
  def count(data: List[SSARow]): Int
  \end{scalacode}

  \item Write a function that produces a tuple with the number of girls and boys
   respectively.
  \begin{scalacode}
  def countGirlsAndBoys(data: List[SSARow]): (Int, Int)
  \end{scalacode}

  \item Writen a function to calculate the set of names that are given to both girls and boys.
  \begin{scalacode}
  def genderNeutralNames(data: List[SSARow]): Set[String]
  \end{scalacode}


  \item Write a function to determine if a person with the specified gender and birth year
    is expected to be alive in the year  \texttt{currentYear}):

  \begin{scalacode}
  def expectedAlive(gender: Gender, birthYear: Int, currentYear: Int, lifeExpectancies: List[CDCRow]): Boolean 
  \end{scalacode}

  If \texttt{currentYear} is the last year the person is estimated to be alive, be
  optimistic and produce \texttt{true}.

  You will need the CDC life expectancy dataset, which you should provide as an
  argument to the function (\lstinline|lifeExpectancies|).
  i.e., do not use
  \lstinline|CSVReader.fromFile| within this function.

  The CDC data only ranges from 1930---2010. Therefore, assume that
    \texttt{birthYear} is in this range too.


  \item Write a function to estimate how many people from the given dataset
  will be alive in a particular year:

  \begin{scalacode}
  def estimatePopulation(data: List[SSARow], year: Int, lifeExpectancies: List[CDCRow]): Int
  \end{scalacode}

  You will need the CDC life expectancy dataset, which you should provide as an
  argument to the function (\lstinline|lifeExpectancies|). i.e., do not use
  \lstinline|CSVReader.fromFile| within this function.


\end{enumerate}



You'll notice that many functions
consume and produce a list of births. The key idea is that you can
compose these functions together to pose complex queries. For example,
suppose \scalainline{allBirths} holds the complete list of births:

\begin{scalacode}
val allBirths = CSVReader.fromFile("ssa-births.csv")
\end{scalacode}

\begin{itemize}

  \item The following query calculates how many girls and boys were born between 1990
  and 2000:

  \begin{scalacode}
  countGirlsAndBoys(yearGT(yearLT(allBirths, 2001), 1989))
  \end{scalacode}

  \item The following query tells is if there were more Emma's born in 2010 than
  in 2009:

  \begin{scalacode}
  count(onlyName(yearIs(2010, allBirths), "Emma")) > count(onlyName(yearIs(2009, allBirths), "Emma"))
  \end{scalacode}

  \item The following query reports the most popular name of 2013:

  \begin{scalacode}
  mostPopular(yearIs(2013, allBirths))
  \end{scalacode}

  \item The following query estimates the number of John's alive today who
  were born after 1980:

  \begin{scalacode}
  estimatePopulation(yearGT(allBirths, 1980), 2015, CSVReader.fromFile("cdc-life-expectancy.csv"))
  \end{scalacode}

\end{itemize}

\input{handin}

\chapter{Project: Generalized Tic Tac Toe}
\savepdf{project-tictactoe}

For this assignment, you will write a program that given an $n \times n$
tic-tac-toe board,
determines which player will win, or if the game will be a draw.
You're going to make significant use of Scala collections and learn the
\emph{Minimax algorithm}, which is a form of \emph{backtracking search}.

\section{Preliminaries}

Using the command-line, run the following command:

\begin{lstlisting}
sbt new umass-compsci220/scala-tictactoe.g8
\end{lstlisting}

When prompted for a project name, press “Enter” to accept the default name.
This will create a directory with the following contents:

You should create a directory-tree that looks like this:

\dirtree{%
.1 ./scala-tictactoe.
.2 build.sbt.
.2 project.
.3 plugins.sbt.
.2 src.
.3 main.
.4 scala.
.5 Main.scala\DTcomment{Your solution goes here}.
.3 test.
.4 scala.
.5 Tests.scala\DTcomment{Yours tests go here}.
}

\section{Representing a Tic Tac Toe Board}

We assume you know how to play Tic Tac Toe. This section talks about
the representation of tic-tac-toe boards that you will use. All
the types mentioned below are in the \scalainline{hw.tictactoe} package.

The \scalainline{sealed trait Player} has two constructors,
\scalainline{O} and \scalainline{X}, that represent the
two players.

A typical $3 \times 3$ board can be thought of as a $3 \times 3$ matrix,
where $(0, 0)$ is
the coordinate of the top-left corner and $(2,2)$ is the coordinate of
the bottom-right corner:

\begin{tikzpicture}
\draw[step=1cm,black,very thin] (0,0) grid (3,3);
\node at (0.5,0.5) {$(0, 2)$};
\node at (1.5,0.5) {$(1, 2)$};
\node at (2.5,0.5) {$(2, 2)$};
\node at (0.5,1.5) {$(0, 1)$};
\node at (1.5,1.5) {$(1, 1)$};
\node at (2.5,1.5) {$(2, 1)$};
\node at (0.5,2.5) {$(0, 0)$};
\node at (1.5,2.5) {$(1, 0)$};
\node at (2.5,2.5) {$(2, 0)$};
\end{tikzpicture}

The \scalainline{Solution.createGame} function, which you need to implement,
takes as input the player who makes the first move, the
value $n$ that specifies the dimensions of the board, and a map from coordinates to \scalainline{Player}s
that indicates where the pieces are.

For example:

\begin{itemize}

  \item In generalized tic-tac-toe, either player may make the first move.
  Therefore, given an empty board:

  \begin{tikzpicture}
  \draw[step=1cm,black,very thin] (0,0) grid (3,3);
  \end{tikzpicture}

  We can call the function in two ways:

  \begin{scalacode}
  Solution.createGame(O, 3, Map())
  Solution.createGame(X, 3, Map())
  \end{scalacode}

\item This board:

\begin{tikzpicture}
\draw[step=1cm,black,very thin] (0,0) grid (3,3);
\node (a) at (2.5,0.5) {\textsf{O}};
\node (b) at (0.5,2.5) {\textsf{X}};
\end{tikzpicture}

Can be represented as:
\begin{scalacode}
Solution.createGame(X, 3, Map((0, 0) -> X, (2, 2) -> O))
\end{scalacode}
Alternatively, we could have O make the next move.

\item This board:

\begin{tikzpicture}
\draw[step=1cm,black,very thin] (0,0) grid (3,3);
\node (a) at (0.5,0.5) {\textsf{X}};
\node (b) at (0.5,2.5) {\textsf{X}};
\node (c) at (2.5,.5) {\textsf{O}};
\end{tikzpicture}

Can be represented as:
\begin{scalacode}
Solution.createGame(X, 3, Map((0, 0) -> X, (0, 2) -> X, (2, 2) -> O))
\end{scalacode}
Alternatively, we could have O make the next move.

\item This board, which is $4 \times 4$:

\begin{tikzpicture}
\draw[step=1cm,black,very thin] (0,0) grid (4,4);
\node (a) at (0.5,3.5) {\textsf{X}};
\node (b) at (2.5,1.5) {\textsf{O}};
\node (c) at (3.5, 0.5) {\textsf{X}};
\end{tikzpicture}

Can be represented as:
\begin{scalacode}
Solution.createGame(O, 4, Map((0, 0) -> X, (2, 2) -> O, (3, 3) -> X))
\end{scalacode}
Alternatively, we could have X start first too.

\end{itemize}

\section{The Minimax Algorithm}

\emph{Minimax} is an algorithm to determine who will win (or draw)
a two-player game, if both players are playing perfectly. To do so, Minimax
searches all possible game-states that are reachable from a given inital
state. Here is an outline of a recursive implementation of Minimax:

\begin{scalacode}
def minimax(game: Game): Option[Player] = {

  /*
  If it is Xs turn:

    1. If X has won the game, return Some(X).
    2. If the game is a draw, return None. (If all squares are filled
       and nobody has won, then the game is a draw. However, you are
       free to detect a draw earlier, if you wish.)
    3. Recursively apply minimax to all the successor states of game
       - If any recursive call produces X, return Some(X)
       - Or, if any recursive call produces None, return None
       - Or, return Some(O)

  The case for Os turn is similar.
  */

}
\end{scalacode}

You can find several other descriptions of Minimax on the Web. But, Minimax
 is a very straightforward function to write, if you follow the programming directions below
and implement (and test) everything leading up to Minimax.

\section{Programming Task}

Your task is to implement a representation of boards, by implementing
the \scalainline{GameLike} trait, provided in the template code.
Your code must be able to implement arbitrary $n \times n$ boards for
all $n > 2$. However, your implementation of the Minimax algorithm
(the \scalainline{MinimaxLike} trait) only needs to be fast enough for
 $n \le 4$.\footnote{If you want to do better, lookup \emph{alpha-beta pruning} on the web.}

I recommend proceeding in the following way, using
\texttt{Solution.scala} as a template:

\begin{enumerate}

\item
   Add fields to the \scalainline{Game} class to represent the state of the game and
   fill in the body of the \scalainline{Solution.createGame(turn, dim, board)} function.
   You may assume that \scalainline{dim >= 2} and that all the pieces described
   in \scalainline{board} are within bounds. However, \emph{The board may be in an
   arbitrary, even illegal state}. For example, the board may have seven Xs.
   Similarly, the \scalainline{turn} could be either X or O.


\item Implement the \scalainline{Game.isFinished} method. This method
  should produce \scalainline{true} when there are $n$ Xs or Os in a row
  or the game ends in a draw.


\item Implement the \scalainline{getWinner} method.

\item Implement the \scalainline{nextBoards} method, which returns a list of
   boards that represent all the moves the next player could make.

   For example, if the current board looks like this:

\begin{tikzpicture}
\draw[step=1cm,black,very thin] (0,0) grid (3,3);
\node at (0.5,0.5) {\textsf{X}};
\node at (1.5,0.5) {\textsf{O}};
\node at (2.5,0.5) {\textsf{O}};
\node at (1.5,1.5) {\textsf{O}};
\node at (0.5,2.5) {\textsf{X}};
\node at (1.5,2.5) {\textsf{X}};
\end{tikzpicture}

And if it is \emph{O}'s turn, then these are the three possible next boards:

\begin{tikzpicture}
\draw[step=1cm,black,very thin] (0,0) grid (3,3);
\node at (0.5,0.5) {\textsf{X}};
\node at (1.5,0.5) {\textsf{O}};
\node at (2.5,0.5) {\textsf{O}};
\node at (0.5,1.5) {\textsf{O}};
\node at (1.5,1.5) {\textsf{O}};
\node at (0.5,2.5) {\textsf{X}};
\node at (1.5,2.5) {\textsf{X}};
\end{tikzpicture}
\quad
\begin{tikzpicture}
\draw[step=1cm,black,very thin] (0,0) grid (3,3);
\node at (0.5,0.5) {\textsf{X}};
\node at (1.5,0.5) {\textsf{O}};
\node at (2.5,0.5) {\textsf{O}};
\node at (1.5,1.5) {\textsf{O}};
\node at (2.5,1.5) {\textsf{O}};
\node at (0.5,2.5) {\textsf{X}};
\node at (1.5,2.5) {\textsf{X}};
\end{tikzpicture}
\quad
\begin{tikzpicture}
\draw[step=1cm,black,very thin] (0,0) grid (3,3);
\node at (0.5,0.5) {\textsf{X}};
\node at (1.5,0.5) {\textsf{O}};
\node at (2.5,0.5) {\textsf{O}};
\node at (1.5,1.5) {\textsf{O}};
\node at (0.5,2.5) {\textsf{X}};
\node at (1.5,2.5) {\textsf{X}};
\node at (2.5,2.5) {\textsf{O}};
\end{tikzpicture}

\item\textbf{(Not Graded.)} Minimax is too slow to solve boards larger than
$4 \times 4$. Look up \emph{alpha-beta pruning} and implement it instead
of Minimax.

\end{enumerate}

As you implement each successive step, you may need to revisit design
decisisions you made earlier.

\input{handin}

\chapter{Project: Generators}
\savepdf{project-generators}

As we've seen, Scala has a builtin \lstinline|Stream| that can represent
infinite lists. In this project, instead of working with Scala's builtin
streams, you will work with a data structure that is essentially equivalent to
Scala's \lstinline|Stream| and write several stream processing functions.

\section{Preliminaries}

Using the command-line, run the following command:

\begin{lstlisting}
sbt new umass-compsci220/scala-generators.g8
\end{lstlisting}

When prompted for a project name, press ``Enter'' to accept the default name.
This will create a directory with the following contents:

\dirtree{%
.1 ./scala-generators.
.2 build.sbt.
.2 project.
.3 plugins.sbt.
.2 src.
.3 main.
.4 scala.
.5 Main.scala\DTcomment{Your solution goes here}.
.3 test.
.4 scala.
.5 Tests.scala\DTcomment{Yours tests go here}.
}

\section{Introduction}

The support code for this project defines a trait called \lstinline|Generator|:

\begin{lstlisting}
trait Generator[T] {
  def next(): (T, Generator[T])
}
\end{lstlisting}

A generator is an object that has a \lstinline|next()| method, which produces
a tuple that contains (1) the next value and (2) a \lstinline|Generator| that generates
the remaining values. Note that \lstinline|next()| \emph{always} produces the next
value and the next \lstinline|Generator|, so it generates an infinite sequence
of values. This is in contrast to
Scala's \lstinline|Stream| and the \lstinline|Generator| we saw in class,
which may be finite.

The following function is equivalent to the cons operator (\lstinline|#::|)
for Scala's streams:
\begin{lstlisting}
def cons[A](head: A, tail: =>Generator[A]): Generator[A] = new Generator[A] {
  def next() = (head, tail)
}
\end{lstlisting}

Notice that \lstinline|tail| is a \emph{by-name argument}, thus we can use
\lstinline|cons| to create cyclic values. For example, the following value
is an infinite sequence of $1$s:
\begin{lstlisting}
val ones: Generator[Int] = cons(1, ones)
\end{lstlisting}

\section{Programming Task}

Within the \lstinline|Main| object in \lstinline|Main.scala|, complete
the following definitions. The number of $\star$s next to each question is
our estimate of how difficult a question will be (harder questions have more 
$\star$s). If you cannot complete a question, leave its definite in place
(i.e., do not delete the \lstinline|???| or any dummy definitions).

\begin{enumerate}

  \item ($\star$, \textbf{Covered in discussion}) Define a function that 
  generates a sequence of numbers starting with \lstinline|x|.

\begin{lstlisting}
def from(x: Int): Generator[Int] = ???
\end{lstlisting}
  
   For example, \lstinline|from(0)| should generate $0, 1, 2, 3, \cdots$.

  \item ($\star\star$) Define the \lstinline|map| function for generators.

\begin{lstlisting}
def map[A,B](f: A => B, agen: Generator[A]): Generator[B] = ???
\end{lstlisting}

  For example, \lstinline|map((x: Int) => x * 2, from(0))| should generate
  $0, 2, 4, 6, \cdots$.


  \item ($\star$) Define a value \lstinline|pow| that generates
  the non-negative powers of two, i.e., $1, 2, 4, 8, 16, \cdots$.

\begin{lstlisting}
val pow: Generator[Int] = ???
\end{lstlisting}

  \emph{Hint:} The function \lstinline|math.pow(x, y)| calculates $x^y$, but
  produces a \lstinline|Double|.
  However, \lstinline|Double|s have a \lstinline|.toInt| method that you can
  use.

\item ($\star\star$, \textbf{Covered in discussion}) Define the function
  \lstinline|nth| which produces the $n$th value generated by a generator.

\begin{lstlisting}
def nth[A](agen: Generator[A], index: Int): A = ???
\end{lstlisting}
  
  For example, \lstinline|nth(from(0), 10)| should produce \lstinline|10|.

\item ($\star\star$) Define the \lstinline|filter| function for generators.
\begin{lstlisting}
def filter[A](pred: (A) => Boolean, agen: Generator[A]): Generator[A] = ???
\end{lstlisting}

  For example, if \lstinline|isEven| is a predicate that produces 
  \lstinline|true| when applied to an even number, then
  \lstinline|filter(isEven, from(0))| should produce $0, 2, 4, 8, 10, \cdots$.

  \emph{Note:} \lstinline|filter| will not terminate if none of the values in
  the generator match the prediciate.

  \item ($\star\star\star$)
  Define the \lstinline|interleave| function, which takes two generators
  and generates an interleaving sequence of values from both, starting with
  the first generator.

\begin{lstlisting}
def interleave[A](gen1: Generator[A], gen2: Generator[A]): Generator[A] = ???
\end{lstlisting}

  For example, if \lstinline|gen1| produces $x_0, x_1, x_2, \cdots$ and \lstinline|gen2|
  produces $y_0, y_1, y_2, \cdots$ then their interleaving is $x_0, y_0, x_1, y_1, x_2, y_2, \cdots$.


  \item ($\star\star\star$) Define a function that generates the running total
  of its input.
  
\begin{lstlisting}
def total(agen: Generator[Double]): Generator[Double] = ???
\end{lstlisting}

  For example, if \lstinline|agen| generates $0, 1, 2, 3, 4, \cdots$, 
  then \lstinline|total(agen)| should
  generate $0, 1, 3, 5, 9, \cdots$.
  
\item ($\star$) Define a function called \lstinline|sift(n, agen)|, which
generates the values of \lstinline|agen| but with the multiples of \lstinline|n|
removed.

\begin{lstlisting}
def sift(n: Int, agen: Generator[Int]): Generator[Int]
\end{lstlisting}


\item ($\star\star\star\star$) The \emph{Sieve of Eratosthenes} is a way of computing the prime numbers.

\begin{itemize}

\item Start with the sequence $2, 3, 4, 5, 6, \cdots$.

\item Take $2$ as prime. Delete all multiples of $2$, since they cannot be prime, which leaves $3, 5, 7, 9, 11, \cdots$.

\item Take $3$ as prime. Delete all multiples of $3$, since they cannot be prime, which leaves $5, 7, 11, 13, 17, \cdots$.

\item Take $5$ as prime, etc.

\end{itemize}

Define a prime number generator (starting with $2$):

\begin{lstlisting}
val primes: Generator[Int] = ???
\end{lstlisting}

\emph{Hint}: Use \lstinline|sift|.

\end{enumerate}

\input{handin}

\chapter{Project: Programming with combinators}
\savepdf{project-json-combinators}

\section{Introduction}
In the past assignments, we looked at how Scala uses first class functions
to allow for a greater level of composition in programs. In this assignment,
you will be implementing \textit{functional combinators} that allow you
build up a library using a small and composable core of program primitives.
\\ \\

\section{Working with combinators}
For this assignment, you will be working with the case class \texttt{JsonProc}
(documented in hw.combinator.JsonProc). We will be using this class and its 
member methods to implement combinators. 
\\ \\
\noindent First, let's take a look at the definition of the \texttt{JsonProc}
class:
\begin{scalacode}
case class JsonProc[S, T](val func: S => List[T])
\end{scalacode}
An instance of \texttt{JsonProc} takes a function that consumes a value of type
\texttt{S} and returns a list of values of type \texttt{T}. The reason for
producing a list of values instead of a single value will become clearer later
on. For now, we can take a look at a combinator that we can implement using
the \texttt{JsonProc} class. 
\\ \\
\noindent \textbf{Description}: Implement a combinator that extract the value
associated with a a key in a \texttt{JsonDict}. If the input is not a
\texttt{JsonDict}, or if the key does not exist, return an empty list.
\begin{scalacode}
def key(key: String): JsonProc[Json, Json] = new JsonProc(json => 
    json match {
      case JsonDict(map) => map.get(JsonString(key)) match {
        case Some(value) => List(value)
        case None => Nil
      }
      case v => Nil
    })
\end{scalacode}
We have now defined the \texttt{key} combinator. To use this combinator, we
can simply extract the \texttt{func} value from the resulting \texttt{JsonProc}:
\begin{scalacode}
// represents the json { "a": 1 }
val json = JsonDict(Map(JsonString("a") -> JsonNumber(1))) 
val a: JsonProc[Json, Json] = key("a").func(json) // a = List(JsonNumber(1))
\end{scalacode}
This however, is not an interesting use case of the combinator since we could
have simply used a function to accomplish the same goal. Consider, however, the
case where we have to extract a value from a nested \texttt{JsonDict}:
\begin{scalacode}
// represents the json { "a": { "b": 2 } }
val nestedJson = JsonDict(Map(JsonString("a") -> JsonDict(Map(JsonString("b") -> JsonNumber(2)))))
\end{scalacode}
To extract this key, we will make use of the method \texttt{>>>} defined on
\texttt{JsonProc}. \texttt{>>>} allows us to compose two \texttt{JsonProc}
sequentially. It takes the result from the first \texttt{JsonProc}, which is a
list, applies the second \texttt{JsonProc} to each element, and flattens the result
to get another list of values.
\begin{scalacode}
val getAthenB: JsonProc[Json, Json] = key("a") >>> key("b")
val b = getAthenB.func(nestedJson) // b = List(JsonNumber(2))
\end{scalacode}
This use case also clarifies why the function inside \texttt{JsonProc} returns
a list of values: What if the input to \texttt{getAthenB} did not have a key
called ``a''. In that case, the composition operator would have received an
empty list and wouldn't have applied the second combinator on anything else.

\section{Preliminaries}
Using the command-line, run the command
\verb|sbt new umass-compsci220/scala-json-combinators.g8|. When prompted for
a project name, press ``Enter'' to accept the default name. This will create
the directory \verb|scala-json-combinators|. Implement the functions described
below in the file \verb|scala-json-combinators/src/main/scala/Main.scala|.

\section{Programming Task}
For this assignment, you will be implementing several combinators that operate
on Json values. Additionally, you will be using these combinators to implement
various extractors on Json values.

\begin{enumerate}
    \item Implement a combinator that extracts the number from an input
    \texttt{JsonNumber}. If the input is not a \texttt{JsonNumber}, return the
    empty list. Otherwise, return a singleton list with just the number.
    \begin{scalacode}
    def number: JsonProc[Json,Double]
    \end{scalacode}

    \item Implement a combinator that extracts the given \texttt{index} from
    a \texttt{JsonArray}. If the input is not a \texttt{JsonArray} or if the index
    is not present in the array, return an empty list. Otherwise, return
    a singleton list with just the Json value at the given index.
    \begin{scalacode}
    def index(n: Int): JsonProc[Json,Json]
    \end{scalacode}

    \item Implement a combinator that returns all the elements in a
    \texttt{JsonArray}. If the input is not a \texttt{JsonArray}, return the
    empty list.
    \begin{scalacode}
    def iter: JsonProc[Json,Json]
    \end{scalacode}

    \item Implement a combinator that extracts all the leaf values from an
    input Json value. Leaf values can only be \texttt{JsonNull},
    \texttt{JsonString}, \texttt{JsonNumber}, and \texttt{JsonBool}.
    \begin{scalacode}
    def recur: JsonProc[Json, Json]
    \end{scalacode}

    % Getting students to use >>> to make sure they understand JsonProcs
    \item Using the combinators defined so far and the \texttt{>>>} method,
    implement a function that takes a \texttt{JsonArray} and adds all the
    numbers in it. \textbf{You may not use pattern matching or recursion to
    implement this function}. You may only use combinators.
    \begin{scalacode}
    def addAll(json: Json): Double
    \end{scalacode}

    \item Implement the function allNumbers that extracts all the numbers from
    an arbitrarily nested Json value. The function should return a list containing
    all the numbers in the input Json value. The order of numbers does not
    matter. \textbf{You may not use pattern matching or recursion to
    implement this function}. You may only use
    combinators.
    \begin{scalacode}
    def allNumbers(json: Json): List[Double]
    \end{scalacode}

    \item Implement a generic combinator that returns tuple that contains
    two copies of the input. This combinator will allow us to perform two
    separate operation on a given input.
    \begin{scalacode}
    def split[S]: JsonProc[S, (S, S)]
    \end{scalacode}

    \item Implement a generic combinator that takes tuple with two values
    of the same type and returns a list containing both the elements. This
    combinator will allow us to combine two separate inputs into one output.
    \begin{scalacode}
    def combine[A]: JsonProc[(A, A), A]
    \end{scalacode}

    \item Implement the combinator \texttt{first}. The input to first is a
    generic \texttt{JsonProc} called \texttt{proc} that consumes a value of
    type `A' and returns a value of type `B'. The output of \texttt{first} is
    a \texttt{JsonProc} that consumes a tuple and returns a list of tuples in
    which the first element has been transformed by \texttt{proc}. This
    combinator will allow us to operate on one of copies generated by split.
    \begin{scalacode}
    def first[A, B, C](proc: JsonProc[A, B]): JsonProc[(A, C), (B, C)]
    \end{scalacode}

    \item Implement the combinator \texttt{second}. The input to first is a
    generic \texttt{JsonProc} called \texttt{proc} that consumes a value of
    type `A' and returns a value of type `B'. The output of \texttt{first} is
    a \texttt{JsonProc} that consumes a tuple and returns a list of tuples in
    which the second element has been transformed by \texttt{proc}. This
    combinator will allow us to operate on one of copies generated by split.
    \begin{scalacode}
    def second[A, B, C](proc: JsonProc[A, B]): JsonProc[(C, A), (C, B)]
    \end{scalacode}

    \item Implement the function extractNameAndAge that consumes a Json value
    and extracts the ``name'' and ``age'' fields if the value is a
    \texttt{JsonDict}. If the extraction is successful, return the values in
    tuple wrapped in \texttt{Some} (value of name first, then age). In every
    other case, return \texttt{None}. \textbf{You may not use pattern
    matching or recursion to implement this function}. You may only use
    combinators.
    \begin{scalacode}
    def extractNameAndAge(json: Json): Option[(Json, Json)]
    \end{scalacode}

    \item Implement the function calculateAge that consumes a Json value
    and calculates the age using the ``born'' and ``died'' fields. If they
    exist, both ``born'' and ``died'' keys have \texttt{JsonNumber}s associated
    to them. If the age can be calculated, return it wrapped in \texttt{Some}.
    In every other case, return \texttt{None}. \textbf{You may not use pattern
    matching or recursion to implement this function}. You may only use
    combinators.
    \begin{scalacode}
    def calculateAge(json: Json): Option[Double]
    \end{scalacode}

\end{enumerate}

\input{handin}

\chapter{Project: Implicit Classes}
\savepdf{project-implicits}

In this assignment, you'll first learn how to use two modern Java APIs on your 
own and then make them more ``Scala-like'' using implicits. Before you start 
directly working on the assignment, you will have to read the API documentation 
and online tutorials to learn how the APIs work. We encourage you to freely use
 any resource from the web for this assignment.

\textbf{Note:} This assignment can be done using implicit classes exclusively. 
Scala also supports implicit arguments and implicit functions, but you don't 
need them for this assignment.

\section{Preliminaries}

Using the command-line, run the following command:

\begin{lstlisting}
sbt new umass-compsci220/scala-implicits.g8
\end{lstlisting}

When prompted, press ``Enter'' to accept the default directory name. This will
create a directory tree with the following contents:

\dirtree{%
.1 ./scala-implicits.
.2 build.sbt.
.2 project.
.3 plugins.sbt.
.2 src.
.3 main.
.4 scala.
.5 Main.scala\DTcomment{Your solution goes here}.
.3 test.
.4 scala.
.5 Tests.scala\DTcomment{Yours tests go here}.
}


\section{Java NIO}

The \href{https://docs.oracle.com/javase/7/docs/api/java/nio/file/package-summary.html#package_description}{java.nio.file} classes are a new (since 2011) API for working with files and directories that is a lot easier to use than the legacy API, which dates back to the early days of Java. For example, the static methods \scalainline{Files.readAllBytes} and \scalainline{Files.write} let you read and write to files with just one line of code.

Moreover, the \scalainline{java.nio.file.Paths} object is easier to use than \scalainline{java.io.File}. For example, to get a reference to the directory \texttt{"a/b/c"}, we can simply write:
%
\begin{scalacode}
import java.nio.file.Paths
Paths.get("a").resolve("b").resolve("c")
\end{scalacode}
%
The ``method call chain'' above is lot easier to write and read than the nested constructors in the legacy code below:
%
\begin{scalacode}
import java.io.File
new File(new File("a", "b"), "c")
\end{scalacode}

However, we ought to be able to do better in Scala. It would be really convenient if we could simply create a \scalainline{java.nio.file.Path} object by writing:
%
\begin{scalacode}
"a" / "b" / "c"	
\end{scalacode}
The expression above should be the same as \scalainline{Paths.get("a").resolve("b").resolve("c")}.
The first part of this assignment is to ``Scala-ize'' the Java NIO file API in this manner.

\subsection{Programming Task}

Add code to the \lstinline|PathImplicits| object (defined in \texttt{Main.scala}),
such that when a block of code begins with \scalainline{import PathImplicits._}, 
we should be able to write the following:

\begin{enumerate}

  \item We should be able to construct paths by using the slash-operator to separate strings. For example, the expression \scalainline{"usr" / "bin" / "scala"} should be equivalent to the expression \scalainline{Paths.get("usr", "bin", "scala")}. 
  \item Similarly, given two paths, we should be able to join them using the slash-operator. For example, if \scalainline{p1} is \scalainline{"usr" / "local"} and \scalainline{p2} is \scalainline{"bin" / "scala"} then \scalainline{p1 / p2} should be equivalent to \scalainline{Paths.get("usr", "local", "bin", "scala")}. 
  \item Paths should have a \scalainline{write} method to create files, where \scalainline{write} takes a string to write to the file. For example, the following program should create a file called \texttt{greeting.txt} with just the line \texttt{Hello, world}: %
\begin{scalacode}
val p = Paths.get("greeting.txt")
p.write("Hello, world\n")
\end{scalacode}	

  \item Paths should also have a \scalainline{read} method that returns the contents of the file as a string. For example, after creating the file above, the expression \scalainline{p.read()} should produce \verb|"Hello, world\n"|.

  \item Finally, paths should have an \scalainline{append} method that appends to the end of a file. For example, after evaluating  \scalainline{p.append("Hello, again")}, the file \texttt{greeting.txt} should contain:

\begin{verbatim}
Hello, world
Hello, again
\end{verbatim}

    \textbf{For convenience, the append method should create a new file if no file exists.}

\end{enumerate}

\section{The Java 8 Time API}

Java 8, which was released in 2014, introduced a new API for working with dates and times, which is much easier to use than the old \texttt{java.util.Calendar} API (from 1997) and the \texttt{java.util.Date} API (from 1996 and deprecated). Notably, the new \texttt{java.time} API uses immutable objects exclusively, unlike the older APIs, which are exemplars of bad imperative design. For this assignment, we are going to focus on the \href{https://docs.oracle.com/javase/8/docs/api/java/time/LocalDate.html}{java.time.LocalDate} class, which just represents a date, without a timezone or time of day.

For example, we can create a date that represents Jan 31 2018 as follows:
\begin{scalacode}
import java.time.LocalDate
val date = LocalDate.of(2018, 1, 31)
\end{scalacode}

We can add days to a date as follows:
\begin{scalacode}
val feb2 = date.plusDays(2)
\end{scalacode}

Note that the expression above does not modify the original \scalainline{date}
object, but produces a new object. In fact, the \scalainline{LocalDate} class
is immutable and the API is designed in a functional way. However, we can make
it even easier to use. It would be more convenient if we could write
\scalainline{31 jan 2018} in Scala code to mean \scalainline{LocalDate.of(2018,1, 31)} 
and \scalainline{(31 jan 2018) + 2.days} to mean \scalainline{2 feb 2018}, and so on.

\subsection{Programming Task}

Add code to the \lstinline|DateImplicits| object, such that when
a block of code begins with \scalainline{import DateImplicits._}, 
we should be able to write the following:

\begin{enumerate}

  \setcounter{enumi}{5}

  \item We should be able to write \scalainline{15.jan}, \scalainline{4.feb}, \scalainline{20.dec}, and so on to create \scalainline{LocalDate} objects that represent dates in the current year. (i.e., the year in which the code is running.) \textbf{This kind of code should work for all months of the year, with the usual three-letter abbreviations of month names.}

  \item To create \scalainline{LocalDate} objects that represent dates in other years, we should be able to write \scalainline{15.oct(1989)}. Note that this is the same as writing \scalainline{15 oct 1989}.

  \item \textbf{(Tricky)}. If \scalainline{x} is a  \scalainline{LocalDate}, we should be able to add days, months, and years in the following way: \scalainline{x + 10.days}, \scalainline{x + 2.months}, and \scalainline{x + 5.years}.

\end{enumerate}

We should be able to combine both notations. For example, \scalainline{(31 jan 2016) + 2.days} should be equal to \scalainline{LocalDate.of(2016, 2, 2)}. Note that the parentheses around the date are necessary because \scalainline{1 jan 2016 + 2.days} is interpreted as \scalainline{1 jan (2016 + 2.days)}. 

\input{handin}


\chapter{Lesson Plan: Introduction}
\savepdf{instructor-intro}

\begin{enumerate}

\item Introduce the course VM.


\item Briefly introduce the console and start \verb|sbt console|.

\item Show basic boolean and arithmetic expressions.

\item Declare a variable with \lstinline|val|. Talk through the output.
Show \emph{type inference}.

\item Define the \lstinline|twice| and \lstinline|double| functions.
Do not use a block. Explain the notation.

\item Declare a function with local variables, e.g., distance between
two points.

\item Introduce projects: in principle you can write a whole program
line by line. But, we want to save files.

\item  Introduce \verb|mkdir|, \verb|cd|, and, \verb|ls|

\item Slowly talk through the command-line commands involved in
creating, changing to it, and starting \sbt{}. Create
the \texttt{plugins.sbt} file with the line

\begin{lstlisting}
addSbtPlugin("edu.umass.cs" % "compsci220" % "1.1.0")
\end{lstlisting}

\item Use a text editor to create a file with one of the function
we wrote earlier. Handwave through the top-level object.
 \textbf{Scala wart:} Do not \verb|extend App| because it can't be evaluated in console.

\item Start SBT console and import the object. Show that its names
are available.

\item Propose a new function to write. Write the test-cases first, then
the implementation and re-run \verb|sbt test|.

\item Recap the development methodology: first write tests cases, then
write the implementation, and re-test continuously. Show continuous
testing with \verb|~test|.

\item Lists and patterns

\begin{enumerate}

  \item Show the list constructors
  \item Show the fully-parenthesized notation
  \item Show the \lstinline|List| shorthand. Explain that all is the same.
  \item Show that Scala is inferring types for the list.
  \item Write a list-producing function, such as fromTo
  \item Propose writing a list-consuming function, such as sum. There are two cases.
  \item Show pattern matching
  \item Write the count-ones function with a conditional
  \item Make it shorter using complex patterns
  \item Show exhaustivity checking by deleting a case
  \item Show unreachability checking by deleting a case

\end{enumerate}

\item Immutability

\begin{enumerate}

  \item From the console: show that our list-producing functions do not
  change the original list

  \item Show that you cannot redefine vals in files

\end{enumerate}
\end{enumerate}

\chapter{Lesson Plan: Pattern Matching and Testing}
\savepdf{instructor-pattern-matching}

\lstset{language=scala}

\section*{Lesson Plan}

\begin{enumerate}

  \item Previous lecture recap:

\begin{enumerate}

  \item Slowly talk through the command-line commands involved in
  creating, changing to it, and starting \sbt{}. Create
  the \texttt{plugins.sbt} file with the line

  \begin{lstlisting}
  addSbtPlugin("edu.umass.cs" % "compsci220" % "1.1.0")
  \end{lstlisting}

  \item Create a file with\lstinline|repeatTwice(alist: List[Int]): List[Int]|.

  \item Create a test-suite for the function and run it using \sbt{}.

  \item Emphasize immutability using the console.

  \item Create \lstinline|countTens(alist: List[Int]): Int|.

  \item Show exhuastivity check (forget a case) and reachability check (reorder cases).

  \item Show complex patterns (e.g., matching 2nd item in a list).

\end{enumerate}

  \item \lstinline|Time| class in Java vs. Scala: it's a lot shorter

  \item case classes: no need to write new, all fields public, toString and equals that make sense.

  \item Write \lstinline|tick(atime: Time): Time| without pattern matching.

  \item Pattern matching on \lstinline|Time|:

  \begin{scalacode}
  def tick(atime: Time): Time = atime match {
    case Time(23, 59, 59) => Time(0, 0, 0)
    case Time(h, 59, 59) => Time(h + 1, 0, 0)
    case Time(h, m, 59) => Time(h, m + 1, 0)
    case Time(h, m, s) => Time(h, m, s + 1)
  }
  \end{scalacode}

  \item Introduce \lstinline|Time12| and write \lstinline|during220(atime: Any): Boolean|.

  \item Emphasize that we can get a runtime error if we mis-apply the function.

  \item Introduce \lstinline|trait Timey| and change type.

  \item Introduce \lstinline|sealed trait Timey| and show that we get exhaustivity checks.

  \item Main point: your data structures can leverage
  exhuastivity and pattern matching. It is not just for built-in
  types.

  \item Recursive types:

  \begin{enumerate}

  \item Define type \lstinline|BinTree| with string keys and integer values.

  \item Write \lstinline|find| and \lstinline|insert| and think about properties.

  \end{enumerate}

\end{enumerate}

\chapter{Lesson Plan: First-Class Functions I}
\savepdf{instructor-first-class-functions-1}


\begin{enumerate}

  \item \textbf{Print debugging:} show that printfs can be used in blocks at some point in the lecture.

  \item Generic functions and type inference

  \begin{enumerate}

  \item Two functions \lstinline|length(alist: List[String]): Int| and \lstinline|length(alist: List[Int]): Int|.

  \item Introduce the \emph{type argument} \lstinline|length[A](alist: List[A]): Int|

  \item Type inference figures out the type parameter: show explicit type argument passing.

  \end{enumerate}

  \item Generic data structures: binary trees and lists.

  \item Higher-order functions (\lstinline|map|):

  \begin{enumerate}

    \item Introduce \lstinline|incrs(alist: List[Int]): List[Int]|,
      \lstinline|doubles(alist: List[Int]): List[Int]|, and \lstinline|lengths(alist: List[String]): List[Int]|.

    \item Refactor to use an externally defined function

    \item Introduce \lstinline|map|

    \item Show explicit type-parameter usage

  \end{enumerate}

  \item Show \lstinline|filter| with \lstinline|filterEven| and \lstinline|filterOdd|.

  \item Show \lstinline|takeWhile|.

  \item Show generic sorting by introducing insertion sort.

  \item Show the builtin methods on lists.

\end{enumerate}

\chapter{Lesson Plan: First-Class Functions II}
\savepdf{instructor-first-class-functions-2}

\begin{itemize}

\item Example functions: \lstinline|sum|, \lstinline|product|, \lstinline|concat|. Abstract their differences.

\item Write \lstinline|fold| without annotations, then reason through the types.

\item Functions can be passed as arguments to other functions (already seen examples).

\item Functions can be nested within other functions (e.g., nest the little helper functions).

\item Functions can produce functions (\lstinline|makeAdder|).

\item Functions do not need to be named. \lstinline|def| is sugar for
  \lstinline|val|. Refactor \lstinline|makeAdder| and show anonymous
  functions used with higher-order functions.

\item Functions can be stored in data structures:
  \lstinline|case class Foo(m1: Int => Int, m2: Int => Int)|.

\item Define \emph{higher-order function} and \emph{first-class function}.

\item Example of scope:

  \begin{scalacode}
  def f(x: Int): Int = {
    val y = x + 10
    y
  }
  f(11)
  y
  \end{scalacode}

\item Example of shadowing: reason through it by
  substitution. \emph{Every line is a Scala program}

\item Object-oriented programming:

\begin{scalacode}
case class Point(
  getX: () => Double,
  getY: () => Double,
  mag: () => Double,
  add => Point => Point)

def makePoint(x: Double, y: Double): Point = ...
\end{scalacode}

\end{itemize}

\chapter{Lesson Plan: Handling Errors}
\savepdf{instructor-option-type}

\begin{enumerate}

  \item How do we represent partial functions:
  
    \begin{enumerate}
  
      \item Throwing exceptions: \lstinline|Integer.parseInt("hello")|
  
      \item Producing \lstinline|null|: \lstinline|get| method of
        \lstinline|java.util.Hashtable|.
  
      \item Producing \lstinline|NaN|:
  \begin{scalacode}
   case class Point(x: Double, y: Double)
  
   def inter(m1: Double, b1: Double, m2: Double, b2: Double): Point = {
     val x = (b2 - b1) / (m1 - m2)
     Point(x, m1 * x + b1)
   }
  \end{scalacode}
  
        
    \end{enumerate}
  
    \item Problem summary: the types of these functions are a lie. And
      you have to remember how they are lying to you.
  
    \item Use \lstinline|SomePoint| and \lstinline|NoPoint| to refactor.
  
    \item Refactor using \lstinline|Option[Point]|
  
    \item Not only useful for you, but \lstinline|Option[A]| is used all over
      Scala libraries.
  
    \item Some examples of builtin list-processing functions:
      \lstinline|take|, \lstinline|exists|, \lstinline|forall|,
      \lstinline|map|. Show that \lstinline|:::| is an ordinary method.
  
    \item The \lstinline|Set| type and methods on it.
  
    \item Show the built-in \scalainline|Map| and its \scalainline|get|
      method. Unpack the notation for adding elements to a map.
  
    \item Show conversions between data structures (\lstinline|.toList|,
      \lstinline|.toMap|, etc.)
  
    \item Data wrangling demo:
  
      \begin{enumerate}
  
        
    \item Visit \url{https://github.com/fivethirtyeight/data} and show what's
    there.
  
    \item Explain CSV files
  
    \item Download the file
  
    \url{https://raw.githubusercontent.com/fivethirtyeight/data/master/congress-age/congress-terms.csv}
  
    \item Explain \texttt{build.sbt}
  
  \end{enumerate}
  
  \scalafile{code/wrangling/Main.scala}
  
  \end{enumerate}

\chapter{Lesson Plan: Expression Problem}
\savepdf{instructor-expression-problem}

\begin{enumerate}

  \item Create a project called \lstinline|fshapes| and give it a
    name, organization, and version number \lstinline|build.sbt|.
    
  \item Define the \lstinline{fshapes} library, with
    \lstinline|Circle(radius)| and \lstinline|Square(side)| as case
    classes and a function \lstinline|inShape(s: Shape, x: Double, y: Double)| that
    uses pattern matching.

  \item Show \lstinline|publishLocal|.

  \item Create a project called \lstinline|jshapes| and fill \lstinline|build.sbt|
   as before.

   \item Show a Point class (not a case class). Show how to make fields
    public, show how to define methods and derived fields.

  \item Show that the entire body of the class can be thought of as a
    constructor, by putting a println in the body.

  \item Delete \lstinline|Point| and create two classes (not case-classes) that
    implement the \lstinline|Shape| trait.

  \item Translate the \lstinline|inShape| function into a method in \lstinline|Shape|
    that uses \lstinline|.isInstanceOf| and \lstinline|.asInstanceOf| instead of
    pattern matching. Say this is terrible.

  \item Rewrite \lstinline|inShape| using dynamic dispatch: note that
    the method bodies are exactly the same as the cases in the
    functional version! \textbf{Make the fields private.}

  \item Recipe: a function that pattern matches, turns into a method on the interface
    and each case becomes an implementation in the corresponding class.

  \item Exhaustivity check: Scala gives you an exhaustivity check in
    the functional code, but we don't have the exhaustivity check.

  \item Using libraries: suppose we found \lstinline|fshapes| and \lstinline|jshapes|
    on the Web. Which should we use? Is it just a matter of style, or are there objective
    criteria for preferring one over the other?

  \item A library is rarely ``complete''. We typically need to extend it. Suppose we
    don't want to edit the source code (or cannot do so).

  \item Add a new \emph{feature} to both libraries: the ability to
    double a shape in size. It is easy in the functional case. In the
    object-oriented case, we need to write a \lstinline|growShape|
    function using type-tests. \textbf{But, this fails because the
      fields are private.} We need to write a wrapper instead. Lots of extra code!

  \item Add anew \emph{data type} to both libraries: easy in the object-oriented
    case. It can't be done in the functional case without a wrapper. Lots of extra code!

  \item Which library should you pick? The one that supports the extensions that you
    anticipate needing to make. What if you want to do both? You're screwed!

\end{enumerate}

\chapter{Lesson Plan: Subtyping}
\savepdf{instructor-subtyping}

\begin{itemize}

  \item Show singleton pattern in Java and then in Scala.
  \item Show case objects, using \lstinline|Leaf| of a binary tree as an example.
  \item Introduce $A <: B$ notation.
  \item Intuition: the subtype can add more behavior, but cannot contradict or remove behavior.
  \item Example hierarchy: \lstinline|Animal| with \lstinline|sound| method. \lstinline|Dog extends Animal| and defines \lstinline|bite|.
    \lstinline|Cat extends Animal| and defines \lstinline|scratch|. \lstinline|Poodle extends Dog| and overrides \lstinline|sound|.
  \item Write out several subtyping relations and give examples of programs that do not typecheck.
  \item Introduce the \lstinline|Any| and \lstinline|Nothing| types and their relationship to all other types.
  \item Introduce a generic container with a single cell and get/set methods.
  \item Cannot stores cats in a \lstinline|C[Dog]|, since we may try to extract and \lstinline|.bite|.
  \item Cannot pass a \lstinline|C[Dog]| to a function that expects a \lstinline|C[Animal]|.
  \item We are going to do \emph{declarative-site variance}.
  \item Show that a Scala list of dogs can be treated as a list of animals.
  \item Introduce the co-variance annotation: \lstinline|+T|. This makes the setter untypable.
  \item Define the \lstinline|List| type in the right way with \lstinline|Nil| as a case object.
  \end{itemize}

\chapter{Lesson Plan: Streams}
\savepdf{instructor-streams}

Note that we don't have any assignment that requires
streams. Apparently, Programming in Scala 2nd ed. doesn't mention
streams at all.
   
\section*{Lecture Outline}

\begin{enumerate}

\item Show the function \lstinline|def fromTo(m: Int, n: Int): Stream[Int]|
  with \lstinline|println|s in the body to show that the body is only evaluated
  on need. Constrast to \lstinline|def fromTo(m: Int, n: Int): List[Int]|.

\item Show the function \lstinline|def from(n: Int): Stream[Int]| and use
  it to define a stream of positive numbers.

\item Define \lstinline|def nthFib(nPredPred: Stream[Int], nPred: Stream[Int]): Stream[Int]|.

\item Show stream combinators, such as map, filter, etc.

\item Show that filter can produce an infinite loop if nothing in the stream
  matches the predicate.

\item Generate all elements from an infinite stream by interleaving.

\end{enumerate}


\chapter{Lesson Plan: Enumerating the Rationals}
\savepdf{instructor-enumerating-rationals}

\begin{enumerate}

\item We can use \lstinline|Stream.from(n)| to produce an infinite stream of integers.

\item We can also produce an infinite stream of fractions:

  \begin{lstlisting}
  Stream.from(1).map(m => Stream.from(1).map(n => s"$m/$n")).flatten
  \end{lstlisting}

\item This stream starts with the sequence \lstinline|1/1|, \lstinline|1/2|, \lstinline|1/3|, etc.
  so we will never reach \lstinline|2/1|.

\item Draw a few rows of the table of fractions and show that we need to walk the diagonals.

\item Intuition: don't flatten the stream of streams above by waiting for the first inner stream
  to terminate. Instead, produce one element from the first stream, then one element from the
  first two streams each, then one element from the first three streams each, and so on.

  \begin{lstlisting}
def diags[A](xss: Stream[Stream[A]], yss: Stream[Stream[A]]): Stream[A] = {
  if (yss.isEmpty) xss.map(_.head) #::: diags(xss.map(_.tail), yss)
  else xss.map(_.head) #::: diags(yss.head #:: xss.map(_.tail), yss.tail)
}

val rats1 = diags(Stream(), nats.map(m => nats.map(n => Rat(m, n))))
  \end{lstlisting}

\item Unfortunately, this produces repeated numbers!

\item Enumerating the rationals directly produces duplicates. So, we
  need to map rationals to some other object such that two equal rationals map to the
  same object and enumerate those objects.

\item Consider the GCD. Calculate GCD by hand for 3 equal rationals. Show that GCD is different
  but operations are the same.

\item Consider instrumented version of GCD that produces a trace:

  \begin{lstlisting}
    def igcd(m: Int, n: Int): (Int, List[Boolean]) = {
      if (m < n) igcd(m, n - m).map { case (r, trace) => (r, false :: trace) }
      else if (m > n) igcd(m - n, n).map { case (r, trace) => (r, true :: trace) }
      else (m, Nil)
    }
  \end{lstlisting}

  Two equal rationals always have the same trace (but different GCDs)

\item We can invert the function

  \begin{lstlisting}
  def ungcd(r: Int, trace: List[Boolean]): (Int, Int) = trace match {
    case Nil => (r, r)
    case false :: rest => ungcd(r, rest).map { case (m, n) => (m, n + m) }
    case true :: rest => ungcd(r, rest).map { case (m, n) => (m + n, n) }
  }
  \end{lstlisting}

\item If we fix $r = 1$ (or any other value) and we enumerate boolean strings, it is easy to
  solve the problem.

\end{enumerate}


\chapter{Lesson Plan: Generators}
\savepdf{instructor-generators}
  
\begin{enumerate}

\item Define \lstinline|BinTree[+A]|.

\item Define \lstinline|def fringe[A](atree: BinTree[A]): List[A]| and write \lstinline|sameFringe| naively. Explain what's wrong with it.

\item Define \lstinline|class FringeIterator[A](atree: BinTree[A] extends Iterator[A]| and write \lstinline|sameFringe| efficiently.

\item The problem seems fundamentally imperative, isn't it?

\item Introduce by-name arguments, using \lstinline|println| to observe the order of operations.

\item Define \lstinline|Generator[T]| with \lstinline|hasNext| and \lstinline|next| methods. Refactor \lstinline|next| to produce \lstinline|Option[(T, Generator[T])]|.

\item Write a generator of three values manually.

\item Introduce the functions \lstinline|zero|, \lstinline|one|, and \lstinline|append| (using by-name arguments).

\item Add the \lstinline|++| method to \lstinline|Generator[T]|.

\item Write the fringe-generator.

\item Notice that the fringe generator looks a lot like the function that returns the fringe as a list!

\end{enumerate}  

\chapter{Lesson Plan: Stack Machines}
\savepdf{instructor-stack-machines}

\begin{enumerate}

  \item Introduction: Over the next two lectures, we'll look under the
hood and discuss some of the ideas used to build the Scala compiler
and the Java virtual machine.  Most of the time, you will not have to
think about these kinds of low-level details.  However, to write
performance-critical code or to debug low-level errors, you will need
to know this kind of work.

  \item Ambiguity in parsing arithmetic expressions

  \item In Scala \lstinline|1 + 2| and \lstinline|1.+(2)| mean the same thing

  \item Concrete vs. abstract syntax: draw the abstract syntax trees for arithmetic expressions

  \item Define the \lstinline|Expr| datatype. (Include subtraction!)

  \item A \emph{parser} takes a concrete syntax string and turns it into an abstract syntax tree

  \item Scala AST example:

\begin{lstlisting}
import scala.tools.reflect._
import scala.reflect.runtime.universe._
val tb = runtimeMirror(getClass.getClassLoader).mkToolBox()
val tree = tb.parse("""(x: Int, y: Int, z: Int) => x + y * z""")
tb.eval(tree)
res0.asInstanceOf[(Int, Int, Int) => Int](1, 2, 3)
\end{lstlisting}

  \item Write recursive evaluator \lstinline|def eval(e: Expr): Int|, but this is not how Scala is evaluated

  \item Show Java compilation process:
    and show that \lstinline|javac| produces the .class file
  and that \lstinline|java|. TalEclipse, etc. do this under the hood.

  \item 

  \begin{enumerate}

    \item Write a class with static main  and factorial method

    \item Show that \texttt{javac} produces the class file

    \item Show that \texttt{java} runs the class file and it works even if the source code is deleted

    \item An IDE uses this stuff under the hood

    \item Disassemble the classfile using \texttt{javap -c Simple.class} and show the instruction stack

    \item Show the class files that Scala generates

  \end{enumerate}

  \item Define instructions and write
  \lstinline|eval(code: List[Instruction], stack: List[Int]): List[Int]|
  and \lstinline|compile(e: Expr): List[Instruction]|
  
\end{enumerate}

\chapter{Lesson Plan: Shell Scripting and String Processing Combinators}
\savepdf{instructor-shell-scripting}

\chapter{Shell Scripting and Function Composition}
\savepdf{shell-scripting-and-composition}

\textbf{Required materials:} A Moodle sheet \emph{without grades}.

\section{Shell Scripting}

\begin{enumerate}

  \item We will first take a small detour from Scala to learn basic
\emph{shell scripting}. Shell scripts let you quickly automate repetitive tasks
that frequently occur while programming. Therefore, knowing how to write shell
scripts will make you a better programmer. Once we are done with shell
scripting, we will study the design principles that underly shell scripting,
known as \emph{combinators}, and see that they are applicable to a wide variety
of problems.


  \item Recap basic shell scripting functions, i.e., \lstinline|cd|, \lstinline|mkdir|, \lstinline|rm|, etc.

  \item Review additional commands. i.e., \lstinline|cat|, \lstinline|uniq|,
  \lstinline|uniq|, \lstinline|sort|, \lstinline|cut|, \lstinline|grep|,
  \lstinline|paste| (similar to zip), \lstinline|head|, \lstinline|tail|.


  \item Show redirecting output, \lstinline|ls > output.txt|.

  \item show redirecting input \lstinline|sort < input.txt|

  \item \emph{Example:} Suppose we want to sort \lstinline|moodle.csv| by name:

  \begin{lstlisting}
  sort -k 2 -t , ~/Downloads/moodle.csv
  \end{lstlisting}

  \item \emph{Example:} Support we want to get the first five names (in alphabetical)
  order.


  \begin{lstlisting}
  sort -k 2 -t , ~/Downloads/moodle.csv > temp; head -n 5 tmp
  \end{lstlisting}

  alternatively

  \begin{lstlisting}
  sort -k 2 -t , ~/Downloads/moodle.csv | head -n 5
  \end{lstlisting}
  

  \item \emph{Example:} Getting student IDs out of \lstinline|moodle.csv|:

  \begin{lstlisting}
  cut -f 1 -d , | cut -f 2 -d ' '
  \end{lstlisting}

  
  \item \emph{Example:} Creating directories for each student

  \begin{lstlisting}
  cut -f 1 -d , | cut -f 2 -d ' ' | xargs mkdir
  \end{lstlisting}

  \item Show an example of handling errors with $\|$.

  \item Key operators: concatenate results, sequence operations, try one then
  another.

\end{enumerate}

\section{Programming with Combinators}

\textbf{See includes/streams}

\begin{itemize}

  \item Define a class for operations of type \lstinline|List[String] => Option[List[String]]|

  \item Show that we can read all lines from a file using NIO

  \item Define some atomic operations, filter, sort, head, tail, cut, uniq

  \item Define higher-order operators: concatenation, sequence, orElse

  \item \emph{Alternate design}: why not use objects, this way we can define
  new operations.

\end{itemize}

\chapter{Lesson Plan: Generators Lab}
\savepdf{instructor-generators-lab}

Start by reading the Generators assignment carefully and doing it yourself.
The high level goal is to cover the \lstinline|from| and \lstinline|nth|
functions. The \lstinline|from| function will give students a sense of how
to program with generators and the \lstinline|nth| function is essential
for testing.

Here is a way to approach the lab:

\begin{enumerate}

\item The \lstinline|ones| generator is already provided.

\item To get the first $1$:

\begin{lstlisting}
val (x1, rest1) = ones.next()
println(x1)
\end{lstlisting}

\item To get the second $1$:

\begin{lstlisting}
val (x2, rest2) = rest1.next()
println(x2)
\end{lstlisting}

\item This is silly, since they are all the same, so define \lstinline|from|

\begin{lstlisting}
def from(x: Int): Generator[Int] = cons(x, from(x + 1))
\end{lstlisting}

The key detail to point out is that this looks like an infinite loop: i.e.,
there is no base case. However, since the second argument to
\lstinline|cons| is a \emph{by-name argument}, the program doesn't make the
recursive call to \lstinline|cons| unless it is needed.

\item Repeat the same experiment to generate values using \lstinline|from|:

\begin{lstlisting}
val nums = from(10)
val (x1, rest1) = nums.next()
println(x1) // 10
val (x2, rest2) = rest1.next()
println(x2) // 11
// and so on
\end{lstlisting}

\item This is very cumbersome, so work through the $n$th function:
  
\begin{lstlisting}
def nth[A](agen: Generator[A], index: Int): A = {
  if (index == 0) {
    val (x, _) = agen.next()
    x
  }
  else {
    val (_, rest) = agen.next()
    nth(rest, index - 1)
  }
}
\end{lstlisting}

\item This function is helpful for testing. E.g.,

\begin{lstlisting}
test("testing from") {
  assert(nth(from(10), 10) == 20)
}
\end{lstlisting}

\end{enumerate}

\chapter{Lesson Plan: Implicit Classes}
\savepdf{instructor-implicits}

\begin{enumerate}

\item Create a Java file with  a \lstinline|Vector2D| class that has
  \lstinline|add| and \lstinline|mul| methods.

\item Show that we can use the Java class in Scala code, but it doesn't feel very
  Scala-like. 9Show the Scala version.)

\item One solution: write an an \emph{adaptor}. Problem: we'd have to wrap
  every single method (and there could be many, many methods).

\item In principle, we want to modify the existing class, but classes cannot
  be modified after they are defined.

\item Show the implicit class \lstinline|RichVector2D|.

\item Show how a simple expression with vectors is elaborated.

\item However, we can write \lstinline|vec * 3|, but not \lstinline|3 * vec|.
Fix this by introducing \lstinline|RichInt|.

\item Show an implicit function that converts int-tuples to vectors. Warn that 
  this is a bad idea.

\item Explain that implicits should be in their own object.

\item Show the \lstinline|process| and \lstinline|duration| DSLs.

\end{enumerate}

\chapter{Lesson Plan: Implicits Lab}
\savepdf{instructor-implicits-lab}

This lab will cover the first two questions of the Implicits project, 
which asks you to use Scala implicits to wrap ``ugly'' Java interfaces with ``pretty'' Scala interfaces.

\section{What you need to do}

Complete the first two programming tasks of the Implicits project in the lab.
The two tasks are reproduced below:

\begin{enumerate}

  \item We should be able to construct paths by using the slash-operator to separate strings. 
  For example, the expression \scalainline{"usr" / "bin" / "scala"} should be equivalent to the expression \scalainline{Paths.get("usr", "bin", "scala")}. 
  
  \item Similarly, given two paths, we should be able to join them using the slash-operator. 
  For example, if \scalainline{p1} is \scalainline{"usr" / "local"} and \scalainline{p2} is \scalainline{"bin" / "scala"} then \scalainline{p1 / p2} should be equivalent to \scalainline{Paths.get("usr", "local", "bin", "scala")}. 
\end{enumerate}

\section{Hints}

First hint: this assignment requires \emph{neither} Scala implicit functions 
to work \emph{nor} Scala implicit function parameters.  
You \emph{only} need Scala implicit classes.  If you do not 
remember the difference between these sorts of implicits, I strongly 
suggest that you familiarize yourself with their definitions.

Second hint: remember that Scala implicit classes require a few ingredients
 in order to work.  The most important ingredients are described here, but 
 you can find the complete list of rules at: \url{https://www.artima.com/pins1ed/implicit-conversions-and-parameters.html#21.2}

\begin{enumerate}
  \item You must create a class and mark it as \scalainline{implicit}.
  \item Implicit classes must be defined inside an \scalainline{object}.
  \item The implicit class must be visible from the scope of the expression that you want rewritten.
  \item The compiler \emph{will not} attempt to rewrite an expression to use an
   implicit class if it type-checks as-is.  In other words, the expression must 
   fail to type check \emph{unless} the compiler can find an implicit class in scope that causes the type check to succeed.
\end{enumerate}

\section{Solutions}

This is a solution to the first two programming tasks.

\begin{scalacode}
  import java.nio.file._

  object PathImplicits {  
    implicit class RichPath(p: Path) {
      def /(p2: String) : Path = p.resolve(p2)
      def /(p2: Path) : Path = p.resolve(p2)
    }

    implicit class RichString(s: String) {
      def /(s2: String) : Path = Paths.get(s).resolve(s2)
      def /(p2: Path) : Path = Paths.get(s).resolve(p2)
    }
  }
\end{scalacode}

\chapter{Lesson Plan: N Queens}
\savepdf{instructor-nqueens}

\begin{enumerate}

  \item Setup a file with the \lstinline|ChessBoardLike| trait.

  \item Do $n$-queens on paper with the class.

  \item Main idea: write a recursive function that places 1 new queen that
  doesn't threaten any existing queen. Terminate when $n$ queens have been
  placed. If a queen can't be placed, \emph{backtrack}.

  \item A naive solution:

\begin{lstlisting}
class NaiveQueens(val dim: Int, val solution: Set[(Int,Int)]) extends ChessBoardLike {
  def canPlace(x: Int, y: Int): Boolean 
  def solveRec(coords: List[(Int, Int)]): Option[NaiveQueens]
  def solve(): Option[NaiveQueens]   
}
\end{lstlisting}

  \item With $n = 11$, solves instantly. $n = 12$ takes a minute.

  \item Constraint propagation: instead of checking every space, keep a list
  of available spaces.

\begin{lstlisting}
class OptQueens(val dim: Int, 
                val solution: Set[(Int, Int)], 
                available: List[(Int, Int)]) extends ChessBoardLike {
  def place(x: Int, y: Int): OptQueens
  def solveRec(coords: List[(Int, Int)]): Option[OptQueens]
  def solve(): Option[OptQueens]
}

object OptQueens {
  def empty(dim: Int): OptQueens
}  
\end{lstlisting}

  \item Randomness: use \lstinline|util.Random.shuffle| to visit spaces in a random
  order.

\end{enumerate}

\chapter{Lesson Plan: Bounded Quantification}
\savepdf{instructor-bounded-quantification}

\begin{itemize}

  \item Show a \lstinline|sort| function that takes a \lstinline|toInt| projection.

  \item Show how to project a \lstinline|Person(name, age)| case class to age to sort.

  \item Add a \lstinline|toInt| method to \lstinline|Person| and try to call it from sort: it fails.

  \item Add an \lstinline|IntLike| trait and modify \lstinline|sort| to use it. Unfortunately, return
    type is not useful.

  \item Use bounded quantification: \lstinline|def sort[A <: IntLike](alist: List[A]): List[A]|.

  \item Scala traits can take type parameters:

    \begin{scalacode}
trait T[X,Y,Z] {
  def f(x: X): Y
  def g(z: Z): Z
}

class C1 extends T[???, ???, ???] {
  def f(x: Int): String = x.toString
  def g(z: Boolean): Boolean = !z
}

class C2 extends T[???, ???, ???] {
  def f(x: Int): String = x.toString
  def g(z: Boolean): Int = 42
}

class C3(head: Int, tail: C3) extends T[???, ???, ???] {
  def f(x: Int): C3 = new C3(x, this)
  def g(z: C3): C3 = z
}

class C4[A](head: A, tail: C4[A]) extends T[???, ???, ???] {
  def f(x: A): C4[A] = new C4[A](x, this)
  def g(z: C4[A]): C4[A] = z
}
\end{scalacode}


\item Recursive bounded quantification: let's add a \lstinline|lessThan| method to \lstinline|Person|
  and a \lstinline|Time|.

\item Abstract their differences into a \lstinline|Comparable| interface.

\item Show bounded quantification in Java and Scala standard libraries.

\end{itemize}

\chapter{EOF}

\end{document}
