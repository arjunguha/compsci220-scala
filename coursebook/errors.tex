\newlecture

\begin{instructor}

\section*{Lecture Outline}

\begin{enumerate}

\item How do we represent partial functions:

  \begin{enumerate}

    \item Throwing exceptions: \lstinline|Integer.parseInt("hello")|

    \item Producing \lstinline|null|: \lstinline|get| method of
      \lstinline|java.util.Hashtable|.

    \item Producing \lstinline|NaN|:
\begin{scalacode}
 case class Point(x: Double, y: Double)

 def inter(m1: Double, b1: Double, m2: Double, b2: Double): Point = {
   val x = (b2 - b1) / (m1 - m2)
   Point(x, m1 * x + b1)
 }
\end{scalacode}

      
  \end{enumerate}

  \item Problem summary: the types of these functions are a lie. And
    you have to remember how they are lying to you.

  \item Use \lstinline|SomePoint| and \lstinline|NoPoint| to refactor.

  \item Refactor using \lstinline|Option[Point]|

  \item Not only useful for you, but \lstinline|Option[A]| is used all over
    Scala libraries.

  \item Some examples of builtin list-processing functions:
    \lstinline|take|, \lstinline|exists|, \lstinline|forall|,
    \lstinline|map|. Show that \lstinline|:::| is an ordinary method.

  \item The \lstinline|Set| type and methods on it.

  \item Show the built-in \scalainline|Map| and its \scalainline|get|
    method. Unpack the notation for adding elements to a map.

  \item Show conversions between data structures (\lstinline|.toList|,
    \lstinline|.toMap|, etc.)

  \item Data wrangling demo:

    \begin{enumerate}

      
  \item Visit \url{https://github.com/fivethirtyeight/data} and show what's
  there.

  \item Explain CSV files

  \item Download the file

  \url{https://raw.githubusercontent.com/fivethirtyeight/data/master/congress-age/congress-terms.csv}

  \item Explain \texttt{build.sbt}

\end{enumerate}

\scalafile{code/wrangling/Main.scala}

\end{enumerate}
  
\end{instructor}

\section{Required Reading}

Read Chapters 16 and 17 of \emph{Programming in Scala}.\footnote{The
  first edition is available online at
  \url{http://www.artima.com/pins1ed/}. The material in these chapters
  apply to the current version of Scala.} In Chapter 17, focus on
immutable collections. We will not use mutable collections in this class, so you can
skip reading about list buffers, array buffers, and arrays.

\section{Partial Functions and Signalling Errors}

Many functions are not defined on all inputs. For example, if you're reading
input from a keyboard (i.e., a string) and want to parse the string as a
number, you can apply \scalainline{Integer.parseInt}:

\begin{console}
scala> val n = Integer.parseInt("10")
n: Int = 10
\end{console}

But, if the string is not a numeral, you get an exception:

\begin{console}
scala> val n = Integer.parseInt("ten")
java.lang.NumberFormatException: For input string: "ten"
\end{console}

You've encountered other ways of signalling errors. For example, if you lookup
an unbound key in a hashtable, Java (and Scala) produce \scalainline{null}s:

\begin{console}
scala> val ht = new java.util.Hashtable[Int, String]()
ht: java.util.Hashtable[Int,String] = {}
scala> ht.put(10, "hello")
scala> val r = ht.get(20)
r: String = null
\end{console}

Finally, here is a more insidious example. The following function calculates the
point where two lines, defined by $y = m_1.x + b_1$ and $y = m2_.x + b_2$, intersect.
The function is not defined when the two lines are parallel (i.e., when their
slopes are the same, or $m_1 = m_2$):

\begin{scalacode}
 case class Point(x: Double, y: Double)

 def inter(m1: Double, b1: Double, m2: Double, b2: Double): Point = {
   val x = (b2 - b1) / (m1 - m2)
   Point(x, m1 * x + b1)
 }
\end{scalacode}

When the slopes are the same, the denominator, \scalainline{m1 - m2} is
\scalainline{0}. So, you
might expect a divide-by-zero \scalainline{ArithmeticException}. That's \emph{not}:
what happens:

\begin{console}
scala> 1.0 / 0.0
res0: Double = Infinity
\end{console}

So you can't even catch this error with an exception handler, since no exception
is raised:

\begin{console}
scala> val r = inter(0, 0, 0, 0)
r: Point = Point(NaN,NaN)
\end{console}

All these mechanisms for signalling errors share similar flaws:
%
\begin{enumerate}

  \item \emph{Exceptions}: you have to remember to catch them, or your program will
   crash. You can't tell if a function will throw an exception without carefully
   reading its code, which may not even be possible if it is in a library.

  \item  \emph{Producing null}: even worse than exceptions, because your program
   will will \emph{not} crash on an error. When it does crash, you'll spend a
   lot of time trying to figure out what produced the \scalainline{null}.

   \item \emph{Producing other null-like values}: see above.

 \end{enumerate}

The real problem is that the types of all these functions are not useful:

\begin{itemize}

  \item The type of \scalainline{Integer.parseInt} is
  \scalainline{String => Int}, but it may throw an exception instead of producing an \scalainline{Int}.

  \item The type of \scalainline{ht.get} is \scalainline{Any => String}, but it
  may produce a \scalainline{null}.

  \item The type of \scalainline{inter} is \scalainline{(Double, Double, Double, Double) => Point},
  but it can produce \scalainline{Point(NaN, NaN)}, which is clearly not what we
  had in mind.

\end{itemize}

\paragraph{A Solution}

Let's use \scalainline{inter} as an example and modify the function so that its type
makes it obvious that it may not always return a \scalainline{Point}. We introduce
the following sealed trait:

\begin{scalacode}
sealed trait OptionalPoint
case class SomePoint(pt: Point) extends OptionalPoint
case class NoPoint() extends OptionalPoint
\end{scalacode}

And we modify \scalainline{inter} to produce \scalainline{NoPoint} instead of a malformed-\scalainline{Point}:

\begin{scalacode}
def inter(m1: Double, b1: Double, m2: Double, b2: Double): OptionalPoint = {
  if (m1 - m2 == 0) {
    NoPoint()
  }
  else {
    val x = (m1 - m2) / (b2 - b1)
    Point(x, m1 * x + b1)
  }
}
\end{scalacode}

With this new type, any program that applies \scalainline{inter} will be forced to check if
if a point was produced:

\begin{scalacode}
  inter(10, 3, 10, 3) match {
    case NoPoint => println("no intersection")
    case SomePoint(Point(x,y)) => println(s"intersection at ($x, $y)")
  }
\end{scalacode}

Consider another example: a type that represents an \emph{alarm clock}. An alarm
clock needs to track the current time and \emph{the alarm time if the alarm is set}:

\begin{scalacode}
case class Time(h: Int, m: Int, s: Int)
case class AlarmClock(time: Time, alarm: Time, alarmOn: Boolean)
\end{scalacode}

But, with this representation, it is easy to make simple errors. For example,
you may accidentally trigger the alarm when \scalainline{time == alarm}, if you forget
to check \scalainline{alarmOn} first. A cleaner represention is to use the same pattern we used
above:

\begin{scalacode}
sealed trait OptionalAlarm
case class NoAlarm() extends OPtionalAlarm
case class AlarmSet(time: Time) extends OptionalAlarm

case class AlarmClock(time: Time, alarm: OptionalAlarm)
\end{scalacode}

In both \scalainline{inter} and \scalainline{AlarmClock}, it is completely
obvious from the type that a point is not always produced and that an alarm is
not always set. Partial functions are \emph{pervasive} in computing and this pattern
will make your programs more robust.

But, it is annoying to define a new type such as \scalainline{OptionalPoint}
and \scalainline{OptionalAlarm} for each type.

\subsection{The Option Type}

Scala has a builtin generic type called \scalainline{Option} that abtracts the
pattern we discussed above. For example, here is \scalainline{inter} rewritten
to use \scalainline{Option}:

\begin{scalacode}
def inter(m1: Double, b1: Double, m2: Double, b2: Double): Option[Point] = {
  if (m1 - m2 == 0) {
    None
  }
  else {
    val x = (m1 - m2) / (b2 - b1)
    Some(Point(x, m1 * x + b1))
  }
}
\end{scalacode}

\section{Built-in List methods}

Scala's \scalainline{List} type has dozens of useful methods. For example,
these methods correspond to the higher-order functions we've seen so far:
%
\begin{itemize}

  \item We can map over a list:

  \begin{scalacode}
  assert(List(10, 20, 30).map(x => x + 1) == List(11, 21, 31))
  \end{scalacode}

  \item We can filter a list:

  \begin{scalacode}
  assert(List(1, 2, 3, 4).filter(x => x % 2 == 0) == List(2, 4))
  \end{scalacode}

  \item We can fold over a list:

  \begin{scalacode}
  assert(List(10, 20, 30).foldRight(0)((x, acc) => x + acc) == 60)
  \end{scalacode}

\end{itemize}

Notice that the syntax of \scalainline{foldRight} is unusual. We'll get into the
details how it works later. For now, there is no need to write sums and products
using folds. Scala's lists have methods that do these directly:

\begin{scalacode}
assert(List(10, 20, 30).sum == 60)
assert(List(10, 20, 30).product == 6000)
\end{scalacode}

There are several other useful methods. For example:

\begin{itemize}

  \item \scalainline{alist.take(n)} produces a list with first \scalainline{n}
  elements of \scalainline{alist}. Similarly, \scalainline{alist.drop(n)} produces
  a list without the first \scalainline{n} elements of \scalainline{alist}.
  %
  \begin{scalacode}
  val alist = List("X", "Y", "Z", "A", "B", "C")
  assert(alist.take(3) == List("X", "Y", "Z"))
  assert(alist.drop(3) == List("A", "B", "C"))
  assert(alist.take(3) ::: alist.drop(3) == alist)
  \end{scalacode}

  In the last line, the \scalainline{:::} operator (pronounced ``append'')
  appends two lists.

  \begin{notation}
  We emphasize that \scalainline{:::} is an ordinary method,
  even though it is written using funny symbols and appears to be an infix
  operator. We could append lists using conventional method-application
  syntax:
  \begin{scalacode}
  assert(alist.:::(alist) == alist ::: alist)
  \end{scalacode}
  In fact, all operators on objects are actually ordinary methods. E.g.,
  we could write \scalainline{2.+(3.*(6))}, to do arithmetic using
  conventional method-application syntax. However, the usual notation
  of \scalainline{2 + (3 * 6)} is typically easier to read.

  \end{notation}

  \item \scalainline{alist.exists(f)} produces \scalainline{true} if there
  exists any element in the list on which \scalainline{f} produces
  \scalainline{true}.

  \begin{scalacode}
  assert(List(1, 2, 3, 4).exists(n => n == 2) == true)
  assert(List(1, 2, 3, 4).exists(n => n == 5) == false)
  \end{scalacode}

  \item \scalainline{alist.forall(f)} checks that all elements in \scalainline{alist}
  satisfy \scalainline{f}:
  %
  \begin{scalacode}
  assert(List(2, 4, 6, 8).forall(x => x % 2 == 0) == true)
  assert(List(2, 3, 4).forall(x => x % 2 == 0) == false)
  \end{scalacode}

\end{itemize}

There are several other useful functions. You should explore the
\href{http://www.scala-lang.org/api/2.11.7/index.html#scala.collection.immutable.List}{List API} to learn more about them.

\section{Sets and Maps}

paragraph{Sets}

The Scala standard library also defines sets and maps, which are two other data
structures that are very common. Note that these represent mathematical sets, so
they don't have duplicate elements and are not ordered. i.e., the three
definitions below are the same:
%
\begin{scalacode}
Set(1, 2, 3)
Set(1, 2, 2, 3)
Set(3, 2, 1)
\end{scalacode}

Sets have methods for calculating set union, set intersection, set difference,
testing emptiness, and so on:
%
\begin{scalacode}
assert(Set(1, 2, 3).union(Set(2, 3, 4)) == Set(1, 2, 3, 4))
assert(Set(1, 2, 3).intersect(Set(2, 3, 4)) == Set(2, 3))
assert(Set(1, 2).intersect(Set(3, 4)).isEmpty == true)
\end{scalacode}

We can also map and filter the elements of sets, similar to lists:
%
\begin{scalacode}
assert(Set(1, 2, 3, 4).filter(x => x % 2 == 0) == Set(2, 4))
assert(Set(1, 2, 3, 4, 5).map(x => x % 2) = Set(0, 1))
\end{scalacode}

There are severy other useful methods in the
\href{http://www.scala-lang.org/api/2.11.7/index.html#scala.collection.immutable.Set}{Set API}.

\paragraph{Maps}
The Map data-structure (which is not the same as the map function) is a finite
map from keys to values. For example:
%
\begin{scalacode}
val dueDates = Map(
  1 -> "Jan 28",
  2 -> "Feb 4",
  3 -> "Feb 11")
\end{scalacode}

\begin{notation}
\scalainline{X -> Y} is just another notation for the tuple
\scalainline{(X, Y)}, but is commonly used with maps to suggest that it
``maps X to Y''. Therefore, we could have writen
\begin{scalacode}
val dueDates = Map(
  (1, "Jan 28"),
  (2, "Feb 4"),
  (3, "Feb 11"))
\end{scalacode}
\end{notation}

We can lookup a key in two ways. First, we can simply apply the map to a key,
just like a function:
\begin{scalacode}
assert(dueDates(1) == "Feb 4")
\end{scalacode}

However, if the key is not found, this throws an exception. An alternative
is to apply the get methods, which produces \scalainline{Some(v)} if the
key is mapped to a value and \scalainline{None} otherwise:
%
\begin{scalacode}
dueDates.get(x) match {
  case Some(v) => v
  case None => "Unknown assignment"
\end{scalacode}

We can augment maps using the following syntax:
\begin{scalacode}
val moreDueDates = dueDates + (4 -> "Feb 18")
\end{scalacode}
We emphasize that this produces a new map with all the contents of
\scalainline{dueDates} and the key mapping for \scalainline{4}.
The original map is not modified.

\begin{notation}
The notation \scalainline{m + (k -> v)} seems to be something
new, but we know how to unpack it. We just learned the arrow notation is
another way of writing tuples, we can first rewrite it as \scalainline{m + (k, v)}.
We also learned that all operators on objects are actually methods, so
can rewrite it again as \scalainline{m.+((k, v))}.

Therefore, we can conclude that maps have a method called \scalainline{+} that
takes one argument. This argument is a tuple where the first component is a key
\scalainline{k} and the second component is the value \scalainline{v}. The
result of applying this method is a new map where \scalainline{k} is mapped to
\scalainline{v}.
\end{notation}

It is often get the set of keys in a map:
\begin{scalacode}
assert(dueDates.keys == Set(1, 2, 3))
\end{scalacode}

Similarly, we can get an \emph{iterator} over the values. Typically, you'll
want to turn the iterator into a list immediately:
\begin{scalacode}
assert(dueDates.values.toList == List("Jan 28", "Feb 4", "Feb 11"))
\end{scalacode}

As usual, there are dozens of handy methods over maps. You should
explore the \href{http://www.scala-lang.org/api/2.11.7/index.html#scala.collection.Map}{Map API}.

\section{Conversions}

It is sometimes necssary and easy to convert lists, sets, and maps to each
other. These objects have methods called \scalainline{toList},
\scalainline{toSet}, and \scalainline{toMap} that do exactly what their
names suggest. For example:
%
\begin{scalacode}
assert(Map("X" -> 10, "Y" -> 20).toList == List(("X", 10), ("Y", 20)))
assert(List(("X", 10), ("Y", 20)).toMap == Map("X" -> 10, "Y" -> 20))
\end{scalacode}
