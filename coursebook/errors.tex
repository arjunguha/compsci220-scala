\newlecture

\begin{instructor}

\section*{Lecture Outline}

\begin{enumerate}

\item How do we represent partial functions:

  \begin{enumerate}

    \item Throwing exceptions: \lstinline|Integer.parseInt("hello")|

    \item Producing \lstinline|null|: \lstinline|get| method of
      \lstinline|java.util.Hashtable|.

    \item Producing \lstinline|NaN|:
\begin{scalacode}
 case class Point(x: Double, y: Double)

 def inter(m1: Double, b1: Double, m2: Double, b2: Double): Point = {
   val x = (b2 - b1) / (m1 - m2)
   Point(x, m1 * x + b1)
 }
\end{scalacode}

      
  \end{enumerate}

  \item Problem summary: the types of these functions are a lie. And
    you have to remember how they are lying to you.

  \item Use \lstinline|SomePoint| and \lstinline|NoPoint| to refactor.

  \item Refactor using \lstinline|Option[Point]|

  \item Not only useful for you, but \lstinline|Option[A]| is used all over
    Scala libraries.

  \item Some examples of builtin list-processing functions:
    \lstinline|take|, \lstinline|exists|, \lstinline|forall|,
    \lstinline|map|. Show that \lstinline|:::| is an ordinary method.

  \item The \lstinline|Set| type and methods on it.

  \item Show the built-in \scalainline|Map| and its \scalainline|get|
    method. Unpack the notation for adding elements to a map.

  \item Show conversions between data structures (\lstinline|.toList|,
    \lstinline|.toMap|, etc.)

  \item Data wrangling demo:

    \begin{enumerate}

      
  \item Visit \url{https://github.com/fivethirtyeight/data} and show what's
  there.

  \item Explain CSV files

  \item Download the file

  \url{https://raw.githubusercontent.com/fivethirtyeight/data/master/congress-age/congress-terms.csv}

  \item Explain \texttt{build.sbt}

\end{enumerate}

\scalafile{code/wrangling/Main.scala}

\end{enumerate}
  
\end{instructor}

