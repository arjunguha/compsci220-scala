\newlecture

\begin{instructor}
\section*{Lecture Outline}

\begin{enumerate}

  \item Text processing and regexes are everywhere: web page validation, regex
  based search and replace in IDEs, to clean data, in virus scanners.

  \item A regex can be read as a pattern that matches strings. Show some
  examples with constants, the wildcard, and repetition.

  \item Introduce triple-quoted strings.

  \item Introduce \emph{literal characters}, \emph{metacharacters}, and
  escaping.

  \item Introduce the wildcard, character ranges, range complements, alternation,
  and iteration (both \texttt{*} and \texttt{+}).

  \item Examples: match undergraduate CS class numbers, credit card numbers,
  even numbers.

  \item Example of something that can't be matched: palindrome.

  \item Challenge problem: check password strength---at least one letter
  and one digit.

\end{enumerate}

\end{instructor}

\section{Required Reading}

\begin{itemize}

\item \href{http://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html}{Java Regular Expressions}

\item \href{http://www.scala-lang.org/api/current/index.html#scala.util.matching.Regex}{Scala Regular Expressions}

\end{itemize}

\section{Regular Expressions}

Many programs need to do some form of text processing and \emph{regular expressions} are the most fundamental and pervasive text processing tools. Average web pages use regular expressions to validate emails, phone numbers, URLs, and so on; IDEs and programmers' text editors support regular-expression based search and replace; regular expressions are often used to ``clean'' data; and regular expressions are also used in virus scanners, network intrusion detection systems, and other computer security products.

You can think of a regular expression as a pattern that describes a set of strings. For example, the regular expression \texttt{a.*z} describes all strings that start with \scalainline{'a'} and end with \scalainline{'z'}. In a regular expression, the character \texttt{.} means ``any character'' and the symbol \texttt{*} means ``zero or more repetitions''. Therefore, we can read \texttt{a.*z} as ``a, followed by zero or more repetitions of any character, followed by `z'''.

In Scala, you can construct a regular expression by written it as a string and invoking the \scalainline{.r} method. For example:
\begin{scalacode}
val regex = "a.*z".r
\end{scalacode}

We can use the \scalainline{regex.findFirstIn} method to match a string:
\begin{scalacode}
regex.findFirstIn(str)
\end{scalacode}
As the name suggests, the method finds the first substring of \scalainline{str} that matches the regular expression. For example, if \scalainline{str} is \scalainline{"hello abcdz bye"}, the expression produces \scalainline{Some("abcdz")}. However, if no substring matches the regular expression, it produces \scalainline{None}.

\begin{notation}
Regular expressions often use special characters that need to be quoted within strings. For example, the regular expression \texttt{\d} matches a single decimal digit. However, to write this as a string, we'd have to quote the backslash (\scalainline{"\\d"}). This becomes cumbersome very quickly. However, Scala has a special syntax for defining strings that is very handy in this situation. In a  string that is enclosed with triple-quotes, a backslash is interpreted as a literal character and not as the start of an escape sequence. Therefore, we can just write \scalainline{"""\d"""}, which is equivalent to \scalainline{"\\d"}.
\end{notation}

A regular expression can be built in several ways:

\begin{enumerate}

 \item  \emph{Literal characters} that match characters exactly, for example \texttt{a} is a regular expression that only matches the string \scalainline{"a"}.

  \item A \emph{metacharacters}, such as \scalainline{.}, matches any character. For example, the regular expression \texttt{...} matches all strings of length three. If we want to match only the string \scalainline{"..."}, we need to escape the metacharacters and write the regular expression \verb|\.\.\.|. There are a few other metacharacters and they can all be matched by escaping with with a backslash.

  \item A \emph{character range}, such as \scalainline{[0-9]} matches any digit. Several ranges can be composed together. For example, \scalainline{[A-Za-z]} matches uppercase and lowercase letters.

  \item A \emph{range complement} matches all characters not in a range. For example, \scalainline{[^ 0-9]} matches all non-numeric characters.

  \item \emph{Alternation} can be used to match one of several regular expressions. For example, \scalainline{(abc)|(xyz)} matches either \texttt{"abc"} or \texttt{"xyz"}. Similarly, \texttt{a(b|c)d} matches either \scalainline{"abd"} or \scalainline{"acd"}.

  \item \emph{Iteration} can be used to repeat a pattern several times. For example, you can read\texttt{a*} as the pattern \texttt{a} repeated zero or more times. Therefore, this regular expression matches \scalainline{""}, \scalainline{"a"}, \scalainline{"aa"}, and so on. Similarly, \texttt{(hi)*} matches \scalainline{""}, \scalainline{"hi"}, \scalainline{"hihi"}, \scalainline{"hihihi"}, and so on.

  There are several other operators that apply a pattern several times:

  \begin{itemize}
    \item $\mathit{regex}\texttt{+}$ repeats $\mathit{regex}$ one or more times.
    \item $\mathit{regex}\texttt{?}$ matches either the empty string or $\mathit{regex}$.
        \item $\mathit{regex}\texttt{\{m,n\}}$ repeats $\mathit{regex}$ between $m$ and $n$ times.
  \end{itemize}

  \item A \emph{character class}, such as \verb|\d| matches a digit.

\end{enumerate}

\subsection{Examples}

\paragraph{Undergraduate Computer Science Classes} Computer science classes begin with the prefix \texttt{"COMPSCI"}. However, undergraduate classes are numbered 499 or lower. The following regular expression matches undergraduate computer science classes:

\texttt{COMPSCI[1-4].*}

\paragraph{Credit Card Numbers}
A Visa or MasterCard has 16 digits, so the simplest regular expression to match then would be \texttt{\d{16}}. However, people tend to format credit card numbers by grouping them into blocks of four digits and separating the blocks with spaces:

\begin{verbatim}
\d{4} \d{4} \d{4} \d{4}
\end{verbatim}

---or with hyphens---

\begin{verbatim}
\d{4}-\d{4}-\d{4}-\d{4}
\end{verbatim}

We can make both regular expressions more compact by rewriting them as \verb|\d{4}( \d{4}){3}| and \verb|\d{4}(-\d{4}){3}| respectively.

We can also make accept both formats by writing:

\begin{verbatim}
(\d{4} \d{4} \d{4} \d{4})|(\d{4}-\d{4}-\d{4}-\d{4})
\end{verbatim}

---or, using the more compact representation, we could write:
\begin{verbatim}
(\d{4}( \d{4}){3})|(\d{4}(-\d{4}){3})
\end{verbatim}


\begin{think}

What does the following regular expression match?

\begin{verbatim}
\d{4}([ -]\d{4}){3}
\end{verbatim}
\end{think}

\paragraph{Even Numbers}

The following regular expression matches all even numbers:

\begin{verbatim}
\d*(0|2|4|6|8)
\end{verbatim}


