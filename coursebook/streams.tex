\chapter{Lecture: Streams}
\startlecture

\begin{instructor}

 Note that we don't have any assignment that requires
 streams. Apparently, Programming in Scala 2nd ed. doesn't mention
 streams at all.

 \section*{Lecture Outline}

 \begin{enumerate}

 \item Show the function \lstinline|def fromTo(m: Int, n: Int): Stream[Int]|
   with \lstinline|println|s in the body to show that the body is only evaluated
   on need. Constrast to \lstinline|def fromTo(m: Int, n: Int): List[Int]|.

 \item Show the function \lstinline|def from(n: Int): Stream[Int]| and use
   it to define a stream of positive numbers.

 \item Define \lstinline|def nthFib(nPredPred: Stream[Int], nPred: Stream[Int]): Stream[Int]|.

 \item Show stream combinators, such as map, filter, etc.

 \item Show that filter can produce an infinite loop if nothing in the stream
   matches the predicate.

 \item Generate all elements from an infinite stream by interleaving.

 \end{enumerate}
 
\end{instructor}

A \emph{stream} is a data structure that is very similar to a list. We write \lstinline|Stream.Empty| instead
of \lstinline|Nil| to denote the empty stream, and we construct streams using \lstinline|#::| instead of
\lstinline|::|. For example, the following expression is a stream of numbers 1, 2, 3:

\begin{lstlisting}
  1 #:: 2 #:: 3 #:: Stream.Empty
\end{lstlisting}

However, the crucial different between streams and lists is that the tail of a stream (i.e., the right-hand side
of \lstinline|#::| is only evaluated when it is \emph{needed}. For example, the function in
\cref{fromToL} produces a list a numbers and prints to the screen on each recursive call.
If we evaluate \lstinline|fromToL(0, 100)|, we get a list of numbers and 100 lines of output
since the entire list is created immediately.

In contrast, the function \cref{fromToS} produces a
stream of numbers. The expression \lstinline|val astream = fromToS(0, 100)| produces only one
line of output. Instead, each time we evaluate \lstinline|astream.tail|, \lstinline|astream.tail.tail|,
and so on, we get one additional line of output. However, evaluating \lstinline|astream.tail| a second
time doesn't produce any output: i.e., the tail is not re-evaluated.

\begin{figure}
\begin{subfigure}{.45\textwidth}
\begin{scalacode}
def fromToL(m: Int, n: Int): List[Int] = {
  println(s"within fromToL($m, $n)")
  if (m > n)  Nil
  else m :: fromToL(m + 1, n)
}
\end{scalacode}
\caption{Generating a list of numbers.}\label{fromToL}
\end{subfigure}
  \quad
  \vrule
  \quad
  \begin{subfigure}{.45\textwidth}
\begin{scalacode}
def fromToS(m: Int, n: Int): Stream[Int] = {
  println(s"within fromToS($m, $n)")
  if (m > n) Stream.Empty
  else m #:: fromTo(m + 1, n)
}

\end{scalacode}
\caption{Generating a stream of numbers.}\label{fromToS}
  \end{subfigure}
\end{figure}

\section{Infinite Streams}

We can exploit the fact that the tail is only evaluated when needed to create
an infinite stream of numbers:

\begin{scalacode}
def from(n: Int): Stream[Int] = n #:: from(n + 1)

val positives = from(1)
\end{scalacode}

This cannot be done with lists! Morever, the Scala console shows exactly what has
been evaluated:

\begin{console}
scala> positives.tail.tail.tail.tail
res2: scala.collection.immutable.Stream[Int] = Stream(5, ?)
scala> positives
res3: Stream[Int] = Stream(1, 2, 3, 4, 5, ?)
\end{console}

You can work with infinite streams freely, so long as you don't try to access
all the values (your program won't halt--there are inifinitely many values).
E.g., \lstinline|positives.length| does not terminate.


\section{Stream Transformations}

Streams have methods such as \lstinline|.map|, \lstinline|.filter|, \lstinline|.flatMap|, etc.
just like lists. However, they also produce streams. For example, the following expression
produces a stream of even numbers:

\begin{scalacode}
val evens = from(1).filter(n => n % 2 == 0)
\end{scalacode}

However, we have to careful when we use filter. If we filter an infinite stream with a
predicate that matches none of the values in the stream, we will get an infinite loop.
E.g., the following expression is an infinite loop:

\begin{scalacode}
  from(1).filter(n => n < 0)
\end{scalacode}

\section{Fibonnaci Numbers}

The following code produces an infinite stream of fibonnaci numbers:

\begin{scalacode}
def nthFib(nPredPred: Stream[Int], nPred: Stream[Int]): Stream[Int] = {
  (nPredPred.head + nPred.head) #:: nthFib(nPredPred.tail, nPred.tail)
}

val fibs: Stream[Int] = 0 #:: 1 #:: nthFib(fibs, fibs.tail)
\end{scalacode}
