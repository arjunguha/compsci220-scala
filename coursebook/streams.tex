\chapter{Lecture: Streams}
\startlecture

\begin{instructor}

 Note that we don't have any assignment that requires
 streams. Apparently, Programming in Scala 2nd ed. doesn't mention
 streams at all.

 \section*{Lecture Outline}

 \begin{enumerate}

 \item Show the function \lstinline|def fromTo(m: Int, n: Int): Stream[Int]|
   with \lstinline|println|s in the body to show that the body is only evaluated
   on need. Constrast to \lstinline|def fromTo(m: Int, n: Int): List[Int]|.

 \item Show the function \lstinline|def from(n: Int): Stream[Int]| and use
   it to define a stream of positive numbers.

 \item Define \lstinline|def nthFib(nPredPred: Stream[Int], nPred: Stream[Int]): Stream[Int]|.

 \item Show stream combinators, such as map, filter, etc.

 \item Show that filter can produce an infinite loop if nothing in the stream
   matches the predicate.

 \item Generate all elements from an infinite stream by interleaving.

 \end{enumerate}
 
\end{instructor}

A stream is like a list, but its tail is only evaluated ``on need''.

A function to generate a list:

\begin{scalacode}
def fromTo(m: Int, n: Int): List[Int] = {
  println(s"within fromTo($m, $n)")
  if (m > n) {
    List()
  }
  else {
    m :: fromTo(m + 1, n)
  }
}

val x = fromTo(0, 100)
\end{scalacode}

Running this code produces 100 lines of output, since the entire list is
immediately created. We can make a small change to use a stream instead:

\begin{scalacode}
def fromTo(m: Int, n: Int): Stream[Int] = {
  println(s"within fromTo($m, $n)")
  if (m > n) {
    List()
  }
  else {
    m #:: fromTo(m + 1, n)
  }
}

val x = fromTo(0, 100)
\end{scalacode}

We now get 1 line of output each time we run \scalainline{x.tail}, \scalainline{x.tail.tail}.
But, running \scalainline{x.tail} a second time doesn't produce any output: Scala evaluates
the tail ``on need'', but doesn't reevaluate the value.

\section{Infinite streams}

We can define an infinite stream of numbers:

\begin{scalacode}
def from(n: Int): Stream[Int] = n #:: from(n + 1)

val positives = from(1)
\end{scalacode}

This cannot be done with lists! Morever, the Scala console shows exactly what has
been evaluated:

\begin{console}
scala> positives.tail.tail.tail.tail
res2: scala.collection.immutable.Stream[Int] = Stream(5, ?)
scala> positives
res3: Stream[Int] = Stream(1, 2, 3, 4, 5, ?)
\end{console}

You can work with infinite streams freely, so long as you don't try to access
all the values (your program won't halt--there are inifinitely many values).
E.g., `positives.length` does not terminate.

\section{Fibonnaci numbers}

\begin{scalacode}
def nthFib(nPredPred: Stream[Int], nPred: Stream[Int]): Stream[Int] = {
  (nPredPred.head + nPred.head) #:: nthFib(nPredPred.tail, nPred.tail)
}

val fibs: Stream[Int] = 0 #:: 1 #:: nthFib(fibs, fibs.tail)
\end{scalacode}

\section{Stream Combinators}

- You can apply map, flatMap, filter, etc. to streams, work just like lists, but
  lazily

this code goes wrong:

\begin{scalacode}
def from(n: Int): Stream[Int] = n #:: from(n + 2)
scala> val odds = from(1)
odds: Stream[Int] = Stream(1, ?)

scala> val evsns = odds.filter(_ % 2 == 0)
\end{scalacode}

\section{Generating All Elements from two infinite streams}

\section{Generators as streams}

\section{$n$-Queens with streams} 

