\newlecture

\begin{instructor}
\section*{Lecture Outline}

\begin{enumerate}

  \item Setup a file with the \lstinline|ChessBoardLike| trait.

  \item Do $n$-queens on paper with the class.

  \item Main idea: write a recursive function that places 1 new queen that
  doesn't threaten any existing queen. Terminate when $n$ queens have been
  placed. If a queen can't be placed, \emph{backtrack}.

  \item A naive solution:

\begin{lstlisting}
class NaiveQueens(val dim: Int, val solution: Set[(Int,Int)]) extends ChessBoardLike {
  def canPlace(x: Int, y: Int): Boolean 
  def solveRec(coords: List[(Int, Int)]): Option[NaiveQueens]
  def solve(): Option[NaiveQueens]   
}
\end{lstlisting}

  \item With $n = 11$, solves instantly. $n = 12$ takes a minute.

  \item Constraint propagation: instead of checking every space, keep a list
  of available spaces.

\begin{lstlisting}
class OptQueens(val dim: Int, 
                val solution: Set[(Int, Int)], 
                available: List[(Int, Int)]) extends ChessBoardLike {
  def place(x: Int, y: Int): OptQueens
  def solveRec(coords: List[(Int, Int)]): Option[OptQueens]
  def solve(): Option[OptQueens]
}

object OptQueens {
  def empty(dim: Int): OptQueens
}  
\end{lstlisting}

  \item Randomness: use \lstinline|util.Random.shuffle| to visit spaces in a random
  order.

\end{enumerate}

\end{instructor}

\section{The $n$-Queens Problem}

The $n$-queens problem is to place $n$ queens on an $n \times n$ chessboard
such that no queens threaten each other.
If you aren't familiar with the
rules of Chess: a queen is a chess piece that move horizontally, vertically,
or diagonally across a chessboard, which is typically an $8 \times 8$ matrix.
A queen can ``kill'' any piece that it can move to, so it is unsafe to be
on the same horziontal, vertical, or diagonal line as a queen. The $n$-queens
problem is to arrange $n$-queens on a generalized $n \times n$ chessboard,
such that no pair of queens can kill each other.

The $n$-queens problem is a canonical example of a constraint-satisfaction
problem that can be solved by backtracking search. In this lecture, we'll
begin with a naive implementation of backtracking search, and then refine
it to use constraint-propagation, which will make it a lot faster.

\section{A trait for chessboards}

\begin{figure}
\scalafile{includes/nqueens/src/main/scala/ChessBoardLike.scala}
\caption{A trait for chessboards.}
\label{ChessBoardLike}
\end{figure}

Since we are going to go through a few different representations of chessboards,
it will help to factor out generic code that prints the representation of
chessboards. The \scalainline{ChessBoardLike} trait in \cref{ChessBoardLike}
defines a \scalainline{toString} method that prints a chessboard of queens,
where each queen is printed as \texttt{Q} and each blank space appears as
\texttt{.}. This printing method requires the implementing class to have
a field that specifies that dimensions of the chessboard and set of coordinates
that describe where the queens are placed.

\section{Backtracking Search}

\begin{figure}
\scalafile{includes/nqueens/src/main/scala/NaiveQueens.scala}
\caption{A naive solution to the $n$-queens problem.}
\label{NaiveQueens}
\end{figure}

The core idea of any solution to the $n$-queens problem is to write a recursive
function (called \scalainline{solve}) that places 1 new queen on the current
board in a position where it does not threaten any existing queen and then
recursively calls \scalainline{solve} to place the remaining queens. The
function terminates sucessfully when $n$ queens have been placed on the board.
The function terminates with an error if there are no positions where the next
queen can be safely placed. In any application of \scalainline{solve}, there may
be several positions where a queen can be safely placed. The key to backtracking
is to try a new position if the recursive application produces an error.

\Cref{NaiveQueens} shows a simple implementation of this idea. The key function
is the \scalainline{canPlace} predicate which determines if a new queen
maybe placed at coordinates $(x,y)$ by checking if there are any existing
queens in the set \scalainline{solution} on the same row, column, diagonal,
or antidiagonal.

\begin{instructor}
These notes could be expanded substantially in the future.
\end{instructor}

We can run the solver as follows:

\begin{scalacode}
(new NaiveQueens(n, Set())).solve()
\end{scalacode}
With $n = 11$, the solver produces a solution in less than a second on my
laptop, with $n = 12$, it takes 55 seconds, and $n = 13$ would take much longer.

\section{Constraint Propagation}

\begin{figure}
\scalafile{includes/nqueens/src/main/scala/OptQueens.scala}
\caption{A constraint-propagating solution to the $n$-queens problem.}
\label{OptQueens}
\end{figure}

\Cref{OptQueens} shows a variant of the naive solver that is substantially
faster. The key idea to store a set of locations where a queen can be placed
without violating any constraints and then prune the set whenever a new queen
is placed.
