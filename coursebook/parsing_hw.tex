\newhw{Parsing, Printing, and Evaluation}

For this assignment, you will write a parser, printer, and evaluator for arithmetic expressions.  To do so, you will (1) learn how to read a \emph{BNF grammar}, (2) learn how to use Scala's parser-combinator library, and (3) use property-based testing, using Scalatest.

\section{Preliminaries}

You should create a directory-tree that looks like this:

\dirtree{%
.1 ./parsing.
.2 build.sbt.
.2 project.
.3 plugins.sbt.
.2 src.
.3 main.
.4 scala.\DTcomment{Your solution goes here}.
.3 test.
.4 scala\DTcomment{Yours tests go here}.
}

Your \texttt{build.sbt} file must have exactly these lines:

\scalafile{../hw/parsing/template/build.sbt}

The \texttt{project/plugins.sbt} file must have exactly this line:

\scalafile{../hw/parsing/template/project/plugins.sbt}

The support code for this assignment is in the package \texttt{hw.parsing}.

\section{Overview}

For this assignment, you will work with a language of arithmetic expressions: numbers, addition, subtraction, multiplication, and division. Here are some examples of the \emph{concrete syntax} of the language:

\begin{itemize}
  \item \texttt{1 + 2}
  \item \texttt{10}
  \item \texttt{2 * 3 + 5 * -10}
  \item \texttt{2 * (3 + 5) * -10}
  \item \verb|2 * (3 + 5) ^ 2 * -10|
\end{itemize}

More formally, the concrete syntax of the language is defined using the grammar in \cref{parsing_grammar}.

\begin{figure}
\(
\begin{array}{rcl}
\mathit{number} & ::= & \texttt{-}?[\texttt{0}-\texttt{9}]+ (\texttt{.}[\texttt{0}-\texttt{9}]+)? \\
\mathit{atom} & ::= & \mathit{number} \\
              & \mid & \texttt{(} \mathit{expr} \texttt{)}  \\
\mathit{exponent} & ::= & \mathit{atom} \\
                 & \mid & \mathit{exponent} \texttt{\textasciicircum} \mathit{atom} \\
\mathit{mul} & ::= & \mathit{exponent} \\
& \mid & \mathit{mul} \texttt{*} \mathit{exponent} \\
& \mid & \mathit{mul} \texttt{/} \mathit{exponent} \\
\mathit{add} & ::= & \mathit{mul} \\
& \mid & \mathit{add} \texttt{+} \mathit{mul} \\
& \mid & \mathit{add} \texttt{-} \mathit{mul} \\
\mathit{expr} & ::= & \mathit{add}
\end{array}
\)
\caption{Grammar of arithmetic expressions}
\label{parsing_grammar}
\end{figure}

Your first task is to implement a parser that parses strings to the \scalainline{Expr} type. For example, \scalainline{parse("1 + 2")} should produce \scalainline{Add(Num(1), Num(2))}. To do so, you will use Scala's parser combinator library with Packrat parsing.

Your second task is to implement a printer, which returns strings that represent arithmetic expressions. An important property of the printer is its relationship with the parser:

\scalainline{parseExpr(print(e)) == e}, for all expressions $e$.

It is tedious to write test cases for this property, since there are so many different kinds of expressions. Instead, we will use \emph{ScalaCheck} to test this property on randomly generated expressions.

Finally, for completeness, you'll write an evaluator for arithmetic expressions.


\section{Programming Task}

\begin{figure}
\scalafile{../hw/parsing/template/src/main/scala/Solution.scala}
\caption{Template for the parser, printer, and evaluator.}
\label{parsing_template}
\end{figure}

You should use the template in \cref{parsing_template} for your solution.

We suggest proceeding in the following order:

\begin{enumerate}

\item Implement \scalainline{ArithEval}. This is a simple recursive function.

\item Implement \scalainline{ArithParser} by translating the grammar provided above to Scala's parser combinators.

\item Implement \scalainline{ArithPrinter}.

\end{enumerate}

We suggest using ScalaCheck to test these functions. (You'll have to define generators as part of your test suite.)

\section{Check Your Work}

\begin{figure}
\scalafile{../hw/parsing/template/src/test/scala/TrivialTests.scala}
\caption{Your solution must pass this test suite with no modifications.}
\label{parsing_tests}
\end{figure}

\Cref{parsing_tests} is a trivial test suite that simply ensures that you've defined the parser, printer, and evaluator with the right types.

\input{handin}
