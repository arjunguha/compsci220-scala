\newlecture

\begin{instructor}

\section*{Lecture Outline}

\begin{enumerate}

\item Define \lstinline|BinTree[+A]|.

\item Define \lstinline|def fringe[A](atree: BinTree[A]): List[A]| and write \lstinline|sameFringe| naively. Explain what's wrong with it.

\item Define \lstinline|class FringeIterator[A](atree: BinTree[A] extends Iterator[A]| and write \lstinline|sameFringe| efficiently.

\item The problem seems fundamentally imperative, isn't it?

\item Introduce by-name arguments, using \lstinline|println| to observe the order of operations.

\item Define \lstinline|Generator[T]| with \lstinline|hasNext| and \lstinline|next| methods. Refactor \lstinline|next| to produce \lstinline|Option[(T, Generator[T])]|.

\item Write a generator of three values manually.

\item Introduce the functions \lstinline|zero|, \lstinline|one|, and \lstinline|append| (using by-name arguments).

\item Add the \lstinline|++| method to \lstinline|Generator[T]|.

\item Write the fringe-generator.

\item Notice that the fringe generator looks a lot like the function that returns the fringe as a list!

\end{enumerate}

\end{instructor}

\section{The \emph{Same Fringe} Problem}



\begin{figure}
\begin{scalacode}
def fringe[A](t: BinTree[A]): List[A] = t match { case Leaf(x) =>
  List(x) case Node(lhs, rhs) => fringe(lhs) ++ fringe(rhs) }
\end{scalacode}
\caption{Recursively calculating the fringe of a binary tree.}
\label{fringeRec}
\end{figure}

Given a binary tree:

\begin{scalacode}
sealed trait BinTree[+A]
case class Node[A](lhs: BinTree[A], rhs: BinTree[A]) extends BinTree[A]
case class Leaf[A](x: A) extends BinTree[A]
\end{scalacode}

The \emph{fringe} of a binary tree are the values in left-to-right order. For
example, the fringe of the following tree:
\begin{scalacode}
val t1 = Node(Leaf(10), Node(Leaf(20), Leaf(40)))
\end{scalacode}
is $10$, $20$, and $40$, in that order. The \emph{same-fringe problem} is to write
a function to determine if two trees have the same fringe. For
example the following tree:
%
\begin{scalacode}
val t2 = Node(Node(Leaf(10), Leaf(20)), Leaf(40))
\end{scalacode}
Has the same fringe as \scalainline{t1}.

We can write a simple recursive function to calculate the fringe of a tree,
as shown in \cref{fringeRec}, so a simple solution to the same-fringe problem
is:
\begin{scalacode}
fringe(t1) == fringe(t2)
\end{scalacode}

But, this is not a very efficient solution:
\begin{itemize}

  \item If the trees are very large, we'll spend a lot of time appending
  lists, and

  \item If the fringes are different, we'll generate the entire fringe instead
  of terminating as soon as a difference is detected.

\end{itemize}

\section{An Imperative Solution}

\begin{figure}
\begin{scalacode}
class FringeIterator[A](tree: BinTree[A]) extends Iterator[A] {
  private val stack = collection.mutable.Stack(tree)
  def hasNext = stack.isEmpty
  def next() = {
    val top = stack.pop()
    top match {
      case Leaf(x) => x
      case Node(lhs, rhs) => { stack.push(rhs); stack.push(lhs); next() }
    }
  }
}

def sameFringe[A](t1: BinTree[A], t2: BinTree[A]): Boolean = {
  val iter1 = new FringeIterator(t1)
  val iter2 = new FringeIterator(t2)
  while (iter1.hasNext && iter2.hasNext) {
    val x = iter1.next
    val y = iter2.next
    if (x != y) {
      return false
    }
  }
  return !iter1.hasNext && !iter2.hasNext
}
\end{scalacode}
\caption{An imperative solution.}
\label{samefringe_imperative}
\end{figure}

A typical Java solution to this problem, which is straightforward to
reproduce in Scala, is to use an iterator. You've seen simple
iterators for lists and arrays before.  You can also write an iterator
that iterates over the fringe of a tree.  The key idea is this:
before we descend into the left-hand side of a node to generate its
fringe, we need to store the right-hand side of the node in a variable so that
we don't forget to generate its fringe. Since the tree may be arbitrarily deep, we
may need to remember a stack of nodes.

\begin{think}
What would happen if we used a queue of nodes?
\end{think}

An iterator that uses this idea is shown in \cref{samefringe_imperative} along with a
solution to the same-fringe problem that doesn't have the two issues we identified
above. An unusual feature of this solution is that it uses two iterators simultaneously
in a single loop.

What's interesting about this problem is that the solution seems to be fundamentally
imperative. In particular, each invocaation of \verb|.next| returns the next value, which
means that the iterators \emph{must} use mutable state internally. Is it possible to solve
this problem without state?

\begin{think}
  Try to solve the problem before proceeding further.
\end{think}

\section{By-Name Arguments}

\begin{figure}
\begin{scalacode}
def g(): Int = {
  println("Evaluating g")
  10
}

def f1(x: Int) = {
  println("Evaluating f1")
  x + 10
}
f1(g())
\end{scalacode}
\caption{Which line prints first?}
\label{evalorder1}
\end{figure}

When you apply a function in Scala (and in most other programming languages), the argument
of the function is first reduced to a value and then that value is passed to the function.
For example, in \scalainline{f(2 + 3)}, the expression \scalainline{2 + 3} is first reduced
to the value \scalainline{5} and then \scalainline{f(5)} is applied.

\begin{think}
  Is the statement above true? Can you think of a way to experimentally validate the
  claim that arguments are reduced to values before they are passed to functions?
 \end{think}

Consider the two functions in \cref{evalorder1} and the expression
\scalainline{f1(g())}.  If the argument is evaluated first, then
``Evaluating g'' will print before ``evaluating f''. Conversely, if
the expression \scalainline{g()} is passed to \scalainline{f1} unevaluated
and only evaluated when it is needed, then we'd expect the lines to print in the opposite
order. If you try this out, you'll find that the former is true, thus validating the
claim.

However, Scala allows you to change the order of evaluation.
In the following function, the \scalainline{=>} annotation means that the argument
is only evaluated when it is \emph{needed}:
\begin{scalacode}
def f2(x: => Int) = {
  println("Evaluating f2")
  x + 10
}
\end{scalacode}
Therefore, the expression \scalainline{f2(g())} prints ``Evaluating f2'' before it prints
``Evaluating g'', since the value of \scalainline{g()} is not needed until after
``Evaluating f2'' is printed.

The following function ignores its argument:
\begin{scalacode}
def f3(x: => Int) = {
  println("Evaluating f3")
  10
}
\end{scalacode}

Therefore, \scalainline{f3(g())} does not evaluate \scalainline{g()}
at all, so ``Evaluating g'' is not printed. In fact, you can even
write \scalainline{f3(throw new Exception("bad"))} and the exception
will not be thrown.

By-name arguments have several applications and are used extensively in the
Scala standard library. For example, Scala maps have a \scalainline{.get} method
that optionally returns a value stored in a map:
\begin{scalacode}
val m = Map("X" -> 1 )
val v = m.get(key) // produces Some(1) if key is "X", otherwise None
val v2 = m.get("Z") // produces None
\end{scalacode}
Suppose we were using maps in a program and that we wanted to return a default value 0
instead of \scalainline{None}. We could write:
\begin{scalacode}
m.get(key) match {
  case Some(v) => v
  case None => 0
}
\end{scalacode}
Alternatively, we could simply write \scalainline{m.getOrElse(key, 0)}. It turns out
that the second argument of this method is a by-name argument. Therefore, we can
write \scalainline{m.getOrElse(key, f())} and be assured that \scalainline{f} will not
be applied unless it is needed. It is safe to write, even if \scalainline{f()} is
an expensive computation that should only be run if \scalainline{key} is not
in the map. We could even write \scalainline{m.getOrElse(key, throw new Exception(...))}
to throw a custom exception if \scalainline{key} is not found.

\section{Functional Generators}

The reason that iterators cannot be functional is evident in the type for iterators. The
\verb|Iterator<T>| interface is part of the Java standard library and it corresponds to
the following Scala trait:
\begin{scalacode}
trait Iterator[T] {
  def hasNext(): Boolean
  def next(): T
  def remove(): Unit // not relevant for our discussion
}
\end{scalacode}
Recall that a key property of functional programs is that a function (or method) always produces
the same result when applies to the same arguments. In this interface, the \scalainline{next()} method
takes zero arguments. Therefore, if an implementation of \scalainline{Iterator[T]} were written
functionally, it could only ever produce one result.

To allow functional programming to work, we're going to have to work with a new kind of iterator,
which we'll call a \emph{generator}, where the \scalainline{next} method produces the next value
and \emph{a new generator that generates the rest of the collection}:
%
\begin{scalacode}
trait Generator[T] {
  def hasNext(): Boolean
  def next(): (T, Generator[T])
}
\end{scalacode}

An important detail of iterators that isn't obvious from the type, is that the \scalainline{next} method
will throw an exception if \scalainline{hasNext} produces \scalainline{false}.  Instead of throwing an exception,
we can make this behavior manifest in the type, by eliminating \scalainline{hasNext} method and changing the type
of \scalainline{next} to optionally produce an element and a generator.
%
\begin{scalacode}
trait Generator[T] {
  def next(): Option[(T, Generator[T])]
}
\end{scalacode}

We can now write some a functional generator. For example, here is a generator that produces three numbers:
\begin{scalacode}
val agen = new Generator[Int] {
  def next() = Some((1, new Generator[Int] {
                          def next() = Some((2, new Generator[Int] {
                                                 def next() = Some((3, new Generator[Int] {
                                                                        def next() = None
                                                                       }))
                                                }))
                        }))
}
\end{scalacode}

Here is a simple function that prints all the elements generated by any generator, including the
one above:
\begin{scalacode}
def printAll[T](gen: Generator[T]): Unit = gen.next() match {
  case None => ()
  case Some((x, rest)) => println(x); printAll(rest)
}
\end{scalacode}

\paragraph{Combining Generators} You probably agree that the definition of \scalainline{agen} is 
too unwieldy. To make generators easier to write, we are going to define three generator building
functions:

\begin{enumerate}

  \item The function \scalainline{zero[T]()} produces a generator that generates zero values of type \scalainline{T}:

  \begin{scalacode}
  def zero[T](): Generator[T] = new Generator[T] { def next() = None }
  \end{scalacode}

  \item The function \scalainline{one(x)} produces a generator that only generates the value \scalainline{x}:

  \begin{scalacode}
  def one[T](x: T): Generator[T] = new Generator[T] { def next() = Some((x, zero[T]())) }
  \end{scalacode}

  \item The function \scalainline{append(gen1, gen2)} takes two generators as arguments and first generates the
  values of \scalainline{gen1} and then the values of \scalainline{gen2}. Furthermore, to avoid generating values
  we don't need, the arguments are passed by-name:

\begin{scalacode}
def append[T](gen1: => Generator[T], gen2: => Generator[T]): Generator[T] = new Generator[T] { 
  def next() = gen1.next match {
    case None => gen2.next
    case Some((x, gen1Rest)) => Some((x, append(gen1Rest, gen2)))
  }
}
\end{scalacode}

To make \scalainline{append} easier to use, we can modify the \scalainline{Generator[T]} trait to include an operator
that invokes \scalainline{append}:
\begin{scalacode}
trait Generator[T] {
  def next(): Option[(T, Generator[T])] // as before
  def ++(other: => Generator[T]): Generator[T] = append(this, other)
}
\end{scalacode}

\end{enumerate}

Using these functions, we can write a generator that generates the fringe of a binary tree:
%
\begin{scalacode}
def fringe[T](t: BinTree[T]): Generator[T] = t match {
  case Leaf(x) => one(x)
  case Node(lhs, rhs) => fringe(lhs) ++ fringe(rhs)
}
\end{scalacode}
%
Notice that it is very similar to the function that generates the fringe as a list. However, it behaves quite differently.
Since the append (\scalainline{++}) operation evaluates its arguments only when needed, it doesn't immediately visit all the
leaves of the tree, which was the problem with the original function.

The following function takes two generators and produces \scalainline{true} if the  generate exactly the same values:
\begin{scalacode}
def sameGen[T](gen1: Generator[T], gen2: Generator[T]): Boolean = (gen1.next, gen2.next) match {
  case (None, None) => true
  case (Some((x, rest1)), Some((y, rest2))) => x == y && sameGen(rest1, rest2)
  case _ => false
}
\end{scalacode}
If the supplied generators only generate values on need, the \scalainline{sameGen} function will abort early and produce
\scalainline{false} if (1) it  encounters two values \scalainline{x != y} or (2) one generator runs out of values before 
the other. Notice that \scalainline{sameGen} has the exactly the same structure as the obvious recursive function that
checks if two lists are equal.

Finally, we can write the \scalainline{sameFringe} function that we wanted as follows:
\begin{scalacode}
def sameFringe[T](t1: BinTree[T], t2: BinTree[T]) = sameGen(fringe(t1), fringe(t2))
\end{scalacode}

\begin{think}
How would you verify that this version of \scalainline{sameFringe} truly aborts early and doesn't incorrectly traverse both
trees when it isn't necessary?
\end{think}

\paragraph{More Generators}

It is staightforward to define other handy generator-building functions. For example, it is easy to define functions
that are analogous to \scalainline{map}, \scalainline{filter}, and \scalainline{fold} for lists. You can even write
a function to flatten a generator-generator into a simple generator:
\begin{scalacode}
def flatten[T](gen: Generator[Generator[T]]): Generator[T] = new Generator[T] {
  def next() = gen.next match {
    case None => None
    case Some((x, rest)) => (x ++ flatten(rest)).next
  }
}
\end{scalacode}



