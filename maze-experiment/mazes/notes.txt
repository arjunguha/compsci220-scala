Maze solver

Issues:
- BFS and Dijkstra's are NOT recursive algorithms. Adding recursion makes them
  ugly, unwieldly, and difficult to use. --> This is fine
- DFS, BFS and Dijkstra's pretty much require mutability.

- How to represent mazes
    - Typically represented w/ 2D array
    - Not necessarily a DAG
    - case class Node(north, east, south, west: Maze)
    - case class Start(north, east, south, west: Maze)
    - case class Finish()
    - case class DeadEnd()
- Solving the maze
    - Dijkstra's? (Shortest path) (would require adding lengths to paths)
    - Depth First Search? (A path)
    - Breadth First Search? (Shortest path)
- "Driving directions"
    - Create list of instructions from path
    - We provide a "walker" that consumes instructions
    - If the maze is in terms of N/E/S/W, then this could be Left, Right and
      Forward.

To represent maze, use graph -> adjacency list
Start location -> always 0,0
Finish location -> any x,y
Walls are not recorded? But need n/s/e/w...

BFS:
- Add the start node to the queue
- Add the start node to the visited set
- Dequeue an element
    - if it is finish, return ???
    - add every adjacent node to the queue
    - Loop.

Meeting notes:
- Let maze have cycles
- Present maze as graph with lengths
- DFS or BFS and Dijkstra's -- with paths
- Driving directions
